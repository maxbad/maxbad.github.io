<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.myxy.net</id>
    <title>Maxbad`Blog</title>
    <updated>2021-03-06T03:12:26.241Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.myxy.net"/>
    <link rel="self" href="https://blog.myxy.net/atom.xml"/>
    <subtitle>记录一些东西</subtitle>
    <logo>https://blog.myxy.net/images/avatar.png</logo>
    <icon>https://blog.myxy.net/favicon.ico</icon>
    <rights>All rights reserved 2021, Maxbad`Blog</rights>
    <entry>
        <title type="html"><![CDATA[线程安全-map]]></title>
        <id>https://blog.myxy.net/xian-cheng-an-quan-map/</id>
        <link href="https://blog.myxy.net/xian-cheng-an-quan-map/">
        </link>
        <updated>2021-03-06T03:11:58.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-cpp">#pragma once
#include &lt;map&gt;
#include &lt;mutex&gt;

template&lt;typename Key, typename Val&gt;
class SafeMap
{
public:
	typedef typename std::map&lt;Key, Val&gt;::iterator this_iterator;
	typedef typename std::map&lt;Key, Val&gt;::const_iterator this_const_iterator;
	Val&amp; operator [](const Key&amp; key)
	{
		std::lock_guard&lt;std::mutex&gt; lk(mtx_);
		return dataMap_[key];
	}

	int erase(const Key&amp; key)
	{
		std::lock_guard&lt;std::mutex&gt; lk(mtx_);
		return dataMap_.erase(key);
	}

	this_iterator find(const Key&amp; key)
	{
		std::lock_guard&lt;std::mutex&gt; lk(mtx_);
		return dataMap_.find(key);
	}

	this_const_iterator find(const Key&amp; key) const
	{
		std::lock_guard&lt;std::mutex&gt; lk(mtx_);
		return dataMap_.find(key);
	}

	this_iterator end()
	{
		return dataMap_.end();
	}

	this_const_iterator end() const
	{
		return dataMap_.end();
	}

private:
	std::map&lt;Key, Val&gt; dataMap_;
	std::mutex mtx_;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程安全-队列]]></title>
        <id>https://blog.myxy.net/xian-cheng-an-quan-dui-lie/</id>
        <link href="https://blog.myxy.net/xian-cheng-an-quan-dui-lie/">
        </link>
        <updated>2021-03-06T03:11:00.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-cpp">#pragma once
#include &lt;iostream&gt;
#include &lt;condition_variable&gt;
#include &lt;mutex&gt;
#include &lt;queue&gt;
#include &lt;memory&gt;

/*
*
 * 线程安全队列
 * T为队列元素类型
 * 因为有std::mutex和std::condition_variable类成员,所以此类不支持复制构造函数也不支持赋值操作符(=)
 *
 * 来源: https://blog.csdn.net/u011726005/article/details/82670730
 */
template&lt;class T, class Container = std::queue&lt;T&gt;&gt;
class ThreadSafeQueue {
public:
	ThreadSafeQueue() = default;

	// 将元素加入队列
	template &lt;class Element&gt;
	void Push(Element&amp;&amp; element) {
		std::lock_guard&lt;std::mutex&gt; lock(mutex_);
		queue_.push(std::forward&lt;Element&gt;(element));
		not_empty_cv_.notify_one();
	}

	// 从队列中弹出一个元素,如果队列为空就阻塞
	void WaitAndPop(T&amp; t) {
		std::unique_lock&lt;std::mutex&gt; lock(mutex_);
		not_empty_cv_.wait(lock, [this]() {
			return !queue_.empty();
			});

		t = std::move(queue_.front());
		queue_.pop()
	}

	// 从队列中弹出一个元素,如果队列为空就阻塞
	std::shared_ptr&lt;T&gt; WaitAndPop() {
		std::unique_lock&lt;std::mutex&gt; lock(mutex_);
		not_empty_cv_.wait(lock, [this]() {
			return !queue_.empty();
			});

		std::shared_ptr&lt;T&gt; t_ptr = std::make_shared&lt;T&gt;(queue_.front());
		queue_.pop();

		return t_ptr;
	}

	// 从队列中弹出一个元素,如果队列为空返回false
	bool TryPop(T&amp; t) {
		std::lock_guard&lt;std::mutex&gt; lock(mutex_);
		if (queue_.empty()) {
			return false;
		}

		t = std::move(queue_.front());
		queue_.pop();
		return true;
	}

	// 从队列中弹出一个元素,如果队列为空返回空指针
	std::shared_ptr&lt;T&gt; TryPop() {
		std::lock_guard&lt;std::mutex&gt; lock(mutex_);
		if (queue_.empty()) {
			return std::shared_ptr&lt;T&gt;();
		}

		t = std::move(queue_.front());
		std::shared_ptr&lt;T&gt; t_ptr = std::make_shared&lt;T&gt;(queue_.front());
		queue_.pop();

		return t_ptr;
	}

	// 返回队列是否为空
	bool IsEmpty() const {
		std::lock_guard&lt;std::mutex&gt; lock(mutex_);
		return queue_.empty();
	}

	// 返回队列中元素数个
	size_t size() {
		std::lock_guard&lt;std::mutex&gt; lock(mutex_);
		return queue_.size();
	}

private:
	ThreadSafeQueue(const ThreadSafeQueue&amp;) = delete;
	ThreadSafeQueue&amp; operator=(const ThreadSafeQueue&amp;) = delete;
	ThreadSafeQueue(ThreadSafeQueue&amp;&amp;) = delete;
	ThreadSafeQueue&amp; operator=(ThreadSafeQueue&amp;&amp;) = delete;

private:
	Container queue_;

	std::condition_variable not_empty_cv_;
	mutable std::mutex mutex_;
};

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[番茄的一些记录]]></title>
        <id>https://blog.myxy.net/fan-qie-de-yi-xie-ji-lu/</id>
        <link href="https://blog.myxy.net/fan-qie-de-yi-xie-ji-lu/">
        </link>
        <updated>2021-01-25T07:40:17.000Z</updated>
        <content type="html"><![CDATA[<h1 id="快捷键">快捷键</h1>
<table>
<thead>
<tr>
<th>快捷键</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>alt+o</td>
<td style="text-align:left">换 .h 和 .cpp</td>
</tr>
<tr>
<td>alt+shift+o</td>
<td style="text-align:left">全局找文件</td>
</tr>
<tr>
<td>alt+shift+s</td>
<td style="text-align:left">全局找符号</td>
</tr>
<tr>
<td>alt+shift+f</td>
<td style="text-align:left">全局找当前光标符号</td>
</tr>
<tr>
<td>f8</td>
<td style="text-align:left">ctrl+shift+f 之后 f8，查找下一个当前光标符号的引用，这个不是 vax 的功能，是 vs 自带的</td>
</tr>
<tr>
<td>alt+g</td>
<td style="text-align:left">找定义</td>
</tr>
<tr>
<td>alt+shift+g</td>
<td style="text-align:left">找继承关系</td>
</tr>
<tr>
<td>alt+shift+q</td>
<td style="text-align:left">添加 include</td>
</tr>
<tr>
<td>alt+shift+r</td>
<td style="text-align:left">重构</td>
</tr>
<tr>
<td>ctrl+k,ctrl+s</td>
<td style="text-align:left">包裹代码</td>
</tr>
<tr>
<td>alt+m</td>
<td style="text-align:left">当前文件方法</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[std::string 构造函数]]></title>
        <id>https://blog.myxy.net/stdstring-gou-zao-han-shu/</id>
        <link href="https://blog.myxy.net/stdstring-gou-zao-han-shu/">
        </link>
        <updated>2021-01-11T03:28:26.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>1,将构造的对象初始化为s的前n个字符，s不够n个时将相邻的内存单元的内容当作s的一部分继续复制:<br>
<code>string(const char *s, size_type n, const Allocator &amp;a = Allocator());</code></p>
<pre><code class="language-cpp">  std::string testStr(&quot;Telephone home.&quot;, 4);
  OutputDebugStringA(testStr.c_str());
  // 输出:Tele
</code></pre>
</li>
<li>
<p>2,将构造的对象初始化为s的后n个字符，也就是从s指向的内存的第n个字节开始复制：<br>
<code>string(const string &amp;str, size_type pos,size_type n = npos, const Allocator &amp;a = Allocator());</code></p>
</li>
</ul>
<pre><code class="language-cpp">    std::string text(&quot;Telephone home.&quot;);
    std::string testStr(text, 4);
    OutputDebugStringA(testStr.c_str());
    // 输出:phone home.
</code></pre>
<ul>
<li>3,创建一个n个字符的string对象：<br>
<code>string(size_type n, char c, const Allocator &amp;a = Allocator())</code><pre><code class="language-cpp">  std::string testStr(10, 'a');
  OutputDebugStringA(testStr.c_str());
  // 输出:aaaaaaaaaa
</code></pre>
</li>
</ul>
<p>其他文档:<a href="http://c.biancheng.net/view/1443.html">http://c.biancheng.net/view/1443.html</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue项目打包时，去掉console.log输出]]></title>
        <id>https://blog.myxy.net/vue-xiang-mu-da-bao-shi-qu-diao-consolelog-shu-chu/</id>
        <link href="https://blog.myxy.net/vue-xiang-mu-da-bao-shi-qu-diao-consolelog-shu-chu/">
        </link>
        <updated>2021-01-09T06:50:20.000Z</updated>
        <content type="html"><![CDATA[<p>安装插件：<code>npm install babel-plugin-transform-remove-console --save-dev</code></p>
<p>在<code>babel.config.js</code>文件的<code>plugins</code>中添加<code>transform-remove-console</code>，此时再build就不会有console警告了。</p>
<pre><code class="language-java">// 项目发布阶段需要用到的Babel插件
const prodPlugins = []
if (process.env.NODE_ENV === 'production') {
  prodPlugins.push('transform-remove-console')
}
module.exports = {
  presets: [
    '@vue/cli-plugin-babel/preset'
  ],
  plugins: [
    [
      'component',
      {
        libraryName: 'element-ui',
        styleLibraryName: 'theme-chalk'
      }
    ],
    // 发布产品时候的插件数组
    ...prodPlugins
  ]
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[proxy配置]]></title>
        <id>https://blog.myxy.net/proxy-pei-zhi/</id>
        <link href="https://blog.myxy.net/proxy-pei-zhi/">
        </link>
        <updated>2020-12-26T11:29:57.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-js">const address = require('address');
devServer: {
        publicPath: Setting.publicPath,
        host: address.ip(),
        noInfo: false,
        progress: true // 将运行进度输出到控制台。
         openPage: 'admin/version', // 默认打开页
         proxy: {
            '/v1': {
                target: 'http://' + address.ip() + ':8098',
                changeOrigin: true, // 是否跨域
                onProxyReq: function (proxyReq, req, res, options) {
                    console.log('发送', req.method, req.url);

                    if (req.body) {
                        console.log('发送 Body', req.body);
                    }
                },
                onProxyRes: function (proxyRes, req, res) {
                    console.log('收到', req.method, req.url);

                    let body = [];
                    proxyRes.on('data', function (chunk) {
                        body.push(chunk);
                    });
                    proxyRes.on('end', function () {
                        body = Buffer.concat(body).toString();
                        console.log('收到 Body', body);
                        // res.end('my response to cli');
                    });
                },
                onError: function (err, req, res) {
                    console.log('代理错误消息', err);
                },
                logLevel: 'debug'
            }
        } 
    },
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[prettier 配置]]></title>
        <id>https://blog.myxy.net/prettier-pei-zhi/</id>
        <link href="https://blog.myxy.net/prettier-pei-zhi/">
        </link>
        <updated>2020-12-22T03:42:30.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode">https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode</a></p>
<blockquote>
<p>自动格式化整理代码，vscode 需要去插件商店下载【Prettier - Code formatter 】这个插件</p>
</blockquote>
<pre><code class="language-json">{
  &quot;[vue]&quot;: {
    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;
  },
  &quot;editor.quickSuggestions&quot;: {
    &quot;strings&quot;: true
  },
  &quot;editor.tabSize&quot;: 2,
  &quot;editor.detectIndentation&quot;: false,
  &quot;emmet.triggerExpansionOnTab&quot;: true,
  &quot;editor.formatOnSave&quot;: true,
  &quot;javascript.format.enable&quot;: true,
  &quot;[json]&quot;: {
    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;
  },
  &quot;explorer.confirmDelete&quot;: false,
  &quot;javascript.updateImportsOnFileMove.enabled&quot;: &quot;always&quot;,
  &quot;typescript.updateImportsOnFileMove.enabled&quot;: &quot;always&quot;,
  &quot;files.exclude&quot;: {
    &quot;**/.idea&quot;: true
  },
  &quot;editor.codeActionsOnSave&quot;: {
    &quot;source.fixAll.stylelint&quot;: true,
    &quot;source.fixAll.eslint&quot;: true
  },
  &quot;[javascript]&quot;: {
    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;
  },
  &quot;[scss]&quot;: {
    &quot;editor.defaultFormatter&quot;: &quot;HookyQR.beautify&quot;
  },
  &quot;[jsonc]&quot;: {
    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;
  },
  &quot;[html]&quot;: {
    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;
  },
  &quot;editor.suggest.snippetsPreventQuickSuggestions&quot;: false,
  &quot;prettier.htmlWhitespaceSensitivity&quot;: &quot;ignore&quot;,
  &quot;prettier.vueIndentScriptAndStyle&quot;: true,
  &quot;vetur.format.defaultFormatter.html&quot;: &quot;prettier&quot;,
  &quot;files.autoSave&quot;: &quot;onFocusChange&quot;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ for遍历循环表达示 auto, auto&, auto&&]]></title>
        <id>https://blog.myxy.net/c-for-bian-li-xun-huan-biao-da-shi-auto-autoand-autoand/</id>
        <link href="https://blog.myxy.net/c-for-bian-li-xun-huan-biao-da-shi-auto-autoand-autoand/">
        </link>
        <updated>2020-12-18T06:44:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="创建拷贝无法修改dataarr中的元素">创建拷贝，无法修改dataArr中的元素</h2>
<pre><code class="language-cpp">for(auto x : dataArr)
</code></pre>
<h2 id="参考引用可以修改dataarr中的元素但一般用第二种">参考引用，可以修改dataArr中的元素，但一般用第二种</h2>
<pre><code class="language-cpp">for(auto&amp; iter : dataArr)
for(auto&amp;&amp; iter : dataArr)
</code></pre>
<h2 id="只读引用不能修改dataarr中的元素">只读引用，不能修改dataArr中的元素</h2>
<pre><code class="language-cpp">for(const auto&amp; iter : dataArr)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ 类中的构造函数]]></title>
        <id>https://blog.myxy.net/c-lei-zhong-de-gou-zao-han-shu/</id>
        <link href="https://blog.myxy.net/c-lei-zhong-de-gou-zao-han-shu/">
        </link>
        <updated>2020-12-16T11:33:37.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/explicitly-defaulted-and-deleted-functions?view=msvc-160">https://docs.microsoft.com/zh-cn/cpp/cpp/explicitly-defaulted-and-deleted-functions?view=msvc-160</a></p>
<h2 id="编译器默认为一个类生成的默认函数">编译器默认为一个类生成的默认函数</h2>
<ul>
<li>默认构造函数</li>
<li>默认析构函数</li>
<li>默认拷贝构造函数</li>
<li>默认赋值函数</li>
<li>移动构造函数</li>
<li>移动拷贝函数</li>
</ul>
<pre><code class="language-cpp">class DataOnly {
public:
    DataOnly ()                  // 默认构造函数
    ~DataOnly ()                 // 默认析构函数

    DataOnly (const DataOnly &amp; rhs)         　 　  // 默认拷贝构造函数
    DataOnly &amp; operator=(const DataOnly &amp; rhs)    // 默认赋值函数

    DataOnly (const DataOnly &amp;&amp; rhs)         // C++11, 移动构造函数
    DataOnly &amp; operator=(DataOnly &amp;&amp; rhs)    // C++11, 移动拷贝函数
};
</code></pre>
<p>类不可复制的通用写法</p>
<pre><code class="language-cpp">struct noncopyable
{
  noncopyable() =default;
  noncopyable(const noncopyable&amp;) =delete;
  noncopyable&amp; operator=(const noncopyable&amp;) =delete;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[hpSocket线程池]]></title>
        <id>https://blog.myxy.net/hpsocket-xian-cheng-chi/</id>
        <link href="https://blog.myxy.net/hpsocket-xian-cheng-chi/">
        </link>
        <updated>2020-12-10T02:50:46.000Z</updated>
        <content type="html"><![CDATA[<p>HP-Socket v5.4.x版本开始，提供线程池组件IHPThreadPool，协助用户实现通信逻辑与业务逻辑分离，提高应用程序的整体执行效率。IHPThreadPool提供以下主要操作方法。这些方法成功返回TRUE，失败返回FALSE，失败可通过SYS_GetLastError() 获取系统错误代码。</p>
<h2 id="启动线程池">启动线程池</h2>
<pre><code class="language-cpp">BOOL Start(dwThreadCount = 0, dwMaxQueueSize = 0, enRejectedPolicy = TRP_CALL_FAIL, dwStackSize = 0)

dwThreadCount  线程数量，（默认：0）
&gt;0 ：dwThreadCount
=0 ：(CPU核数 * 2 + 2)
&lt;0 ：(CPU核数 * (-dwThreadCount))
dwMaxQueueSize  任务队列最大容量（默认：0，不限制）
enRejectedPolicy  任务拒绝处理策略
TRP_CALL_FAIL	：（默认）立刻返回失败
TRP_WAIT_FOR	：等待（直到成功、超时或线程池关闭等原因导致失败）
TRP_CALLER_RUN	：调用者线程直接执行
dwStackSize  线程堆栈空间大小（默认：0 -&gt; 操作系统默认）
</code></pre>
<h2 id="关闭线程池">关闭线程池</h2>
<blockquote>
<p>在规定时间内关闭线程池组件，如果工作线程在最大等待时间内未能正常关闭，会尝试强制关闭，这种情况下很可能会造成系统资源泄漏。</p>
</blockquote>
<pre><code class="language-cpp">BOOL Stop(dwMaxWait = INFINITE)

dwMaxWait  最大等待时间（毫秒，默认：INFINITE，一直等待）
</code></pre>
<h2 id="提交任务">提交任务</h2>
<pre><code class="language-cpp">BOOL Sbumit(fnTaskProc, pvArg, dwMaxWait = INFINITE)

fnTaskProc  任务处理函数
pvArg  任务参数
dwMaxWait  任务提交最大等待时间（仅对TRP_WAIT_FOR类型线程池生效，默认：INFINITE，一直等待）。
** SYS_GetLastError() 错误码ERROR_DESTINATION_ELEMENT_FULL表示任务队列已满。
</code></pre>
<h2 id="提交socket任务">提交Socket任务</h2>
<pre><code class="language-cpp">BOOL Sbumit(pTask, dwMaxWait = INFINITE)

pTask  任务参数
dwMaxWait  任务提交最大等待时间（仅对TRP_WAIT_FOR类型线程池生效，默认：INFINITE，一直等待）
** SYS_GetLastError() 错误码ERROR_DESTINATION_ELEMENT_FULL表示任务队列已满。
</code></pre>
<h2 id="动态调整线程池大小">动态调整线程池大小</h2>
<pre><code class="language-cpp">BOOL AdjustThreadCount(dwNewThreadCount)

dwNewThreadCount  线程数量
&gt;0 ：dwNewThreadCount
=0 ：(CPU核数 * 2 + 2)
&lt;0 ：(CPU核数 * (-dwNewThreadCount))
</code></pre>
]]></content>
    </entry>
</feed>