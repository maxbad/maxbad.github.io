<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.myxy.net</id>
    <title>Maxbad`Blog</title>
    <updated>2020-07-07T16:21:02.579Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.myxy.net"/>
    <link rel="self" href="https://blog.myxy.net/atom.xml"/>
    <subtitle>记录一些东西</subtitle>
    <logo>https://blog.myxy.net/images/avatar.png</logo>
    <icon>https://blog.myxy.net/favicon.ico</icon>
    <rights>All rights reserved 2020, Maxbad`Blog</rights>
    <entry>
        <title type="html"><![CDATA[vue]]></title>
        <id>https://blog.myxy.net/vue/</id>
        <link href="https://blog.myxy.net/vue/">
        </link>
        <updated>2020-07-07T15:26:02.000Z</updated>
        <content type="html"><![CDATA[<h3 id="创建项目">创建项目:</h3>
<p><code>vue init webpack test1</code></p>
<blockquote>
<p>配置项目</p>
</blockquote>
<h4 id="如果创建失败则重新安装一次vue-cli">如果创建失败则重新安装一次vue-cli:</h4>
<p><code>cnpm install -gd vue-cli</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SmartSniff过滤器的规则]]></title>
        <id>https://blog.myxy.net/smartsniff-guo-lu-qi-de-gui-ze/</id>
        <link href="https://blog.myxy.net/smartsniff-guo-lu-qi-de-gui-ze/">
        </link>
        <updated>2020-07-02T08:24:13.000Z</updated>
        <content type="html"><![CDATA[<p>显示:<code>include</code><br>
排除:<code>exclude</code></p>
<p>本地:<code>local</code><br>
远程:<code>remote</code><br>
双向:<code>both</code></p>
<p>[<code>include</code>|<code>exclude</code>] : [<code>local</code>|<code>remote</code>|<code>both</code>] : [<code>tcp</code>|<code>udp</code>|<code>tcpudp</code>|<code>icmp</code>|<code>all</code>] : [<code>IP Range</code>|<code>Ports Range</code>]</p>
<p>[<code>显示</code>|<code>排除</code>] : [<code>本地</code>|<code>远程</code>|<code>双向</code>] : [<code>tcp</code>|<code>udp</code>|<code>tcpudp</code>|<code>icmp</code>|<code>all</code>] : [<code>ip地址范围</code>|<code>端口范围</code>]</p>
<p>例如在菜单：options-&gt;Display Filter中添加如下语句：<br>
include:local:all:6434，就会只显示服务器端口为6434和本机的抓包信息</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[uinapp]]></title>
        <id>https://blog.myxy.net/uinapp/</id>
        <link href="https://blog.myxy.net/uinapp/">
        </link>
        <updated>2020-07-01T12:26:45.000Z</updated>
        <content type="html"><![CDATA[<h3 id="初始化npm工程">初始化npm工程:</h3>
<blockquote>
<p>若项目之前未使用npm管理依赖（项目根目录下无package.json文件），先在项目根目录执行命令初始化npm工程：</p>
</blockquote>
<pre><code>npm init -y
</code></pre>
<h3 id="安装依赖">安装依赖</h3>
<blockquote>
<p>在项目根目录执行命令安装npm包：</p>
</blockquote>
<pre><code>npm install packageName --save
</code></pre>
<h3 id="使用">使用</h3>
<blockquote>
<p>安装完即可使用npm包，js中引入npm包：</p>
</blockquote>
<pre><code>import package from 'packageName'
const package = require('packageName')
</code></pre>
<h3 id="跳转tabbar页">跳转tabbar页:</h3>
<pre><code>uni.switchTab({
    url: '/pages/tabBar/component/component'
});
</code></pre>
<h3 id="向本地存储中设置值">向本地存储中设置值</h3>
<pre><code>uni.setStorage({
        key: 'launchFlag',
        data: true,
});
</code></pre>
<h3 id="从本地缓存中同步获取指定-key-对应的内容">从本地缓存中同步获取指定 key 对应的内容。</h3>
<blockquote>
<p>https://uniapp.dcloud.io/api/storage/storage?id=getstoragesync</p>
</blockquote>
<pre><code>try {
    const value = uni.getStorageSync('storage_key');
    if (value) {
        console.log(value);
    }
} catch (e) {
    // error
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[宝塔nginx配置]]></title>
        <id>https://blog.myxy.net/bao-ta-nginx-pei-zhi/</id>
        <link href="https://blog.myxy.net/bao-ta-nginx-pei-zhi/">
        </link>
        <updated>2020-06-24T01:46:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="自定义日志格式">自定义日志格式</h2>
<pre><code>log_format  main '$http_x_forwarded_for - [$time_iso8601] &quot;$request&quot; '
	                                    '$status $body_bytes_sent '
	                                    '&quot;$http_referer&quot; &quot;$http_user_agent&quot; ';
        access_log logs/access.log main;
</code></pre>
<p>https://blog.csdn.net/xqhys/article/details/81782633</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一些有趣的网址]]></title>
        <id>https://blog.myxy.net/docsify-yi-ge-shen-qi-de-wen-dang-wang-zhan-sheng-cheng-gong-ju/</id>
        <link href="https://blog.myxy.net/docsify-yi-ge-shen-qi-de-wen-dang-wang-zhan-sheng-cheng-gong-ju/">
        </link>
        <updated>2020-06-05T09:41:32.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://docsify.js.org/#/zh-cn/">docsify一个神奇的文档网站生成工具</a></p>
<p><a href="https://mornin.fm/">Mornin 是一个匿名语音群聊服务</a></p>
<p><a href="https://swagger.io/">swagger</a></p>
<blockquote>
<p>swagger是一个REST APIs文档生成工具，可以在许多不同的平台上从代码注释中自动生成，开源，支持大部分语言，社区好，总之就是一个强大.</p>
</blockquote>
<p><a href="https://lab.lyric.im/wxformat/">微信公众号文章排版</a></p>
<blockquote>
<p>源码:https://github.com/lyricat/wechat-format</p>
</blockquote>
<p><a href="http://www.51yuansu.com/">觅元素</a></p>
<blockquote>
<p>一天免费下载十张 psd</p>
</blockquote>
<p><a href="https://ps.gaoding.com/">在线PS</a></p>
<p><a href="https://send.firefox.com/">火狐-临时文件上传</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[printf()中的%]]></title>
        <id>https://blog.myxy.net/printfzhong-de/</id>
        <link href="https://blog.myxy.net/printfzhong-de/">
        </link>
        <updated>2020-05-27T03:10:57.000Z</updated>
        <content type="html"><![CDATA[<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">对应数据类型</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">示例</th>
<th style="text-align:center">输出</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">o</td>
<td style="text-align:center">unsigned int</td>
<td style="text-align:center">无符号8进制(octal)整数(不输出前缀0)</td>
<td style="text-align:center">printf(&quot;0%o&quot;,123);</td>
<td style="text-align:center">0173</td>
</tr>
<tr>
<td style="text-align:center">u</td>
<td style="text-align:center">unsigned int</td>
<td style="text-align:center">无符号10进制整数</td>
<td style="text-align:center">printf(&quot;%u&quot;,123);</td>
<td style="text-align:center">123</td>
</tr>
<tr>
<td style="text-align:center">x/X</td>
<td style="text-align:center">unsigned int</td>
<td style="text-align:center">无符号16进制整数，x对应的是abcdef，X对应的是ABCDEF（不输出前缀0x)</td>
<td style="text-align:center">printf(&quot;0x%x 0x%X&quot;,123,123);</td>
<td style="text-align:center">0x7b 0x7B</td>
</tr>
<tr>
<td style="text-align:center">f/lf</td>
<td style="text-align:center">float(double)</td>
<td style="text-align:center">单精度浮点数用f,双精度浮点数用lf(printf可混用，但scanf不能混用)</td>
<td style="text-align:center">printf(&quot;%.9f %.9lf&quot;,0.000000123,0.000000123);</td>
<td style="text-align:center">0.000000123 0.000000123。注意指定精度，否则printf默认精确到小数点后六位</td>
</tr>
<tr>
<td style="text-align:center">F</td>
<td style="text-align:center">float(double)</td>
<td style="text-align:center">与f格式相同，只不过 infinity 和 nan 输出为大写形式。</td>
<td style="text-align:center">printf(&quot;%f %F %f %F\n&quot;,INFINITY,INFINITY,NAN,NAN);</td>
<td style="text-align:center">inf INF nan NAN</td>
</tr>
<tr>
<td style="text-align:center">e/E</td>
<td style="text-align:center">float(double)</td>
<td style="text-align:center">科学计数法，使用指数(Exponent)表示浮点数，此处”e”的大小写代表在输出时“e”的大小写</td>
<td style="text-align:center">printf(&quot;%e %E&quot;,0.000000123,0.000000123);</td>
<td style="text-align:center">1.230000e-07 1.230000E-07</td>
</tr>
<tr>
<td style="text-align:center">g</td>
<td style="text-align:center">float(double)</td>
<td style="text-align:center">根据数值的长度，选择以最短的方式输出，%f或%e</td>
<td style="text-align:center">printf(&quot;%g %g&quot;,0.000000123,0.123);</td>
<td style="text-align:center">1.23e-07 0.123</td>
</tr>
<tr>
<td style="text-align:center">G</td>
<td style="text-align:center">float(double)</td>
<td style="text-align:center">根据数值的长度，选择以最短的方式输出，%f或%E</td>
<td style="text-align:center">printf(&quot;%G %G&quot;,0.000000123,0.123);</td>
<td style="text-align:center">1.23E-07 0.123</td>
</tr>
<tr>
<td style="text-align:center">c</td>
<td style="text-align:center">char</td>
<td style="text-align:center">字符型。可以把输入的数字按照ASCII码相应转换为对应的字符</td>
<td style="text-align:center">printf(&quot;%c\n&quot;,64)</td>
<td style="text-align:center">A</td>
</tr>
<tr>
<td style="text-align:center">s</td>
<td style="text-align:center">char*</td>
<td style="text-align:center">字符串。输出字符串中的字符直至字符串中的空字符（字符串以空字符’\0‘结尾）</td>
<td style="text-align:center">printf(&quot;%s&quot;,&quot;测试test&quot;);</td>
<td style="text-align:center">测试test</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">wchar_t*</td>
<td style="text-align:center">宽字符串。输出字符串中的字符直至字符串中的空字符（宽字符串以两个空字符’\0‘结尾）</td>
<td style="text-align:center">setlocale(LC_ALL,&quot;zh_CN.UTF-8&quot;);wchar_t wtest[]=L&quot;测试Test&quot;;printf(&quot;%S\n&quot;,wtest);</td>
<td style="text-align:center">测试test</td>
</tr>
<tr>
<td style="text-align:center">p</td>
<td style="text-align:center">void*</td>
<td style="text-align:center">以16进制形式输出指针</td>
<td style="text-align:center">printf(&quot;%010p&quot;,&quot;lvlv&quot;);</td>
<td style="text-align:center">0x004007e6</td>
</tr>
<tr>
<td style="text-align:center">n</td>
<td style="text-align:center">int*</td>
<td style="text-align:center">什么也不输出。%n对应的参数是一个指向signed int的指针，在此之前输出的字符数将存储到指针所指的位置	int num=0;</td>
<td style="text-align:center">printf(&quot;lvlv%n&quot;,&amp;num);printf(&quot;num:%d&quot;,num);</td>
<td style="text-align:center">lvlvnum:4</td>
</tr>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:center">字符%</td>
<td style="text-align:center">输出字符‘%’（百分号）本身</td>
<td style="text-align:center">printf(&quot;%%&quot;);</td>
<td style="text-align:center">%</td>
</tr>
<tr>
<td style="text-align:center">m</td>
<td style="text-align:center">无</td>
<td style="text-align:center">打印errno值对应的出错内容</td>
<td style="text-align:center">printf(&quot;%m\n&quot;);</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">a/A</td>
<td style="text-align:center">float(double)</td>
<td style="text-align:center">十六进制p计数法输出浮点数，a为小写，A为大写</td>
<td style="text-align:center">printf(&quot;%a %A&quot;,15.15,15.15);</td>
<td style="text-align:center">0x1.e4ccccccccccdp+3 0X1.E4CCCCCCCCCCDP+3</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">对应数据类型</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">示例</th>
<th style="text-align:center">输出</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">lu</td>
<td style="text-align:center">unsigned long</td>
<td style="text-align:center">无符号长整数</td>
<td style="text-align:center">printf(&quot;%lu&quot;,123);</td>
<td style="text-align:center">123</td>
</tr>
</tbody>
</table>
<p>https://blog.csdn.net/JX_Cesare/article/details/81153410</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在Win32程序中调用控制台调试输出]]></title>
        <id>https://blog.myxy.net/zai-win32-cheng-xu-zhong-diao-yong-kong-zhi-tai-diao-shi-shu-chu/</id>
        <link href="https://blog.myxy.net/zai-win32-cheng-xu-zhong-diao-yong-kong-zhi-tai-diao-shi-shu-chu/">
        </link>
        <updated>2020-05-23T01:05:16.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><strong>AllocConsole</strong> 函数的功能是为当前的窗口程序申请一个Console窗口，其原型为 <code>BOOL AllocConsole(void);</code><br>
<strong>freopen</strong> 函数用来替换一个流，或者说重新分配文件指针，以实现重定向。可重定向的流有：标准输入流、标准输出流或者标准错误流。其函数原型为<code>FILE *freopen(const char *path, const char *mode, FILE *stream);</code><br>
<code>CONOUT$</code> 是指代当前console的特殊字符串，<code>w</code>表明以written模式打开这个console，stdout指代标准输出流。</p>
</blockquote>
<p>完整代码如下：</p>
<pre><code class="language-cpp">    AllocConsole();
    freopen(&quot;CONOUT$&quot;, &quot;w&quot;, stdout);
    std::cout &lt;&lt; &quot;This is a test info&quot; &lt;&lt; std::endl;
</code></pre>
<p>最后要记得关闭控制台:</p>
<pre><code class="language-cpp">FreeConsole();
</code></pre>
<p>补充：</p>
<p>AllocConsole函数不能改变控制台窗口在屏幕上的位置、尺寸等属性。以下函数可以控制&amp;获取控制台相关信息</p>
<pre><code class="language-cpp">    GetConsoleScreenBufferInfo 　　// 检索窗口大小，屏幕缓冲区大小及颜色属性
    SetConsoleWindowInfo 　　　　　 // 改变控制台窗口大小
    SetConsoleScreenBufferSize　　 // 改变控制台屏幕缓冲区大小
    SetConsoleTextAttribute　　    // 设置颜色属性
    SetConsoleTitle　　　　　　　　  // 设置控制台窗口标题
    GetConsoleTitle　　　　　　　　  // 获取控制台窗口标题
</code></pre>
<p>打印日志:</p>
<pre><code class="language-cpp">#define LOG(format, ...) fprintf(stdout, &quot;&gt;&gt; &quot;format&quot;\n&quot;, ##__VA_ARGS__)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[inja模板渲染]]></title>
        <id>https://blog.myxy.net/inja-mo-ban-xuan-ran/</id>
        <link href="https://blog.myxy.net/inja-mo-ban-xuan-ran/">
        </link>
        <updated>2020-05-16T01:55:17.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://github.com/xmh0511/inja">inja</a><br>
<a href="https://github.com/xmh0511/xfinal">xfinal</a></p>
<h2 id="赋值方式">赋值方式</h2>
<pre><code class="language-cpp">//方式一:
res.set_attr(&quot;variable&quot;,&quot;hello,world&quot;);
//方式二:
json  jsondata;
jsondata[&quot;code&quot;]=0;
jsondata[&quot;msg&quot;]=&quot;ok&quot;;
res.write_view(&quot;./tpl/login.html&quot;, jsondata,false);
</code></pre>
<h2 id="循环输出">循环输出</h2>
<blockquote>
<p>对json数组的遍历</p>
</blockquote>
<pre><code class="language-html">{% for item in list %}
    &lt;p&gt;@{item.name}&lt;/p&gt;
{% endfor %}

// 数组元素的访问
&lt;div&gt;@{list.0.name}&lt;/div&gt;

// 获取list长度
&lt;div&gt;@{length(list)}&lt;/div&gt;

// 获取list中的第一个或最后一个元素
&lt;div&gt;@{first (list)}&lt;/div&gt;
&lt;div&gt;@{last (list)}&lt;/div&gt;

//列表排序
&lt;div&gt;@{sort([3,2,1])}&lt;/div&gt;
&lt;div&gt;@{sort(list)}&lt;/div&gt;

// 获取list中的最大最小值
&lt;div&gt;max([1,3,2])&lt;/div&gt;
&lt;div&gt;min([3,1,2])&lt;/div&gt;
&lt;div&gt;min(list)&lt;/div&gt;

// 还可以通过关键字loop访问当前循环的属性和值
{% for item in list %}
    &lt;p&gt;
        &lt;span&gt;@{loop.index }&lt;/span&gt;
        &lt;span&gt;@{loop.index1 }&lt;/span&gt;
        &lt;span&gt;@{loop.is_first   }&lt;/span&gt;
        &lt;span&gt;@{loop.is_last  }&lt;/span&gt;
        &lt;span&gt;@{item.name}&lt;/span&gt;
    &lt;/p&gt;
{% endfor %}

// 多重循环中，嵌套的循环中可以通过loop.parent访问父层循环的loop，以此类推loop.parent.parent
{% for item in list %}
    {% for item0 in item %}
        &lt;p&gt;@{item0.abc}&lt;/p&gt;
    {% endfor %}
{% endfor %}
</code></pre>
<blockquote>
<p>对json对象的遍历</p>
</blockquote>
<pre><code class="language-html">{% for key, value in object %}
    &lt;p&gt;
        &lt;span&gt;@{key}&lt;/span&gt;
        &lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;@{value}&lt;/span&gt;
    &lt;/p&gt;
{% endfor %}
</code></pre>
<blockquote>
<p>获取一个循环区间</p>
</blockquote>
<pre><code class="language-html">{% for i in range(4) %}
    &lt;div&gt;@{ loop.index1 }&lt;/div&gt;
{% endfor %}
</code></pre>
<h2 id="变量输出">变量输出:</h2>
<pre><code class="language-html">@{downpath}
</code></pre>
<h2 id="条件判断">条件判断:</h2>
<p><code>==</code> , <code>&gt;</code> , <code>&gt;=</code> , <code>&lt;</code> , <code>&lt;=</code> , <code>!=</code> , <code>逻辑与 and</code> , <code>逻辑或 or</code> , <code>逻辑非 not</code></p>
<pre><code>{% if variable == true %}
    &lt;div&gt;如果variable是true则显示&lt;/div&gt;
{% endif %}

{% if variable in list %}
    &lt;div&gt;variable:&quot;a&quot;,list:[&quot;a&quot;,&quot;b&quot;]&lt;/div&gt;
{% endif %}

{% if variable == null %}
    {% endif %}
    {% if ... %}
        {% else if ... %}
    {% else %}
{% endif %}

// 判断对象中是否存在某键名
{% if exists(\&quot;variable\&quot;) %}
    存在
{% endif %}

{% if existsIn(variable,\&quot;time\&quot;) %}
    &lt;div&gt;variable对象中是否存在key为time的键值对&lt;/div&gt;
{% endif %}

// 判断值的类型
&lt;div&gt;@{isString(variable)}&lt;/div&gt;
&lt;div&gt;@{isArray(variable)}&lt;/div&gt;
</code></pre>
<h2 id="包含外部模板文件">包含外部模板文件</h2>
<pre><code class="language-cpp">{% include \&quot;footer.html\&quot; %}
</code></pre>
<h2 id="原样输出">原样输出</h2>
<pre><code class="language-html">&lt;div&gt;
    #(
        {% for item in list %}
        {% endfor %}
    )#
&lt;div&gt;
</code></pre>
<h2 id="转换成大小写输出">转换成大小写输出</h2>
<pre><code class="language-html">&lt;div&gt;@{upper(variable)}&lt;/div&gt;
&lt;div&gt;@{lower(variable)}&lt;/div&gt;
</code></pre>
<h2 id="判断数值奇偶性">判断数值奇偶性</h2>
<pre><code class="language-html">&lt;div&gt;@{odd(42)}&lt;/div&gt;
&lt;div&gt;@{even(42)}&lt;/div&gt;
</code></pre>
<h2 id="保留小数点n位">保留小数点N位</h2>
<pre><code class="language-html">@{ round(3.1415, 2)  }
&lt;div&gt;round(3.1415, 0)&lt;/div&gt;
&lt;div&gt;round(3.1415, 2)&lt;/div&gt;
</code></pre>
<h2 id="是否能整除">是否能整除</h2>
<pre><code class="language-html">&lt;div&gt;@{divisibleBy(42,7)}&lt;/div&gt;
</code></pre>
<h2 id="字符串转数值">字符串转数值</h2>
<pre><code class="language-html">&lt;div&gt;@{int(\&quot;2\&quot;) == 2 } &lt;/div&gt;
&lt;div&gt;@{float(\&quot;1.8\&quot;) &gt; 2}&lt;/div&gt;
</code></pre>
<h2 id="代码注释">代码注释:</h2>
<pre><code class="language-html">&lt;div&gt;1&lt;/div&gt;
{# 
  Todo...
#}
</code></pre>
<h2 id="给不存在的对象设置默认值">给不存在的对象设置默认值</h2>
<pre><code class="language-html">&lt;div&gt;@{default(notexists, \&quot;默认值\&quot;)}&lt;/div&gt;
</code></pre>
<h2 id="自定义模板函数">自定义模板函数</h2>
<blockquote>
<p>通过http_server类的add_view_method方法可以给模板渲染引擎增加处理方法<br>
add_view_method 参数解释</p>
</blockquote>
<pre><code class="language-cpp">参数一: 定义的方法名:string
参数二: 方法参数个数
参数三: 为该方法注册的cpp方法,其参数为 inja::Arguments const&amp; args，返回值为可以隐式转换成json对象的类型

server.add_view_method(&quot;str2int&quot;, 1, [](inja::Arguments const&amp; args) {
        auto i = std::atoi(args[0]-&gt;get&lt;std::string&gt;().data());
        return std::string(&quot;transform:&quot;) + std::to_string(i);
});

 &lt;div&gt;@{str2int(\&quot;123\&quot;)}&lt;/div&gt;
</code></pre>
<h2 id="自定义句法">自定义句法</h2>
<blockquote>
<p>通过response类中的view_environment方法获取模板渲染引擎的句柄 ,注意此设置只针对当前请求的返回，不是全局的</p>
</blockquote>
<ul>
<li>set_expression 设置输出变量值的句法</li>
<li>set_comment 设置注释句法</li>
<li>set_statement 设置块状表达式句法</li>
<li>set_line_statement 设置行表达式句法<br>
<code>res. view_environment().set_expression(&quot;@{&quot;,&quot;}&quot;)</code></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nlohmann/json 使用记录]]></title>
        <id>https://blog.myxy.net/nlohmannjson-shi-yong-ji-lu/</id>
        <link href="https://blog.myxy.net/nlohmannjson-shi-yong-ji-lu/">
        </link>
        <updated>2020-05-12T04:02:56.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://github.com/nlohmann/json">nlohmann</a>库是C++解析json的库，库使用很简单，程序中使用nlohmann仅需要将json.hpp添加到工程中即可。<a href="https://nlohmann.github.io/json/">在线帮助文档</a><br>
定义一个JSON对象: <code>nlohmann::json j_object;</code><br>
打印json对象内容：<code>j_object.dump(缩进量)</code><br>
删除: <code>j_object.erase(&quot;one&quot;);</code></p>
<p>获取值:<code>auto&amp; username = req_json[&quot;username&quot;].get&lt;std::string&gt;();</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows 最常用的多线程同步对象 Event]]></title>
        <id>https://blog.myxy.net/windows-zui-chang-yong-de-duo-xian-cheng-tong-bu-dui-xiang-event/</id>
        <link href="https://blog.myxy.net/windows-zui-chang-yong-de-duo-xian-cheng-tong-bu-dui-xiang-event/">
        </link>
        <updated>2020-05-12T02:37:13.000Z</updated>
        <content type="html"><![CDATA[<p>创建 Event 的 Windows API 函数签名是：</p>
<pre><code class="language-cpp">HANDLE CreateEvent(
  LPSECURITY_ATTRIBUTES lpEventAttributes,
  BOOL                  bManualReset,
  BOOL                  bInitialState,
  LPCTSTR               lpName
);
</code></pre>
<p><strong>参数和返回值的说明如下:</strong></p>
<ul>
<li>参数 <strong>lpEventAttributes</strong>，这个参数设置了 Event 对象的安全属性，Windows 中所有的内核对象都可以设置这个属性，我们一般设置为 NULL，即使用默认安全属性。</li>
<li>参数 <strong>bManualReset</strong>，这个参数设置 Event 对象受信（变成有信号状态）时的行为，当设置为 TRUE 时，表示需要手动调用 ResetEvent 函数去将 Event 重置成无信号状态；当设置为 FALSE，Event 事件对象受信后会自动重置为无信号状态。</li>
<li>参数 <strong>bInitialState</strong> 设置 Event 事件对象初始状态是否是受信的，TRUE 表示有信号，FALSE 表示无信号。</li>
<li>参数 <strong>lpName</strong> 可以设置 Event 对象的名称，如果不需要设置名称，可以将该参数设置为 NULL。一个 Event 对象根据是否设置了名称分为具名对象（具有名称的对象）和匿名对象。Event 对象是可以通过名称在不同进程之间共享的，通过这种方式共享很有用，后面我们会相信介绍。</li>
<li>返回值，如果成功创建 Event 对象返回对象的句柄，如果创建失败返回 NULL。</li>
</ul>
<p>一个无信号的 Event 对象，我们可以通过 <code>SetEvent</code> 将其变成受信状态，SetEvent 的函数签名如下：<code>BOOL SetEvent(HANDLE hEvent);</code> 参数 hEvent 设置为需要设置信号的 Event 句柄即可。</p>
<p>同理，一个已经受信的 Event 对象，可以使用 <code>ResetEvent</code> 对象将其变成无信号状态，ResetEvent 的函数签名如下：<code>BOOL ResetEvent(HANDLE hEvent);</code> 参数 hEvent 即我们需要重置的 Event 对象句柄。</p>
<p>例子,假设现在有两个线程，其中一个是主线程，主线程等待工作线程执行某一项耗时的任务完成后，将任务结果显示出来。代码如下：</p>
<pre><code class="language-cpp"> #include &lt;Windows.h&gt;
 #include &lt;string&gt;
 #include &lt;iostream&gt;

 bool        g_bTaskCompleted = false;
 std::string g_TaskResult;
 HANDLE      g_hTaskEvent = NULL;

 DWORD __stdcall WorkerThreadProc(LPVOID lpThreadParameter)
{
   //使用 Sleep 函数模拟一个很耗时的操作
   //睡眠3秒
   Sleep(3000);
   g_TaskResult = &quot;task completed&quot;;
   g_bTaskCompleted = true;
   //设置事件信号
   SetEvent(g_hTaskEvent);
   return 0;
 }

int main()
{
   //创建一个匿名的手动重置初始无信号的事件对象
   g_hTaskEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
   HANDLE hWorkerThread = CreateThread(NULL, 0, WorkerThreadProc, NULL, 0, NULL); 
   
   DWORD dwResult = WaitForSingleObject(g_hTaskEvent, INFINITE);
   if (dwResult == WAIT_OBJECT_0)
   {
       std::cout &lt;&lt; g_TaskResult &lt;&lt; std::endl;
   }
   
   CloseHandle(hWorkerThread);
   CloseHandle(g_hTaskEvent);
   return 0;
 }
</code></pre>
<p><strong>Event 对象有两个显著的特点：</strong></p>
<ul>
<li>与临界区对象（以及接下来要介绍的 Mutex 对象）相比，Event 对象没有被谁持让持有者线程变成其 owner 这一说法，因此 Event 对象可以同时唤醒多个等待的工作线程。</li>
<li>手动重置的 Event 对象一旦变成受信状态，其信号不会丢失，也就是说当 Event 从无信号变成有信号时，即使某个线程当时没有调用 <code>WaitForSingleObject</code>等待该 Event 对象受信，而是在这之后才调用 <code>WaitForSingleObject</code> ，仍然能检测到事件的受信状态，即不会丢失信号，而后面要介绍的条件变量就可能会丢失信号。</li>
</ul>
]]></content>
    </entry>
</feed>