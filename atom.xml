<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.myxy.net</id>
    <title>Maxbad`Blog</title>
    <updated>2020-09-22T02:47:00.070Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.myxy.net"/>
    <link rel="self" href="https://blog.myxy.net/atom.xml"/>
    <subtitle>记录一些东西</subtitle>
    <logo>https://blog.myxy.net/images/avatar.png</logo>
    <icon>https://blog.myxy.net/favicon.ico</icon>
    <rights>All rights reserved 2020, Maxbad`Blog</rights>
    <entry>
        <title type="html"><![CDATA[Redis2]]></title>
        <id>https://blog.myxy.net/redis2/</id>
        <link href="https://blog.myxy.net/redis2/">
        </link>
        <updated>2020-09-22T01:42:16.000Z</updated>
        <content type="html"><![CDATA[<h1 id="结构类型">结构类型</h1>
<table>
<thead>
<tr>
<th>结构类型</th>
<th style="text-align:left">结构存储的值</th>
<th style="text-align:left">结构的读写能力</th>
</tr>
</thead>
<tbody>
<tr>
<td>STRING</td>
<td style="text-align:left">可以是字符串,整数或者浮点数</td>
<td style="text-align:left">对整个字符串或者字符串的其中一部分执行操作;对整数和浮点数执行自增(increment)或者自减(decrement)操作</td>
</tr>
<tr>
<td>LIST</td>
<td style="text-align:left">一个链表,链表上的每个节点都包含了一个字符串</td>
<td style="text-align:left">从链表的两端推入或者弹出元素;根据偏移量对链表进行修剪(trim);读取单个或者多个元素;根据值查找或者移除元素</td>
</tr>
<tr>
<td>SET</td>
<td style="text-align:left">包含字符串的无序收集器(unordered collection),并且被包含的每个字符串都是独一无二,各不相同的</td>
<td style="text-align:left">添加,获取,移除单个元素;检查一个元素是否存在于集合中,计算交集,并集,差集;从集合里面随机获取元素</td>
</tr>
<tr>
<td>HASH</td>
<td style="text-align:left">包含键值对的无序散列表</td>
<td style="text-align:left">添加,获取,移除单个键值对;获取所有键值对</td>
</tr>
<tr>
<td>ZSET(有序集合)</td>
<td style="text-align:left">字符串成员(member)与浮点数分值(score)之间的有序映射,元素的排列顺序由分值的大小决定</td>
<td style="text-align:left">添加,获取,删除单个元素;根据分值范围(fange)或者成员来获取元素</td>
</tr>
</tbody>
</table>
<h2 id="string-字符串">STRING (字符串)</h2>
<figure data-type="image" tabindex="1"><img src="https://blog.myxy.net/post-images/1600741899944.jpg" alt="" loading="lazy"></figure>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">行为</th>
<th style="text-align:left">其他</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td style="text-align:left">获取存储在给定键中的值</td>
<td style="text-align:left">不存在返回nil</td>
</tr>
<tr>
<td>SET</td>
<td style="text-align:left">设置存储在给定键中的值</td>
<td style="text-align:left">执行成功返回OK</td>
</tr>
<tr>
<td>DEL</td>
<td style="text-align:left">删除存储在给定键中的值</td>
<td style="text-align:left">这个命令可以用于所有类型,成功删除的值的数量</td>
</tr>
</tbody>
</table>
<h2 id="list-有序列表">LIST (有序列表)</h2>
<blockquote>
<p>列表结构可以<code>有序</code>地存储多个字符串,可重复<br>
<img src="https://blog.myxy.net/post-images/1600741872621.jpg" alt="" loading="lazy"></p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">行为</th>
<th style="text-align:left">其他</th>
</tr>
</thead>
<tbody>
<tr>
<td>RPUSH</td>
<td style="text-align:left">将给定值推入列表的右端</td>
<td style="text-align:left">返回列表当前的长度</td>
</tr>
<tr>
<td>LRANGE</td>
<td style="text-align:left">获取列表在给定范围上的所有值</td>
<td style="text-align:left">从0到-1范围可以去除全部列表</td>
</tr>
<tr>
<td>LINDEX</td>
<td style="text-align:left">获取列表在给定位置上的单个元素</td>
<td style="text-align:left">取单个</td>
</tr>
<tr>
<td>LPOP</td>
<td style="text-align:left">从列表的左端弹出一个值,并返回被弹出的值</td>
<td style="text-align:left">被弹出的元素将不再存在于列表</td>
</tr>
</tbody>
</table>
<h2 id="set-无序集合">SET (无序集合)</h2>
<blockquote>
<p>通过散列表来保证自己存储的每个字符串都是各不相同的(这些散列表只有键,但没有与键相关联的值),<code>无序</code>方式存储元素<br>
<img src="https://blog.myxy.net/post-images/1600741849673.jpg" alt="" loading="lazy"></p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">行为</th>
<th style="text-align:left">其他</th>
</tr>
</thead>
<tbody>
<tr>
<td>SADD</td>
<td style="text-align:left">将给定元素添加到集合</td>
<td style="text-align:left">返回1表示成功,返回0表示已存在</td>
</tr>
<tr>
<td>SMEMBERS</td>
<td style="text-align:left">返回集合包含的所有元素</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>SISMEMBER</td>
<td style="text-align:left">检查给定元素是否存在于集合中</td>
<td style="text-align:left">返回1表示存在,返回0表示不存在</td>
</tr>
<tr>
<td>SREM</td>
<td style="text-align:left">如果给定的元素存在于集合中,那么移除这个元素</td>
<td style="text-align:left">返回被移除元素的数量</td>
</tr>
<tr>
<td>SINTER</td>
<td style="text-align:left">交集</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>SUNION</td>
<td style="text-align:left">并集</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>SDIFF</td>
<td style="text-align:left">差集</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h2 id="hash-散列">HASH (散列)</h2>
<blockquote>
<p>可以存储多个键值对之间的映射,值可以是字符串也可以是数值,并且数值可以自增或自减操作.<br>
<img src="https://blog.myxy.net/post-images/1600741809702.jpg" alt="" loading="lazy"></p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">行为</th>
<th style="text-align:left">其他</th>
</tr>
</thead>
<tbody>
<tr>
<td>HSET</td>
<td style="text-align:left">在散列里面关联起给定的键值对</td>
<td style="text-align:left">1表示成功,0表示已存在</td>
</tr>
<tr>
<td>HGET</td>
<td style="text-align:left">获取指定散列键的值</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>HGETALL</td>
<td style="text-align:left">获取散列包含的所有键值对</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>HDEL</td>
<td style="text-align:left">如果给定的键存在于散列里面,那么移除这个键</td>
<td style="text-align:left">1表示成功,0表示不存在</td>
</tr>
</tbody>
</table>
<h2 id="zset-有序集合">ZSET (有序集合)</h2>
<blockquote>
<p>有序集合的键被称为成员(member),每个成员都是各不相同的,有序集合的值被称为分值(score),分值必须为浮点数,有序集合是Redis里面唯一一个既可以根据成员访问元素(散列一样),有可以根据分值以及分值的排序来访问元素的结构<br>
<img src="https://blog.myxy.net/post-images/1600742459363.jpg" alt="" loading="lazy"></p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">行为</th>
<th style="text-align:left">其他</th>
</tr>
</thead>
<tbody>
<tr>
<td>ZADD</td>
<td style="text-align:left">将一个带有给定分值的成员添加到有序集合里面</td>
<td style="text-align:left">返回添加元素的数量</td>
</tr>
<tr>
<td>ZRANGE</td>
<td style="text-align:left">根据元素在有序排列中所处的位置,从有序集合里面获取多个元素</td>
<td style="text-align:left">从0开始-1结束可返回全部</td>
</tr>
<tr>
<td>ZRANGEBYSCORE</td>
<td style="text-align:left">获取有序集合在给定分值范围内的所有元素</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>ZREM</td>
<td style="text-align:left">如果给定成员存在于有序集合,那么移除这个成员</td>
<td style="text-align:left">返回被移除元素的数量</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[布隆过滤器]]></title>
        <id>https://blog.myxy.net/bu-long-guo-lu-qi/</id>
        <link href="https://blog.myxy.net/bu-long-guo-lu-qi/">
        </link>
        <updated>2020-09-19T13:21:18.000Z</updated>
        <content type="html"><![CDATA[<p>https://blog.csdn.net/y1054765649/article/details/88712339</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[VS  自定义 clang-format 格式化代码格式]]></title>
        <id>https://blog.myxy.net/vs-zi-ding-yi-clang-format-ge-shi-hua-dai-ma-ge-shi/</id>
        <link href="https://blog.myxy.net/vs-zi-ding-yi-clang-format-ge-shi-hua-dai-ma-ge-shi/">
        </link>
        <updated>2020-09-19T06:52:53.000Z</updated>
        <content type="html"><![CDATA[<p>将<code>.clang-format</code> 文件放到工程根目录</p>
<pre><code class="language-python">ColumnLimit:     0   # 这样就不会限制行宽，自动折行了
IndentWidth:     4
</code></pre>
<p>官方文档:http://clang.llvm.org/docs/ClangFormatStyleOptions.html<br>
中文文档: https://www.cnblogs.com/PaulpauL/p/5929753.html</p>
<h2 id="示例文件">示例文件:</h2>
<pre><code class="language-python">---
Language:        Cpp

AccessModifierOffset:                                       -2
AlignAfterOpenBracket:                                      DontAlign
AlignConsecutiveAssignments:                                true
AlignConsecutiveDeclarations:                               false
AlignEscapedNewlinesLeft:                                   false
AlignOperands:                                              true
AlignTrailingComments:                                      true
AllowAllParametersOfDeclarationOnNextLine:                  false
AllowShortBlocksOnASingleLine:                              true
AllowShortCaseLabelsOnASingleLine:                          true
AllowShortFunctionsOnASingleLine:                           All
AllowShortIfStatementsOnASingleLine:                        true
AllowShortLoopsOnASingleLine:                               true
AlwaysBreakAfterDefinitionReturnType:                       All
AlwaysBreakAfterReturnType:                                 AllDefinitions
AlwaysBreakBeforeMultilineStrings:                          false
AlwaysBreakTemplateDeclarations:                            true
BinPackArguments:                                           true
BinPackParameters:                                          true
# Ignored if BreakBeforeBraces different from Custom
BraceWrapping:
  AfterClass:                                               false
  AfterControlStatement:                                    false
  AfterEnum:                                                false
  AfterFunction:                                            false
  AfterNamespace:                                           false
  AfterObjCDeclaration:                                     false
  AfterStruct:                                              false
  AfterUnion:                                               false
  BeforeCatch:                                              true
  BeforeElse:                                               true
  IndentBraces:                                             false
BreakBeforeBinaryOperators:                                 NonAssignment
BreakBeforeBraces:                                          Custom
BreakBeforeTernaryOperators:                                true
BreakConstructorInitializersBeforeComma:                    true
# Ignored in C++
BreakAfterJavaFieldAnnotations:                             false
BreakStringLiterals:                                        false
ColumnLimit:                                                0
CommentPragmas:                                             '.*'
ConstructorInitializerAllOnOneLineOrOnePerLine:             true
ConstructorInitializerIndentWidth:                          0
ContinuationIndentWidth:                                    2
Cpp11BracedListStyle:                                       true
DerivePointerAlignment:                                     false
DisableFormat:                                              false
ExperimentalAutoDetectBinPacking:                           false
ForEachMacros:                                              [ foreach, Q_FOREACH, BOOST_FOREACH ]
IncludeCategories:
  - Regex:                                                  'cpp_redis'
    Priority:                                               1
IncludeIsMainRegex:                                         '$'
IndentCaseLabels:                                           false
IndentWidth:                                                2
IndentWrappedFunctionNames:                                 false
# Ignored in C++
JavaScriptQuotes:                                           Leave
# Ignored in C++
JavaScriptWrapImports:                                      true
KeepEmptyLinesAtTheStartOfBlocks:                           true
MacroBlockBegin:                                            ''
MacroBlockEnd:                                              ''
MaxEmptyLinesToKeep:                                        2
NamespaceIndentation:                                       None
# Ignored in C++
ObjCBlockIndentWidth:                                       2
# Ignored in C++
ObjCSpaceAfterProperty:                                     false
# Ignored in C++
ObjCSpaceBeforeProtocolList:                                true
PenaltyBreakBeforeFirstCallParameter:                       19
PenaltyBreakComment:                                        300
PenaltyBreakFirstLessLess:                                  120
PenaltyBreakString:                                         1000
PenaltyExcessCharacter:                                     1000000
PenaltyReturnTypeOnItsOwnLine:                              60
PointerAlignment:                                           Left
ReflowComments:                                             true
SortIncludes:                                               true
SpaceAfterCStyleCast:                                       true
SpaceBeforeAssignmentOperators:                             true
SpaceBeforeParens:                                          ControlStatements
SpaceInEmptyParentheses:                                    false
SpacesBeforeTrailingComments:                               1
SpacesInAngles:                                             false
SpacesInContainerLiterals:                                  true
SpacesInCStyleCastParentheses:                              false
SpacesInParentheses:                                        false
SpacesInSquareBrackets:                                     false
Standard:                                                   Cpp11
TabWidth:                                                   8
UseTab:                                                     Never
...
</code></pre>
<h2 id="说明">说明</h2>
<pre><code class="language-python">
---
# 语言: None, Cpp, Java, JavaScript, ObjC, Proto, TableGen, TextProto #
Language:	Cpp
# 基础格式 #
BasedOnStyle: Google
# 访问说明符(public、private等)的偏移 #
AccessModifierOffset: -4

# 开括号(开圆括号、开尖括号、开方括号)后的对齐: Align, DontAlign, AlwaysBreak(总是在开括号后换行)
AlignAfterOpenBracket:	Align
# 连续赋值时，对齐所有等号
AlignConsecutiveAssignments:	true
# 连续声明时，对齐所有声明的变量名
AlignConsecutiveDeclarations:	true
# 左对齐逃脱换行(使用反斜杠换行)的反斜杠
AlignEscapedNewlinesLeft:	true
# 水平对齐二元和三元表达式的操作数
AlignOperands:	true
# 对齐连续的尾随的注释
AlignTrailingComments:	true
# 允许函数声明的所有参数在放在下一行
AllowAllParametersOfDeclarationOnNextLine:	true
# 允许短的块放在同一行
AllowShortBlocksOnASingleLine:	false
# 允许短的case标签放在同一行
AllowShortCaseLabelsOnASingleLine:	false
# 允许短的函数放在同一行: None, InlineOnly(定义在类中), Empty(空函数), Inline(定义在类中，空函数), All
AllowShortFunctionsOnASingleLine:	Empty
# 允许短的if语句保持在同一行
AllowShortIfStatementsOnASingleLine:	false
# 允许短的循环保持在同一行
AllowShortLoopsOnASingleLine:	false
# 总是在定义返回类型后换行(deprecated)
AlwaysBreakAfterDefinitionReturnType:	None
# 总是在返回类型后换行: None, All, TopLevel(顶级函数，不包括在类中的函数), 
#   AllDefinitions(所有的定义，不包括声明), TopLevelDefinitions(所有的顶级函数的定义)
AlwaysBreakAfterReturnType:	None
# 总是在多行string字面量前换行
AlwaysBreakBeforeMultilineStrings:	false
# 总是在template声明后换行
AlwaysBreakTemplateDeclarations:	false
# false表示函数实参要么都在同一行，要么都各自一行
BinPackArguments:	true
# false表示所有形参要么都在同一行，要么都各自一行
BinPackParameters:	true
# 大括号换行，只有当BreakBeforeBraces设置为Custom时才有效
BraceWrapping:   
  # class定义后面
  AfterClass:	false
  # 控制语句后面
  AfterControlStatement:	false
  # enum定义后面
  AfterEnum:	false
  # 函数定义后面
  AfterFunction:	false
  # 命名空间定义后面
  AfterNamespace:	false
  # ObjC定义后面
  AfterObjCDeclaration:	false
  # struct定义后面
  AfterStruct:	false
  # union定义后面
  AfterUnion:	false
  # catch之前
  BeforeCatch:	true
  # else之前
  BeforeElse:	true
  # 缩进大括号
  IndentBraces:	false
# 在二元运算符前换行: None(在操作符后换行), NonAssignment(在非赋值的操作符前换行), All(在操作符前换行)
BreakBeforeBinaryOperators:	NonAssignment
# 在大括号前换行: Attach(始终将大括号附加到周围的上下文), Linux(除函数、命名空间和类定义，与Attach类似), 
#   Mozilla(除枚举、函数、记录定义，与Attach类似), Stroustrup(除函数定义、catch、else，与Attach类似), 
#   Allman(总是在大括号前换行), GNU(总是在大括号前换行，并对于控制语句的大括号增加额外的缩进), WebKit(在函数前换行), Custom
#   注：这里认为语句块也属于函数
BreakBeforeBraces:	Custom
# 在三元运算符前换行
BreakBeforeTernaryOperators:	true
# 在构造函数的初始化列表的逗号前换行
BreakConstructorInitializersBeforeComma:	false
# 每行字符的限制，0表示没有限制
ColumnLimit:	200
# 描述具有特殊意义的注释的正则表达式，它不应该被分割为多行或以其它方式改变
CommentPragmas:	'^ IWYU pragma:'
# 构造函数的初始化列表要么都在同一行，要么都各自一行
ConstructorInitializerAllOnOneLineOrOnePerLine:	false
# 构造函数的初始化列表的缩进宽度
ConstructorInitializerIndentWidth:	4
# 延续的行的缩进宽度
ContinuationIndentWidth:	4
# 去除C++11的列表初始化的大括号{后和}前的空格
Cpp11BracedListStyle:	false
# 继承最常用的指针和引用的对齐方式
DerivePointerAlignment:	false
# 关闭格式化
DisableFormat:	false
# 自动检测函数的调用和定义是否被格式为每行一个参数(Experimental)
ExperimentalAutoDetectBinPacking:	false
# 需要被解读为foreach循环而不是函数调用的宏
ForEachMacros:	[ foreach, Q_FOREACH, BOOST_FOREACH ]
# 对#include进行排序，匹配了某正则表达式的#include拥有对应的优先级，匹配不到的则默认优先级为INT_MAX(优先级越小排序越靠前)，
#   可以定义负数优先级从而保证某些#include永远在最前面
IncludeCategories: 
  - Regex:	'^&quot;(llvm|llvm-c|clang|clang-c)/'
    Priority:	2
  - Regex:	'^(&lt;|&quot;(gtest|isl|json)/)'
    Priority:	3
  - Regex:	'.*'
    Priority:	1
# 缩进case标签
IndentCaseLabels:	false

# 缩进宽度 #
IndentWidth: 4

# 函数返回类型换行时，缩进函数声明或函数定义的函数名
IndentWrappedFunctionNames:	false
# 保留在块开始处的空行
KeepEmptyLinesAtTheStartOfBlocks:	true
# 开始一个块的宏的正则表达式
MacroBlockBegin:	''
# 结束一个块的宏的正则表达式
MacroBlockEnd:	''
# 连续空行的最大数量
MaxEmptyLinesToKeep:	1
# 命名空间的缩进: None, Inner(缩进嵌套的命名空间中的内容), All
NamespaceIndentation:	Inner
# 使用ObjC块时缩进宽度
ObjCBlockIndentWidth:	4
# 在ObjC的@property后添加一个空格
ObjCSpaceAfterProperty:	false
# 在ObjC的protocol列表前添加一个空格
ObjCSpaceBeforeProtocolList:	true
# 在call(后对函数调用换行的penalty
PenaltyBreakBeforeFirstCallParameter:	19
# 在一个注释中引入换行的penalty
PenaltyBreakComment:	300
# 第一次在&lt;&lt;前换行的penalty
PenaltyBreakFirstLessLess:	120
# 在一个字符串字面量中引入换行的penalty
PenaltyBreakString:	1000
# 对于每个在行字符数限制之外的字符的penalty
PenaltyExcessCharacter:	1000000
# 将函数的返回类型放到它自己的行的penalty
PenaltyReturnTypeOnItsOwnLine:	60
# 指针和引用的对齐: Left, Right, Middle
PointerAlignment:	Left
# 允许重新排版注释
ReflowComments:	true
# 允许排序#include
SortIncludes:	true
# 在C风格类型转换后添加空格
SpaceAfterCStyleCast:	false
# 在赋值运算符之前添加空格
SpaceBeforeAssignmentOperators:	true
# 开圆括号之前添加一个空格: Never, ControlStatements, Always
SpaceBeforeParens:	ControlStatements
# 在空的圆括号中添加空格
SpaceInEmptyParentheses:	false
# 在尾随的评论前添加的空格数(只适用于//)
SpacesBeforeTrailingComments:	2
# 在尖括号的&lt;后和&gt;前添加空格
SpacesInAngles:	true
# 在容器(ObjC和JavaScript的数组和字典等)字面量中添加空格
SpacesInContainerLiterals:	true
# 在C风格类型转换的括号中添加空格
SpacesInCStyleCastParentheses:	true
# 在圆括号的(后和)前添加空格
SpacesInParentheses:	true
# 在方括号的[后和]前添加空格，lamda表达式和未指明大小的数组的声明不受影响
SpacesInSquareBrackets:	true
# 标准: Cpp03, Cpp11, Auto
Standard:	Cpp11
# tab宽度
TabWidth:	4
# 使用tab字符: Never, ForIndentation, ForContinuationAndIndentation, Always
UseTab:	Never
...
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis]]></title>
        <id>https://blog.myxy.net/redis/</id>
        <link href="https://blog.myxy.net/redis/">
        </link>
        <updated>2020-09-19T05:59:55.000Z</updated>
        <content type="html"><![CDATA[<p>官方命令手册:<a href="https://oss.redislabs.com/redisearch/Commands.html">https://oss.redislabs.com/redisearch/Commands.html</a><br>
命令手册1:<a href="https://www.redis.net.cn/order/">https://www.redis.net.cn/order/</a><br>
命令手册2:<a href="https://www.redis.com.cn/commands/">https://www.redis.com.cn/commands/</a></p>
<table>
<thead>
<tr>
<th>角色</th>
<th style="text-align:left">redis.conf</th>
<th style="text-align:left">权限说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>超户</td>
<td style="text-align:left">requirepass</td>
<td style="text-align:left">所有功能</td>
</tr>
<tr>
<td>普通</td>
<td style="text-align:left">requireuserpass</td>
<td style="text-align:left">不能进程管理类命令,如shutdown</td>
</tr>
<tr>
<td>只读</td>
<td style="text-align:left">requirereaduserpass</td>
<td style="text-align:left">在普通用户基础上,进一步限制只能进行读操作,没有script命令权限</td>
</tr>
</tbody>
</table>
<h2 id="普通用户不能进行的操作有">普通用户不能进行的操作有：</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>INFO commandstats</td>
<td style="text-align:left">查看所有命令统计</td>
</tr>
<tr>
<td>CONFIG RESETSTAT</td>
<td style="text-align:left">重置统计</td>
</tr>
<tr>
<td>save</td>
<td style="text-align:left">SAVE命令执行一个同步保存操作,将当前Redis实列的所有数据快照(snapshot)以RDB文件的形式保存到硬盘</td>
</tr>
<tr>
<td>bgsave</td>
<td style="text-align:left">在后台异步(Asynchronously)保存当前数据库的数据到磁盘</td>
</tr>
<tr>
<td>bgrrwriteaof</td>
<td style="text-align:left">执行一个AOF文件重写操作,重写会创建一个当前AOF文件的体积优化版本,即使BGREWRITEAOF执行失败,也不会有任何数据丢失,因为旧的AOF文件在BGREWRITEAOF成功之前不会被修改</td>
</tr>
<tr>
<td>shutdown</td>
<td style="text-align:left">停止所有客户端,如果有至少一个保存点在等待,执行SAVE命令,如果AOF选项被打开,更新AOF文件,关闭Redis服务器(server)</td>
</tr>
<tr>
<td>sync</td>
<td style="text-align:left">用户复制功能(replication)的内部命令</td>
</tr>
<tr>
<td>psync</td>
<td style="text-align:left">用户复制功能(replication)的内部命令</td>
</tr>
<tr>
<td>replconf</td>
<td style="text-align:left">暂无用处</td>
</tr>
<tr>
<td>monitor</td>
<td style="text-align:left">实时打印出Redis服务器收到的命令,调试专用</td>
</tr>
<tr>
<td>slaveof</td>
<td style="text-align:left">SLAVEOF命令用户在Redis运行时动态地修改复制(replication)功能的行为</td>
</tr>
<tr>
<td>debug</td>
<td style="text-align:left">调试命令</td>
</tr>
<tr>
<td>config</td>
<td style="text-align:left">配置参数</td>
</tr>
<tr>
<td>restore</td>
<td style="text-align:left">反序列化给定的序列化值,并将它和给定的KEY关联</td>
</tr>
<tr>
<td>migrate</td>
<td style="text-align:left">将key原子性地从当前实例传送到目标实例的指定数据库上,一旦传送成功,KEY保证会出现在目标实例上,而当前实例上的KEY会被删除</td>
</tr>
<tr>
<td>dump</td>
<td style="text-align:left">序列化给定KEY,并返回被序列化的值,使用restore命令可以将这个值反序列化为Redis键</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>查看锁定IP</td>
<td style="text-align:left">config get lockedips</td>
</tr>
<tr>
<td>解锁单个IP</td>
<td style="text-align:left">config set unlockips 10.67.147.111</td>
</tr>
<tr>
<td>解锁所有IP</td>
<td style="text-align:left">config set unlockips “all”</td>
</tr>
</tbody>
</table>
<h1 id="string类型">string类型</h1>
<h2 id="字符串常见操作">字符串常见操作</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>set key value</td>
<td style="text-align:left">存入键值对</td>
</tr>
<tr>
<td>mset key value [key value…]</td>
<td style="text-align:left">批量存储字符串键值对</td>
</tr>
<tr>
<td>setnx key value</td>
<td style="text-align:left">存入一个不存在的字符串键值对</td>
</tr>
<tr>
<td>get key</td>
<td style="text-align:left">获取一个字符串</td>
</tr>
<tr>
<td>mget key [key…]</td>
<td style="text-align:left">批量获取字符串键值</td>
</tr>
<tr>
<td>del key [key…]</td>
<td style="text-align:left">删除一个键</td>
</tr>
<tr>
<td>expire key seconds</td>
<td style="text-align:left">设置一个键的过期时间（秒）</td>
</tr>
</tbody>
</table>
<h2 id="原子加减">原子加减</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>incr key</td>
<td style="text-align:left">将key中存储的数字值加一</td>
</tr>
<tr>
<td>decr key</td>
<td style="text-align:left">将key中存储的数字值减一</td>
</tr>
<tr>
<td>incr by key increment</td>
<td style="text-align:left">将key中所存储的值加上increment</td>
</tr>
<tr>
<td>decr by key decrement</td>
<td style="text-align:left">将key所存储的值减去decrement</td>
</tr>
</tbody>
</table>
<h2 id="string应用场景">string应用场景</h2>
<blockquote>
<p>计数器<br>
文章计数器 阅读量 incr article:num</p>
</blockquote>
<h2 id="分布式锁">分布式锁</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>setnx product true</td>
<td style="text-align:left">返回1代表获取锁成功</td>
</tr>
<tr>
<td>setnx product true</td>
<td style="text-align:left">返回0代表获取锁失败</td>
</tr>
<tr>
<td>del product</td>
<td style="text-align:left">执行完业务释放锁</td>
</tr>
</tbody>
</table>
<h1 id="hash类型">hash类型</h1>
<h2 id="hash常用操作">hash常用操作</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>hset key field value</td>
<td style="text-align:left">存储一个哈希key的键值</td>
</tr>
<tr>
<td>hsetnx key field value</td>
<td style="text-align:left">存储一个不存在的哈希表key的键值</td>
</tr>
<tr>
<td>hmseet key field value[field value…]</td>
<td style="text-align:left">在一个哈希表key中存储多个键值对</td>
</tr>
<tr>
<td>hget key field</td>
<td style="text-align:left">获取哈希表key对应的field的值</td>
</tr>
<tr>
<td>hmget key field[field…]</td>
<td style="text-align:left">批量获取哈希表key中多个field的值</td>
</tr>
<tr>
<td>hdel key field [field…]</td>
<td style="text-align:left">删除哈希表key中的field的键值</td>
</tr>
<tr>
<td>hlen key</td>
<td style="text-align:left">返回哈希表key中的field的数量</td>
</tr>
<tr>
<td>hgetall key</td>
<td style="text-align:left">返回哈希表key中所有的键值</td>
</tr>
<tr>
<td>hincrby key field increment</td>
<td style="text-align:left">为哈希表key中field键的值加上增量increment</td>
</tr>
</tbody>
</table>
<h2 id="hash应用场景">hash应用场景</h2>
<blockquote>
<p>对象缓存<br>
hmset user userid1:name value userid1:age 14<br>
购物车<br>
hmset user product1:name value prodeuct1:num value</p>
</blockquote>
<h2 id="hash优缺点">hash优缺点</h2>
<ul>
<li>优点<br>
同类数据归类整合存储，方便数据管理<br>
相比string操作消耗内存与cpu更小<br>
相比string存储更节省空间</li>
<li>缺点<br>
过期功能不能使用在field上，只能使用在key上<br>
Redis集群架构下不适合大规模使用</li>
</ul>
<h1 id="list类型">list类型</h1>
<h2 id="list常用操作">list常用操作</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>lpush key value[value…]</td>
<td style="text-align:left">将一个或多个值value插入到key列表的表头（最左边）</td>
</tr>
<tr>
<td>rpush key value[value…]</td>
<td style="text-align:left">将一个或多个value插入到key列表的表尾（最右边）</td>
</tr>
<tr>
<td>lpop key</td>
<td style="text-align:left">移除并返回key列表的头元素</td>
</tr>
<tr>
<td>rpop key</td>
<td style="text-align:left">移除并返回key列表的尾元素</td>
</tr>
<tr>
<td>lrange key start stop</td>
<td style="text-align:left">返回列表key中指定区间内的元素，区间以偏移量start和stop指定</td>
</tr>
<tr>
<td>blpop key [key…] timeout</td>
<td style="text-align:left">从key列表表头弹出一个元素，若列表中没有元素，阻塞等待timeout秒，如果timeout=0，一直阻塞等待</td>
</tr>
<tr>
<td>brpop key [key…] timeout</td>
<td style="text-align:left">从key列表表尾弹出一个元素，若列表中没有元素，阻塞等待timeout秒，如果timeout=0，一直阻塞等待</td>
</tr>
</tbody>
</table>
<h2 id="list应用场景">list应用场景</h2>
<p>栈（stack）<br>
lpush + lpop —&gt;FILO<br>
队列（queue）<br>
lpush + rpop<br>
阻塞队列（Blocking MQ）<br>
lpush + brpop<br>
微博微信消息流<br>
使用lpush放入用户ID消息，然后使用lrange 来获取消息</p>
<h1 id="set类型">set类型</h1>
<h2 id="set常用操作">set常用操作</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>sadd key member [member…]</td>
<td style="text-align:left">往集合key中存入元素，元素存在则忽略，若key不存在则创建</td>
</tr>
<tr>
<td>srem key member[member…]</td>
<td style="text-align:left">从集合key中删除元素</td>
</tr>
<tr>
<td>smembers key</td>
<td style="text-align:left">获取集合key中的所有元素</td>
</tr>
<tr>
<td>scardkey</td>
<td style="text-align:left">获取集合key中的元素的个数</td>
</tr>
<tr>
<td>sismemver key member</td>
<td style="text-align:left">判断member元素是否存在于集合key中</td>
</tr>
<tr>
<td>srandmember key [count]</td>
<td style="text-align:left">从集合key中选出count个元素，元素不从key中删除</td>
</tr>
</tbody>
</table>
<p>spop key [count]//从集合key中选出count个元素，元素从key中删除</p>
<h2 id="set运算操作">set运算操作</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>sinter key [key…]</td>
<td style="text-align:left">交集运算</td>
</tr>
<tr>
<td>sinterstore destination key [key…]</td>
<td style="text-align:left">交集结果存入新集合destination中</td>
</tr>
<tr>
<td>sunion key [key…]</td>
<td style="text-align:left">并集运算</td>
</tr>
<tr>
<td>sunionstore destination key [key…]</td>
<td style="text-align:left">并集结果存入新集合destination中</td>
</tr>
<tr>
<td>sdiff key [key…]</td>
<td style="text-align:left">差集运算</td>
</tr>
<tr>
<td>sdiffstore destination key [key…]</td>
<td style="text-align:left">差集结果存入新集合destination中</td>
</tr>
</tbody>
</table>
<h2 id="set使用场景">set使用场景</h2>
<p>微信抽奖小程序<br>
点击参与抽奖加入集合 sadd key {userID}<br>
查看参与抽奖所有用户 smembers key<br>
抽取count名中奖者 srandmember key [count]/spop key [count]<br>
微信微博点赞、收藏、标签<br>
点赞 sadd user ID<br>
取消点赞 srem user ID<br>
检查用户是否点过赞 sismember user ID<br>
获取用户点赞列表 smembers user<br>
获取点赞用户数 scard user<br>
关注模型 （使用集合）<br>
共同关注的人 ------ 交集<br>
可能认识的人 ------- 差集</p>
<p>其他应用场景:<br>
https://bbs.huaweicloud.com/forum/thread-10558-1-1.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Promise]]></title>
        <id>https://blog.myxy.net/promise/</id>
        <link href="https://blog.myxy.net/promise/">
        </link>
        <updated>2020-09-07T08:11:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="promise是什么">promise是什么？</h1>
<ul>
<li>主要用于异步计算</li>
<li>可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果</li>
<li>可以在对象之间传递和操作promise，帮助我们处理队列</li>
</ul>
<blockquote>
<p><em>同步</em>：假设你去了一家饭店，找个位置，叫来服务员，这个时候服务员对你说，对不起我是“同步”服务员，我要服务完这张桌子才能招呼你。那桌客人明明已经吃上了，你只是想要个菜单，这么小的动作，服务员却要你等到别人的一个大动作完成之后，才能再来招呼你，这个便是同步的问题：也就是“顺序交付的工作1234，必须按照1234的顺序完成”。<br>
<em>异步</em>：则是将耗时很长的A交付的工作交给系统之后，就去继续做B交付的工作，。等到系统完成了前面的工作之后，再通过回调或者事件，继续做A剩下的工作。<br>
AB工作的完成顺序，和交付他们的时间顺序无关，所以叫“异步”。</p>
</blockquote>
<p>promise详解</p>
<pre><code>new Promise(
  function (resolve, reject) {
    // 一段耗时的异步操作
    resolve('成功') // 数据处理完成
    // reject('失败') // 数据处理出错
  }
).then(
  (res) =&gt; {console.log(res)},  // 成功
  (err) =&gt; {console.log(err)} // 失败
)
</code></pre>
<p><code>resolve</code>作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</p>
<p><code>reject</code>作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p><em>promise</em>有三个状态：<br>
1、pending[待定]初始状态<br>
2、fulfilled[实现]操作成功<br>
3、rejected[被否决]操作失败<br>
当promise状态发生改变，就会触发then()里的响应函数处理后续步骤；<br>
promise状态一经改变，不会再变。</p>
<p>Promise对象的状态改变，只有两种可能：<br>
从pending变为fulfilled<br>
从pending变为rejected。<br>
这两种情况只要发生，状态就凝固了，不会再变了。</p>
<p>1.promise简单用法</p>
<pre><code>function2(){
    // 你的逻辑代码 
    return Promise.resolve(/* 这里是需要返回的数据*/)
}

function3(){
    // 你的逻辑代码 
    return Promise.resolve(/* 这里是需要返回的数据*/)
}

// 调用
function1(){
    this.function2().then(val =&gt; { 
        this.function3();
    });
}
</code></pre>
<p>2.promise高阶用法</p>
<pre><code>init1(){
return new Promise((resolve, reject) =&gt; {
    let data={
        dateStr:this.time
    };
    api.get('url', null).then( res =&gt; {
       //自己的操作
        resolve()
    }).catch(err =&gt; {
        reject()
    });
});
};
init2(){
return new Promise((resolve, reject) =&gt; {
    let data={
        dateStr:this.time
    };
    api.get('url', null).then( res =&gt; {
       //自己的操作
        resolve()
    }).catch(err =&gt; {
        reject()
    });
});
};


//调用
Promise.all([this.init1(),this.init2()]).then(() =&gt; {
    //两个都调成功以后执行的操作
//主要是loading问题
}).catch(err =&gt; {
    // 抛出错误信息
});
</code></pre>
<p>https://www.jianshu.com/p/1b63a13c2701<br>
https://blog.csdn.net/qq_34645412/article/details/81170576</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[lodash]]></title>
        <id>https://blog.myxy.net/lodash/</id>
        <link href="https://blog.myxy.net/lodash/">
        </link>
        <updated>2020-09-05T02:43:11.000Z</updated>
        <content type="html"><![CDATA[<p><em>文档</em><br>
<a href="https://www.lodashjs.com/">https://www.lodashjs.com/</a><br>
<a href="http://lodash.think2011.net/">http://lodash.think2011.net/</a><br>
<a href="https://www.html.cn/doc/lodash/">https://www.html.cn/doc/lodash/</a></p>
<p>assign，extend 和 merge 的区别<br>
https://blog.csdn.net/u011153667/article/details/52275797</p>
<h2 id="isarray">isArray</h2>
<p><code>_.isArray(value)</code></p>
<blockquote>
<p>检查 value 是否是 Array 类对象。</p>
</blockquote>
<h2 id="iselement">isElement</h2>
<p><code>_.isElement(value)</code></p>
<blockquote>
<p>检查 value 是否是可能是 DOM 元素</p>
</blockquote>
<h2 id="isequal">isEqual</h2>
<blockquote>
<p>执行深比较来决定两者的值是否相等</p>
</blockquote>
<pre><code>var object = { 'user': 'fred' };
var other = { 'user': 'fred' };

_.isEqual(object, other);
// =&gt; true

object === other;
// =&gt; false
</code></pre>
<h2 id="isinteger">isInteger</h2>
<blockquote>
<p>检查 value 是否是整数</p>
</blockquote>
<h2 id="ismatch">isMatch</h2>
<p><code>_.isMatch(object, source)</code></p>
<blockquote>
<p>执行一个深比较来确定object 是否包含有 source 的属性值。</p>
</blockquote>
<pre><code>var object = { 'user': 'fred', 'age': 40 };

_.isMatch(object, { 'age': 40 });
// =&gt; true

_.isMatch(object, { 'age': 36 });
// =&gt; false
</code></pre>
<h2 id="isnil">isNil</h2>
<p><code>_.isNil(value)</code></p>
<blockquote>
<p>检查 value 是否是 null 或者 undefined。</p>
</blockquote>
<h2 id="isplainobject">isPlainObject</h2>
<blockquote>
<p>检查 value 是否是普通对象。 也就是说该对象由 Object 构造函数创建或者 [[Prototype]] 为空。</p>
</blockquote>
<pre><code>function Foo() {
  this.a = 1;
}

_.isPlainObject(new Foo);
// =&gt; false

_.isPlainObject([1, 2, 3]);
// =&gt; false

_.isPlainObject({ 'x': 0, 'y': 0 });
// =&gt; true

_.isPlainObject(Object.create(null));
// =&gt; true
</code></pre>
<h2 id="isundefined">isUndefined</h2>
<h2 id="isnull">isNull</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iview 表单验证]]></title>
        <id>https://blog.myxy.net/iview-biao-dan-yan-zheng/</id>
        <link href="https://blog.myxy.net/iview-biao-dan-yan-zheng/">
        </link>
        <updated>2020-09-02T05:14:38.000Z</updated>
        <content type="html"><![CDATA[<p>Form 组件基于 <a href="https://github.com/yiminghe/async-validator">async-validator</a>实现的数据验证，给 Form 设置属性 rules，同时给需要验证的 FormItem 设置属性 prop 指向对应字段即可。</p>
<p>完整的验证规则请参照开源项目 async-validator。</p>
<p>验证方法也支持 Promise。</p>
<p>https://www.jianshu.com/p/627c42d6da79<br>
https://www.cnblogs.com/wozho/p/10955525.html<br>
https://www.jianshu.com/p/2105c48b45c7</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ES6]]></title>
        <id>https://blog.myxy.net/es6/</id>
        <link href="https://blog.myxy.net/es6/">
        </link>
        <updated>2020-08-28T03:10:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="对象字面量简写">对象字面量简写</h2>
<p><code>https://zhuanlan.zhihu.com/p/56215043</code></p>
<h2 id="模板字符串">模板字符串</h2>
<blockquote>
<p>模板字符串就是一种字符串的新的表现形式,模板字符串的出现，极大的改变传统字符串的拼接方法，减少代码出现错误的几率。提高开发效率</p>
</blockquote>
<ul>
<li>基本用法</li>
</ul>
<pre><code>let s1 = ` hello `
let s2 = ' hello '
</code></pre>
<ul>
<li>字符串和变量拼接</li>
</ul>
<pre><code>let s3 =&quot; a &quot; + s1 + &quot; b &quot; + s2;
let s4 = ` a ${s1} b ${s2}`;  
</code></pre>
<ul>
<li>字符串换行</li>
</ul>
<pre><code>var box =`&lt;div&gt;
            &lt;p&gt;
              &lt;span&gt;123&lt;/span&gt;
            &lt;/p&gt;
            &lt;p&gt;${a1}&lt;/p&gt;
         &lt;/div&gt;`;
</code></pre>
<h2 id="解构赋值">解构赋值</h2>
<blockquote>
<p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构</p>
</blockquote>
<ul>
<li>对象结构赋值</li>
</ul>
<pre><code>var obj ={ name:&quot;abc&quot;,age:18 };
    //用解构赋值的方式获取name、age

    let { name } = obj; //创建了一个变量name，值=obj.name
    console.log(name);  //&quot;abc&quot;

    let { age } =obj;
    console.log(age);  //18
</code></pre>
<ul>
<li>函数参数结构赋值</li>
</ul>
<pre><code>function f1(obj){
        console.log(obj.age);
        console.log(obj.height)
    }
    //等价于
    function f1({ age,height }){
        console.log(age);
        console.log(height)
    }

    f1({age:5,height:180})
</code></pre>
<h2 id="rest参数">rest参数</h2>
<blockquote>
<p>ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。es6箭头函数内部不能使用arguments，为了弥补这个问题，rest参数应孕而生</p>
</blockquote>
<pre><code>function fn(){
        //arguments是函数内部的一个局部变量，
        //arguments.length表示函数的实参的个数
        console.log(arguments.length);

        for(var i =0 ; i&lt;arguments.length; i++){
            console.log(arguments[i]);
        }

    }
    fn(1,3,5)       //3
    // fn(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;) //5

    //...args就是rest参数
    //--&gt;产生了一个变量，这个变量是一个数组，数组里面包含了这个函数调用时传递的所有实参
    function q(...args){
        //验证args是不是数组？
        console.log(args instanceof Array);//true
        console.log(Object.prototype.toString.call(args));//&quot;[object Array]&quot;
        console.log(Array.isArray(args));   //true es5中的新方法

        console.log(args);
    }
    q(1,3,5);
    q(2,3,4,5,6,7,8);
</code></pre>
<h2 id="箭头函数">箭头函数</h2>
<blockquote>
<p>ES6 允许使用“箭头”（=&gt;）定义函数。<br>
<em>箭头函数和普通匿名函数有哪些不同？</em><br>
1.函数体内的this对象，就是定义所在的对象，而不是使用所在的对象<br>
2.不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误<br>
3.不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。<br>
4.不可以使用yield命令，因此箭头函数不能用作 Generator 函数。<br>
5.generator函数现在经常用async替代</p>
</blockquote>
<ul>
<li>用于替换匿名函数</li>
</ul>
<pre><code>基本用法

//匿名函数
div.onclick=function(){
    console.log(&quot;你好&quot;)
}
//箭头函数
div.onclick=()=&gt;{
    console.log(&quot;你好&quot;)
}
</code></pre>
<ul>
<li>有一个参数的箭头函数</li>
</ul>
<pre><code>var fn=(a)=&gt;{
        console.log(&quot;abc&quot;);
    }
    //等价于：
    var fn=a=&gt;{
        console.log(&quot;abc&quot;);
    }

</code></pre>
<ul>
<li>有2个及更多参数的箭头函数</li>
</ul>
<pre><code> var f=(a,b,c)=&gt;{
        console.log(&quot;abc&quot;)
    }
</code></pre>
<pre><code>var p={
        age:18,
        //es6中对象方法的箭头函数表示形式
        run:()=&gt;{
            setTimeout(()=&gt;{
                //this:window
                console.log(this);//this是window
            },100)
        },
        travel:function(){
            //this:p
            setTimeout(()=&gt;{
                console.log(this);//this是p
            },100)
        },
        //推荐使用的方式☆☆☆：es6中对象方法的简写形式
        say(){
            console.log(&quot;say方法中的this：&quot;,this);
            setTimeout(()=&gt;{
                console.log(&quot;say内部的延迟函数：&quot;,this);//this是p
            },100)
        },
    }

    p.run();

    p.travel();

    p.say();
</code></pre>
<h2 id="let">let</h2>
<blockquote>
<p>用来声明变量。它的用法类似于var,但是所声明的变量，只在let命令所在的代码块内有效。</p>
</blockquote>
<pre><code>for (let i = 0; i &lt; 10; i++) {
 
 }
console.log(i) //ReferenceError: i is not defined&lt;br&gt;&lt;br&gt;for(var i=0;i&lt;10;i++){&lt;br&gt;&lt;br&gt;}&lt;br&gt;console.log(i) //10&lt;br&gt;
</code></pre>
<h2 id="const">const</h2>
<blockquote>
<p>用来声明一个只读的常量，一旦声明，常量的值就不能改变。，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>
</blockquote>
<pre><code>const a = 10；
a = 20；
console.log(a)  //TypeError: Assignment to constant variable.
上面代码表明改变常量的值会报错。
</code></pre>
<h2 id="promise">Promise</h2>
<blockquote>
<p>Promise是异步编程一种解决方案(回调地狱)</p>
</blockquote>
<pre><code>在没有promise都是这样写的回调，一层一层的写，
$.get(&quot;/getUser&quot;,function(res){
        $.get(&quot;/getUserDetail&quot;,function(){
            $.get(&quot;/getCart&quot;,function(){
                $.get(&quot;/getBooks&quot;,function(){
                    //...
                })
            })
        })
    })
</code></pre>
<ul>
<li>promise的基本用法</li>
</ul>
<pre><code>var promise=new Promise((resolve,reject)=&gt;{
       //b 把需要执行的异步操作放在这里
       $.get(&quot;/getUser&quot;,res=&gt;{
           //获取数据的异步操作已经执行完毕了，等待下一步的执行，通过执行resolve函数，告诉外界你可以执行下一步操作了
           //c、
           resolve(res)
           //而执行的下一步操作，其实就是写在then的回调函数中的
       })
   })
   //a、
   promise.then(res=&gt;{
       //d、执行后续的操作
       console.log(res);
   })
</code></pre>
<ul>
<li>promise实现多层回调</li>
</ul>
<pre><code>
new Promise((resolve,reject)=&gt;{
        $.get(&quot;/getUser&quot;,res=&gt;{
            resolve(res)
        })
    }).then(res=&gt;{
        //用户基本信息
        return new Promise(resolve=&gt;{
            $.get(&quot;/getUserDetail&quot;,res=&gt;{
                resolve(res)
            })
        })
    }).then(res=&gt;{
        //用户详情
        return new Promise(resolve=&gt;{
            $.get(&quot;/getCart&quot;,res=&gt;{
                resolve(res)
            })
        })
    }).then(res=&gt;{
        //购物车信息
    })
</code></pre>
<ul>
<li>promise实现错误处理</li>
</ul>
<pre><code>new Promise((resolve,reject)=&gt;{
        $.ajax({
            url:&quot;/getUser&quot;,
            type:&quot;GET&quot;,
            success:res=&gt;{
                resolve(res);
            },
            error:res=&gt;{
                reject(res)
            }
        })
    }).then(resSuccess=&gt;{
        //成功的返回值
    },resError=&gt;{
        //失败的返回值
    })
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 vue-devtools]]></title>
        <id>https://blog.myxy.net/shi-yong-vue-devtools/</id>
        <link href="https://blog.myxy.net/shi-yong-vue-devtools/">
        </link>
        <updated>2020-08-10T11:18:10.000Z</updated>
        <content type="html"><![CDATA[<p>找到<a href="https://github.com/vuejs/vue-devtools">vue-devtools</a>的github项目，克隆到本地；<br>
进入到项目根目录，安装依赖 <code>npm install</code> 或着 <code>cpm install</code>；<br>
找到<code>vue-devtools/shells/chrome/manifest.json</code> 文件，修改 <code>persistent</code> 为 <code>true</code>；<br>
编译构建 <code>npm run build</code>；<br>
打开chrome浏览器，输入 <code>chrome://extensions</code> 进入扩展程序页面，点击 加载已解压的扩展程序, 选择 <code>vue-devtools&gt;shells&gt;chrome</code>文件夹 （记得打开开发者模式)<br>
<code>Vue.js devtools</code> 就安装好了，点击扩展应用卡片上的 详细信息，勾选(在所有网站上,允许访问文件网址,手机各项错误)三个选项。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[cjson 使用记录]]></title>
        <id>https://blog.myxy.net/cjson-shi-yong-ji-lu/</id>
        <link href="https://blog.myxy.net/cjson-shi-yong-ji-lu/">
        </link>
        <updated>2020-07-25T12:34:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="备忘">备忘</h1>
<h3 id="打印">打印</h3>
<p><code>cJSON_Print</code>会申请内存，使用完后要free掉。</p>
<pre><code class="language-cpp">	const  char* pstr = cJSON_Print(json);
	free(pstr);
</code></pre>
<p><code>cJSON_PrintUnformatted</code> 打印出的json字符串是紧凑的不用换行，适合传输json字符串时使用<br>
<code>cJSON_PrintBuffered</code> 可以事先指定分配一个缓冲区，如果足够大，则可以节省不断重新分配空间的时间； 如果指定缓冲区过小，则与cJSON_Print和cJSON_PrintUnformatted性能能相同。<br>
<code>cJSON_PrintPreallocated</code>  可以将json字符串填入给定的缓冲区，并指定缓冲区大小。 成功返回1，失败返回0。除了这个打印json字符串的函数，以上的函数在生成json字符串时若空间不足，都会重新分配一次空间。</p>
<h3 id="销毁">销毁</h3>
<p>JSON对象使用完成记得Delete</p>
<pre><code class="language-cpp">	cJSON* pjson = NULL;
	pjson = cJSON_Parse(&quot;{}&quot;);
	cJSON_Delete(pjson);
</code></pre>
<h3 id="解析">解析</h3>
<p><code>cJSON_ParseWithOpts</code>该函数是<code>cJSON_Parse</code>的实现，但是它比<code>cJSON_Parse</code>更灵活。</p>
<ul>
<li>如果cJSON_Parse解析错误，必须调用cJSON_GetErrorPtr找到解析错误位置</li>
<li>cJSON_Parse解析不严谨，如&quot;<code>{\&quot;name\&quot;: \&quot;Lee\&quot;} }</code>&quot;这个字符串，后边多了一个大括号，但还是解析成功了。</li>
<li><code>cJSON_ParseWithOpts</code>的return_parse_end参数可以获取解析失败的位置，          require_null_terminated参数为1会检查剩余未解析字符串是否是空字符串，若不为空字符串，则会释放内存，返回空。所以因该使用<code>cJSON_ParseWithOpts</code>解析json对象</li>
</ul>
<pre><code class="language-cpp">	char* end = NULL;
	cJSON* cj_ParseWithOpts = cJSON_ParseWithOpts(&quot;{\&quot;name\&quot;: \&quot;Lee\&quot;} }&quot;, &amp;end, 1);
	if (cj_ParseWithOpts) {
		printf(&quot;%s\n\n&quot;, cJSON_Print(cj_ParseWithOpts));
	}
	else {
		printf(&quot;[%s]\n\n&quot;, end);
	}
</code></pre>
<h1 id="数组倒删除">数组倒删除</h1>
<pre><code class="language-cpp">	cJSON* adArr = NULL;  //欲删除的数组
	int arrCount = cJSON_GetArraySize(adArr);
	if (arrCount &gt; 0)
	{
		for (int j = arrCount - 1; j &gt;= 0; j--)
		{
			cJSON_DeleteItemFromArray(adArr, j);  //删除json数组对象的第j个节点
		}
	}
</code></pre>
<h1 id="对象替换">对象替换</h1>
<pre><code class="language-cpp"> cJSON* itemObj = NULL;  

   //文本替换
   cJSON_ReplaceItemInObject(itemObj, &quot;username&quot;, cJSON_CreateString(&quot;tom&quot;));

   //数组清空
   cJSON_ReplaceItemInObject(itemObj, &quot;userlist&quot;, cJSON_CreateArray());
</code></pre>
]]></content>
    </entry>
</feed>