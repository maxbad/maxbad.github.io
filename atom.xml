<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.myxy.net</id>
    <title>Maxbad`Blog</title>
    <updated>2020-09-02T13:42:16.635Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.myxy.net"/>
    <link rel="self" href="https://blog.myxy.net/atom.xml"/>
    <subtitle>记录一些东西</subtitle>
    <logo>https://blog.myxy.net/images/avatar.png</logo>
    <icon>https://blog.myxy.net/favicon.ico</icon>
    <rights>All rights reserved 2020, Maxbad`Blog</rights>
    <entry>
        <title type="html"><![CDATA[iview 表单验证]]></title>
        <id>https://blog.myxy.net/iview-biao-dan-yan-zheng/</id>
        <link href="https://blog.myxy.net/iview-biao-dan-yan-zheng/">
        </link>
        <updated>2020-09-02T05:14:38.000Z</updated>
        <content type="html"><![CDATA[<p>Form 组件基于 <a href="https://github.com/yiminghe/async-validator">async-validator</a>实现的数据验证，给 Form 设置属性 rules，同时给需要验证的 FormItem 设置属性 prop 指向对应字段即可。</p>
<p>完整的验证规则请参照开源项目 async-validator。</p>
<p>验证方法也支持 Promise。</p>
<p>https://www.jianshu.com/p/627c42d6da79<br>
https://www.cnblogs.com/wozho/p/10955525.html<br>
https://www.jianshu.com/p/2105c48b45c7</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ES6]]></title>
        <id>https://blog.myxy.net/es6/</id>
        <link href="https://blog.myxy.net/es6/">
        </link>
        <updated>2020-08-28T03:10:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="对象字面量简写">对象字面量简写</h2>
<p><code>https://zhuanlan.zhihu.com/p/56215043</code></p>
<h2 id="模板字符串">模板字符串</h2>
<blockquote>
<p>模板字符串就是一种字符串的新的表现形式,模板字符串的出现，极大的改变传统字符串的拼接方法，减少代码出现错误的几率。提高开发效率</p>
</blockquote>
<ul>
<li>基本用法</li>
</ul>
<pre><code>let s1 = ` hello `
let s2 = ' hello '
</code></pre>
<ul>
<li>字符串和变量拼接</li>
</ul>
<pre><code>let s3 =&quot; a &quot; + s1 + &quot; b &quot; + s2;
let s4 = ` a ${s1} b ${s2}`;  
</code></pre>
<ul>
<li>字符串换行</li>
</ul>
<pre><code>var box =`&lt;div&gt;
            &lt;p&gt;
              &lt;span&gt;123&lt;/span&gt;
            &lt;/p&gt;
            &lt;p&gt;${a1}&lt;/p&gt;
         &lt;/div&gt;`;
</code></pre>
<h2 id="解构赋值">解构赋值</h2>
<blockquote>
<p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构</p>
</blockquote>
<ul>
<li>对象结构赋值</li>
</ul>
<pre><code>var obj ={ name:&quot;abc&quot;,age:18 };
    //用解构赋值的方式获取name、age

    let { name } = obj; //创建了一个变量name，值=obj.name
    console.log(name);  //&quot;abc&quot;

    let { age } =obj;
    console.log(age);  //18
</code></pre>
<ul>
<li>函数参数结构赋值</li>
</ul>
<pre><code>function f1(obj){
        console.log(obj.age);
        console.log(obj.height)
    }
    //等价于
    function f1({ age,height }){
        console.log(age);
        console.log(height)
    }

    f1({age:5,height:180})
</code></pre>
<h2 id="rest参数">rest参数</h2>
<blockquote>
<p>ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。es6箭头函数内部不能使用arguments，为了弥补这个问题，rest参数应孕而生</p>
</blockquote>
<pre><code>function fn(){
        //arguments是函数内部的一个局部变量，
        //arguments.length表示函数的实参的个数
        console.log(arguments.length);

        for(var i =0 ; i&lt;arguments.length; i++){
            console.log(arguments[i]);
        }

    }
    fn(1,3,5)       //3
    // fn(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;) //5

    //...args就是rest参数
    //--&gt;产生了一个变量，这个变量是一个数组，数组里面包含了这个函数调用时传递的所有实参
    function q(...args){
        //验证args是不是数组？
        console.log(args instanceof Array);//true
        console.log(Object.prototype.toString.call(args));//&quot;[object Array]&quot;
        console.log(Array.isArray(args));   //true es5中的新方法

        console.log(args);
    }
    q(1,3,5);
    q(2,3,4,5,6,7,8);
</code></pre>
<h2 id="箭头函数">箭头函数</h2>
<blockquote>
<p>ES6 允许使用“箭头”（=&gt;）定义函数。<br>
<em>箭头函数和普通匿名函数有哪些不同？</em><br>
1.函数体内的this对象，就是定义所在的对象，而不是使用所在的对象<br>
2.不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误<br>
3.不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。<br>
4.不可以使用yield命令，因此箭头函数不能用作 Generator 函数。<br>
5.generator函数现在经常用async替代</p>
</blockquote>
<ul>
<li>用于替换匿名函数</li>
</ul>
<pre><code>基本用法

//匿名函数
div.onclick=function(){
    console.log(&quot;你好&quot;)
}
//箭头函数
div.onclick=()=&gt;{
    console.log(&quot;你好&quot;)
}
</code></pre>
<ul>
<li>有一个参数的箭头函数</li>
</ul>
<pre><code>var fn=(a)=&gt;{
        console.log(&quot;abc&quot;);
    }
    //等价于：
    var fn=a=&gt;{
        console.log(&quot;abc&quot;);
    }

</code></pre>
<ul>
<li>有2个及更多参数的箭头函数</li>
</ul>
<pre><code> var f=(a,b,c)=&gt;{
        console.log(&quot;abc&quot;)
    }
</code></pre>
<pre><code>var p={
        age:18,
        //es6中对象方法的箭头函数表示形式
        run:()=&gt;{
            setTimeout(()=&gt;{
                //this:window
                console.log(this);//this是window
            },100)
        },
        travel:function(){
            //this:p
            setTimeout(()=&gt;{
                console.log(this);//this是p
            },100)
        },
        //推荐使用的方式☆☆☆：es6中对象方法的简写形式
        say(){
            console.log(&quot;say方法中的this：&quot;,this);
            setTimeout(()=&gt;{
                console.log(&quot;say内部的延迟函数：&quot;,this);//this是p
            },100)
        },
    }

    p.run();

    p.travel();

    p.say();
</code></pre>
<h2 id="let">let</h2>
<blockquote>
<p>用来声明变量。它的用法类似于var,但是所声明的变量，只在let命令所在的代码块内有效。</p>
</blockquote>
<pre><code>for (let i = 0; i &lt; 10; i++) {
 
 }
console.log(i) //ReferenceError: i is not defined&lt;br&gt;&lt;br&gt;for(var i=0;i&lt;10;i++){&lt;br&gt;&lt;br&gt;}&lt;br&gt;console.log(i) //10&lt;br&gt;
</code></pre>
<h2 id="const">const</h2>
<blockquote>
<p>用来声明一个只读的常量，一旦声明，常量的值就不能改变。，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>
</blockquote>
<pre><code>const a = 10；
a = 20；
console.log(a)  //TypeError: Assignment to constant variable.
上面代码表明改变常量的值会报错。
</code></pre>
<h2 id="promise">Promise</h2>
<blockquote>
<p>Promise是异步编程一种解决方案(回调地狱)</p>
</blockquote>
<pre><code>在没有promise都是这样写的回调，一层一层的写，
$.get(&quot;/getUser&quot;,function(res){
        $.get(&quot;/getUserDetail&quot;,function(){
            $.get(&quot;/getCart&quot;,function(){
                $.get(&quot;/getBooks&quot;,function(){
                    //...
                })
            })
        })
    })
</code></pre>
<ul>
<li>promise的基本用法</li>
</ul>
<pre><code>var promise=new Promise((resolve,reject)=&gt;{
       //b 把需要执行的异步操作放在这里
       $.get(&quot;/getUser&quot;,res=&gt;{
           //获取数据的异步操作已经执行完毕了，等待下一步的执行，通过执行resolve函数，告诉外界你可以执行下一步操作了
           //c、
           resolve(res)
           //而执行的下一步操作，其实就是写在then的回调函数中的
       })
   })
   //a、
   promise.then(res=&gt;{
       //d、执行后续的操作
       console.log(res);
   })
</code></pre>
<ul>
<li>promise实现多层回调</li>
</ul>
<pre><code>
new Promise((resolve,reject)=&gt;{
        $.get(&quot;/getUser&quot;,res=&gt;{
            resolve(res)
        })
    }).then(res=&gt;{
        //用户基本信息
        return new Promise(resolve=&gt;{
            $.get(&quot;/getUserDetail&quot;,res=&gt;{
                resolve(res)
            })
        })
    }).then(res=&gt;{
        //用户详情
        return new Promise(resolve=&gt;{
            $.get(&quot;/getCart&quot;,res=&gt;{
                resolve(res)
            })
        })
    }).then(res=&gt;{
        //购物车信息
    })
</code></pre>
<ul>
<li>promise实现错误处理</li>
</ul>
<pre><code>new Promise((resolve,reject)=&gt;{
        $.ajax({
            url:&quot;/getUser&quot;,
            type:&quot;GET&quot;,
            success:res=&gt;{
                resolve(res);
            },
            error:res=&gt;{
                reject(res)
            }
        })
    }).then(resSuccess=&gt;{
        //成功的返回值
    },resError=&gt;{
        //失败的返回值
    })
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 vue-devtools]]></title>
        <id>https://blog.myxy.net/shi-yong-vue-devtools/</id>
        <link href="https://blog.myxy.net/shi-yong-vue-devtools/">
        </link>
        <updated>2020-08-10T11:18:10.000Z</updated>
        <content type="html"><![CDATA[<p>找到<a href="https://github.com/vuejs/vue-devtools">vue-devtools</a>的github项目，克隆到本地；<br>
进入到项目根目录，安装依赖 <code>npm install</code> 或着 <code>cpm install</code>；<br>
找到<code>vue-devtools/shells/chrome/manifest.json</code> 文件，修改 <code>persistent</code> 为 <code>true</code>；<br>
编译构建 <code>npm run build</code>；<br>
打开chrome浏览器，输入 <code>chrome://extensions</code> 进入扩展程序页面，点击 加载已解压的扩展程序, 选择 <code>vue-devtools&gt;shells&gt;chrome</code>文件夹 （记得打开开发者模式)<br>
<code>Vue.js devtools</code> 就安装好了，点击扩展应用卡片上的 详细信息，勾选(在所有网站上,允许访问文件网址,手机各项错误)三个选项。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[cjson 使用记录]]></title>
        <id>https://blog.myxy.net/cjson-shi-yong-ji-lu/</id>
        <link href="https://blog.myxy.net/cjson-shi-yong-ji-lu/">
        </link>
        <updated>2020-07-25T12:34:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="备忘">备忘</h1>
<h3 id="打印">打印</h3>
<p><code>cJSON_Print</code>会申请内存，使用完后要free掉。</p>
<pre><code class="language-cpp">	const  char* pstr = cJSON_Print(json);
	free(pstr);
</code></pre>
<p><code>cJSON_PrintUnformatted</code> 打印出的json字符串是紧凑的不用换行，适合传输json字符串时使用<br>
<code>cJSON_PrintBuffered</code> 可以事先指定分配一个缓冲区，如果足够大，则可以节省不断重新分配空间的时间； 如果指定缓冲区过小，则与cJSON_Print和cJSON_PrintUnformatted性能能相同。<br>
<code>cJSON_PrintPreallocated</code>  可以将json字符串填入给定的缓冲区，并指定缓冲区大小。 成功返回1，失败返回0。除了这个打印json字符串的函数，以上的函数在生成json字符串时若空间不足，都会重新分配一次空间。</p>
<h3 id="销毁">销毁</h3>
<p>JSON对象使用完成记得Delete</p>
<pre><code class="language-cpp">	cJSON* pjson = NULL;
	pjson = cJSON_Parse(&quot;{}&quot;);
	cJSON_Delete(pjson);
</code></pre>
<h3 id="解析">解析</h3>
<p><code>cJSON_ParseWithOpts</code>该函数是<code>cJSON_Parse</code>的实现，但是它比<code>cJSON_Parse</code>更灵活。</p>
<ul>
<li>如果cJSON_Parse解析错误，必须调用cJSON_GetErrorPtr找到解析错误位置</li>
<li>cJSON_Parse解析不严谨，如&quot;<code>{\&quot;name\&quot;: \&quot;Lee\&quot;} }</code>&quot;这个字符串，后边多了一个大括号，但还是解析成功了。</li>
<li><code>cJSON_ParseWithOpts</code>的return_parse_end参数可以获取解析失败的位置，          require_null_terminated参数为1会检查剩余未解析字符串是否是空字符串，若不为空字符串，则会释放内存，返回空。所以因该使用<code>cJSON_ParseWithOpts</code>解析json对象</li>
</ul>
<pre><code class="language-cpp">	char* end = NULL;
	cJSON* cj_ParseWithOpts = cJSON_ParseWithOpts(&quot;{\&quot;name\&quot;: \&quot;Lee\&quot;} }&quot;, &amp;end, 1);
	if (cj_ParseWithOpts) {
		printf(&quot;%s\n\n&quot;, cJSON_Print(cj_ParseWithOpts));
	}
	else {
		printf(&quot;[%s]\n\n&quot;, end);
	}
</code></pre>
<h1 id="数组倒删除">数组倒删除</h1>
<pre><code class="language-cpp">	cJSON* adArr = NULL;  //欲删除的数组
	int arrCount = cJSON_GetArraySize(adArr);
	if (arrCount &gt; 0)
	{
		for (int j = arrCount - 1; j &gt;= 0; j--)
		{
			cJSON_DeleteItemFromArray(adArr, j);  //删除json数组对象的第j个节点
		}
	}
</code></pre>
<h1 id="对象替换">对象替换</h1>
<pre><code class="language-cpp"> cJSON* itemObj = NULL;  

   //文本替换
   cJSON_ReplaceItemInObject(itemObj, &quot;username&quot;, cJSON_CreateString(&quot;tom&quot;));

   //数组清空
   cJSON_ReplaceItemInObject(itemObj, &quot;userlist&quot;, cJSON_CreateArray());
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[uin-app]]></title>
        <id>https://blog.myxy.net/uin-app/</id>
        <link href="https://blog.myxy.net/uin-app/">
        </link>
        <updated>2020-07-25T03:06:36.000Z</updated>
        <content type="html"><![CDATA[<h1 id="目录结构">目录结构</h1>
<p><code>components</code>  自定义组件目录<br>
<code>pages</code> 页面存放目录<br>
<code>static</code> 静态文件资源目录<br>
<code>unpackage</code> 编译后的文件存放目录<br>
<code>App.vue</code>    app.js <a href="https://uniapp.dcloud.io/collocation/App">查看文档</a><br>
<code>main.js</code>  应用入口(  引用全局组件 ) <a href="https://uniapp.dcloud.io/collocation/main">查看文档</a><br>
<code>manifest,json</code>  项目配置  <a href="https://uniapp.dcloud.io/collocation/manifest">查看文档</a><br>
<code>page.json</code> 页面配置 <a href="https://uniapp.dcloud.io/collocation/pages">查看文档</a><br>
<code>package.json</code>  <a href="https://uniapp.dcloud.io/collocation/package">查看文档</a><br>
<code>vue.config.js</code> 是一个可选的配置文件  <a href="https://uniapp.dcloud.io/collocation/vue-config">查看文档</a><br>
<code>uni.scss</code>  <a href="https://uniapp.dcloud.io/collocation/uni-scss">查看文档</a></p>
<p><code>utils</code> 自定义 - 公用的工具类<br>
<code>common</code>  自定义 - 公用的文件</p>
<table>
<thead>
<tr>
<th>符号</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@</td>
<td style="text-align:center">项目根目录</td>
</tr>
<tr>
<td>vh</td>
<td style="text-align:center">屏幕高度</td>
</tr>
<tr>
<td>vw</td>
<td style="text-align:center">屏幕宽度</td>
</tr>
<tr>
<td>px</td>
<td style="text-align:center">固定</td>
</tr>
<tr>
<td>rpx</td>
<td style="text-align:center">根据屏幕宽度750动态调整</td>
</tr>
<tr>
<td>@import './index.css'</td>
<td style="text-align:center">引入外部CSS文件</td>
</tr>
</tbody>
</table>
<p>尺寸单位 :  px  rpx rem</p>
<h1 id="模板语法与数据绑定">模板语法与数据绑定</h1>
<p><view class="content" v-bing:class="className" v-on:click="open"></view><br>
&lt;view class=&quot;content&quot; :class=&quot;className&quot; @click=&quot;open&quot;&gt;</view></p>
<table>
<thead>
<tr>
<th>全写</th>
<th style="text-align:center">简写</th>
</tr>
</thead>
<tbody>
<tr>
<td>v-bing</td>
<td style="text-align:center">:</td>
</tr>
<tr>
<td>v-on</td>
<td style="text-align:center">@</td>
</tr>
</tbody>
</table>
<h1 id="条件判断">条件判断</h1>
<pre><code>&lt;view v-if=&quot;show==='1'&quot;&gt; 1 &lt;/view&gt;  如果表达式返回真值为true,那么正常渲染内容
&lt;view v-else-if=&quot;show==='2'&quot;&gt; 2 &lt;/view&gt;  如果表达式返回真值为true,那么正常渲染内容
&lt;view v-else&gt; 3 &lt;/view&gt;
</code></pre>
<h1 id="列表渲染">列表渲染</h1>
<p>item : 被迭代的数组元素的别名<br>
index : 下标别名</p>
<pre><code>&lt;view v-for=&quot;(item,index) in arr&quot;&gt; {{ (index+1) + '---' + item }} &lt;/view&gt;
&lt;view v-for=&quot;(item,value) in obj&quot;&gt; {{ value + '---' + item }} &lt;/view&gt;
</code></pre>
<h1 id="基础组件">基础组件</h1>
<view> 
    <view></view>     试图容器 .
    <scroll-view></scroll-view>   可滚动视图区域    
    <button>vue</button>  按钮
    <input value="1" />     输入框
</view>
<h1 id="自定义组件">自定义组件</h1>
<h1 id="api">API</h1>
<p><a href="https://uniapp.dcloud.io/api/README">API</a></p>
<h1 id="条件编译">条件编译</h1>
<p><a href="https://uniapp.dcloud.io/platform">条件编译</a></p>
<h1 id="生命周期">生命周期</h1>
<p><a href="https://uniapp.dcloud.io/collocation/frame/lifecycle?id=%e5%ba%94%e7%94%a8%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f">应用生命周期</a><br>
<a href="https://uniapp.dcloud.io/collocation/frame/lifecycle?id=%e9%a1%b5%e9%9d%a2%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f">页面生命周期</a><br>
<a href="https://uniapp.dcloud.io/collocation/frame/lifecycle?id=%e7%bb%84%e4%bb%b6%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f">组件生命周期</a></p>
<p>uin.navigateTo()  //打开新页面. 返回键可返回到当前页面  只能打开非 tabBar 页面。<br>
uin.redirectTo()   //关闭当前页面,打开新页面,会触发页面销毁事件.   只能打开非 tabBar 页面。</p>
<p>uin.switchTab() 只能打开 tabBar 页面。<br>
uin.reLaunch() 可以打开任意页面。</p>
<h1 id="scss">SCSS</h1>
<p>.content{<br>
&amp;.box{}    <code>&amp;</code>表示父级<br>
}</p>
<h1 id="unicloule">uniCloule</h1>
<p><a href="https://uniapp.dcloud.io/uniCloud/README">查看文档</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GraceUI]]></title>
        <id>https://blog.myxy.net/graceui/</id>
        <link href="https://blog.myxy.net/graceui/">
        </link>
        <updated>2020-07-14T12:16:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="组件插槽">组件插槽</h2>
<pre><code>&lt;slot name=&quot;gHeader&quot;&gt;&lt;/slot&gt; 头部导航内容
&lt;slot name=&quot;gBody&quot;&gt;&lt;/slot&gt; 页面主体内容
&lt;slot name=&quot;gFooter&quot;&gt;&lt;/slot&gt; 页面底部导航内容
&lt;slot name=&quot;gRTArea&quot;&gt;&lt;/slot&gt; 页面悬浮挂件内容
</code></pre>
<h3 id="uni-app-开发时-app-端必须的设置manifastjson">uni-app 开发时 APP 端必须的设置（manifast.json）</h3>
<pre><code>/* 5+App特有相关 */
&quot;app-plus&quot;: {
    &quot;nvueCompiler&quot;:&quot;uni-app&quot;,
    &quot;safearea&quot;: {
        &quot;background&quot;: &quot;#FFFFFF&quot;,  
        &quot;bottom&quot;: {  
            &quot;offset&quot;: &quot;auto&quot;  
        }  
    },
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JSON_API]]></title>
        <id>https://blog.myxy.net/json_api/</id>
        <link href="https://blog.myxy.net/json_api/">
        </link>
        <updated>2020-07-11T15:18:46.000Z</updated>
        <content type="html"><![CDATA[<h1 id="获取ip地址">获取IP地址:</h1>
<pre><code>http://mam.netease.com/api/config/getClientIp
http://sdk.open.phone.igexin.com/api/addr.htm
http://vv6.video.qq.com/checktime?otype=json&amp;guid=123&amp;randnum=0123
http://pv.sohu.com/cityjson
http://ip.360.cn/IPShare/info

</code></pre>
<h1 id="时间戳获取">时间戳获取</h1>
<pre><code>http://api.m.taobao.com/rest/api3.do?api=mtop.common.getTimestamp
http://quan.suning.com/getSysTime.do
http://api.pinduoduo.com/api/server/_stm
https://a.jd.com//ajax/queryServerData.html
https://mbuy.vmall.com/getSkuRushbuyInfo.json
https://m.poizon.com/client/cold
https://tptm.hd.mi.com/gettimestamp
http://vv6.video.qq.com/checktime?otype=json&amp;guid=123&amp;randnum=0123

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iconfont 批量把图标加入购物车的方法]]></title>
        <id>https://blog.myxy.net/iconfont-pi-liang-ba-tu-biao-jia-ru-gou-wu-che-de-fang-fa/</id>
        <link href="https://blog.myxy.net/iconfont-pi-liang-ba-tu-biao-jia-ru-gou-wu-che-de-fang-fa/">
        </link>
        <updated>2020-07-11T14:26:29.000Z</updated>
        <content type="html"><![CDATA[<p>在浏览器中按 f12 打开【开发人员工具】，找到【console(控制台)】，输入以下代码，再按回车，稍等片刻即可把全部图标加入购物车</p>
<pre><code>function str_repeat(str, num){ return new Array( num + 1 ).join( str ); }var ll = document.getElementsByClassName('icon-gouwuche1'); for (var i=0; i&lt;ll.length;i++){ll[i].click();console.clear();console.warn(&quot;Iconfont自动加购物车脚本V2\n正在下载第&quot;+(i+1)+&quot;个图标\n共计&quot;+ll.length+&quot;个图标(&quot;+(Math.floor((i+1)*100/ll.length))+&quot;%)&quot;);console.log(str_repeat(&quot;|&quot;,(Math.floor((i+1)*34/ll.length))));}console.clear();console.log(&quot;所有图标已加入购物车成功!&quot;);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mysql ]]></title>
        <id>https://blog.myxy.net/mysql/</id>
        <link href="https://blog.myxy.net/mysql/">
        </link>
        <updated>2020-07-08T13:56:54.000Z</updated>
        <content type="html"><![CDATA[<p>#分页查询:</p>
<h2 id="1根据自增且连续主键排序的分页查询">1,根据自增且连续主键排序的分页查询</h2>
<p>一般: select * from t1 limit 99000,2;<br>
优化: select * from t1 where id &gt;99000 limit 2;</p>
<h2 id="2查询根据非主键字段排序的分页查询">2,查询根据非主键字段排序的分页查询</h2>
<p>一般:  select * from t1 order by a limit 99000,2;<br>
优化: select * from t1 as a join( select id from t1 limit 99000,2) as b on a.id=b.id</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue]]></title>
        <id>https://blog.myxy.net/vue/</id>
        <link href="https://blog.myxy.net/vue/">
        </link>
        <updated>2020-07-07T15:26:02.000Z</updated>
        <content type="html"><![CDATA[<p>#vui2</p>
<h3 id="创建项目">创建项目:</h3>
<p>基于webpack模板创建项目的语法是:<code>vue init webpack test1</code></p>
<blockquote>
<p>配置项目</p>
</blockquote>
<h4 id="如果创建失败则重新安装一次vue-cli">如果创建失败则重新安装一次vue-cli:</h4>
<p><code>cnpm install -gd vue-cli</code></p>
<p>#vue3<br>
###创建项目:<br>
vue create test3</p>
<p>##全局注册 axios<br>
在main.js 内<br>
import axios form 'axios'</p>
<p>Vue.prototype.$http=axios</p>
<h2 id="tttttttttt">tttttttttt</h2>
<p>观察变量变化<br>
vm.$watch('a',function(newval,oldval){</p>
<p>})<br>
输出HTML元素: v-html</p>
<p><code>computed</code> 是属性调用,<br>
带缓存功能<br>
调用方式: 直接名称</p>
<p><code>methods</code> 是函数调用<br>
调用方式:名字后面加括号</p>
<h1 id="vue-小技巧">VUE 小技巧</h1>
<h2 id="生命周期-hook">生命周期 @hook</h2>
<blockquote>
<p>有时在一些业务场景下，需要在父组件监听子组件挂载后mounted, 做一些逻辑处理，一般我们会在每个子组件中去this.$emit事件，我们也可以使用 @hook 来方便的做这个事情。</p>
</blockquote>
<pre><code>// 子组件
export default {
    mounted() {
        this.$emit('listenMounted')
    }
}

// 父组件
&lt;template&gt;
    &lt;div&gt;
        &lt;List @listenMounted=&quot;listenMounted&quot; /&gt;
    &lt;/div&gt;
&lt;/template&gt;


其实还有一种简洁的方法，使用 @hook 即可监听组件生命周期，组件内无需做任何改变。同样的， created 、 updated 等也可以使用此方法。
&lt;template&gt;
    &lt;Child @hook:mounted=&quot;childMounted&quot; /&gt;
&lt;/template&gt;
</code></pre>
<h2 id="动态注册-hook">动态注册 hook</h2>
<p><em>常见业务场景：</em></p>
<ul>
<li>使用定时器，生命周期内清除定时器</li>
<li>事件监听移除</li>
<li>摧毁实例化的对象<br>
一般我们会这样做</li>
</ul>
<pre><code>export default {
  created() {
    addEventListener(&quot;click&quot;, Function, false);
  },

  beforeDestroy() {
    removeEventListener(&quot;click&quot;, Function, false);
  },
};
</code></pre>
<p>避免可能遗忘，我们可以这样</p>
<pre><code>export default {
  mounted() {
    const picker = new Pickaday({
      // ...
    });

    this.$once(&quot;hook:beforeDestroy&quot;, () =&gt; {
      picker.destroy();
    })
  }
};
</code></pre>
<h2 id="避免进行数据劫持">避免进行数据劫持</h2>
<p><code>Vue</code> 中 <code>data</code> 的数据默认会 <code>Object.defineProperty</code> 对数据进行劫持, 以实现双向数据绑定，若是将大量的和渲染无关的数据直接放置在data中，将会浪费双向数据绑定时所消耗的性能，将这些和渲染无关的数据进行抽离并配合<code>Object.freeze</code>进行处理。</p>
<pre><code>export default {
  data() {
    return {
      tableList: [],
    };
  },

  created() {
    const tableList = [
      { name: &quot;张四&quot;, gender: &quot;male&quot;, age: &quot;26&quot; },
      { name: &quot;李三&quot;, gender: &quot;fmale&quot;, age: &quot;24&quot; },
    ];
    this.tableList = Object.freeze(tableList);
  },
};
</code></pre>
<h2 id="批量数据更新">批量数据更新</h2>
<p>一次性更新多个数据时，可使用如下方法一起赋值。</p>
<pre><code>const {name, age, gender} = resData
this = Object.assign(this, {name, age, gender})
</code></pre>
<h2 id="watch-监听多个变量">watch 监听多个变量</h2>
<p>watch本身无法监听多个变量。但我们可以将需要监听的多个变量通过计算属性返回对象，再监听这个对象来实现监听多个变量</p>
<pre><code>export default {
    data() {
        return {
            msg1: 'apple',
            msg2: 'banana'
        }
    },
    compouted: {
        msgObj() {
            const { msg1, msg2 } = this
            return {
                msg1,
                msg2
            }
        }
    },
    watch: {
        msgObj: {
            handler(newVal, oldVal) {
                if (newVal.msg1 != oldVal.msg1) {
                    console.log('msg1 is change')
                }
                if (newVal.msg2 != oldVal.msg2) {
                    console.log('msg2 is change')
                }
            },
            deep: true
        }
    }
}
</code></pre>
]]></content>
    </entry>
</feed>