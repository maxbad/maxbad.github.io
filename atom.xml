<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.myxy.net</id>
    <title>Maxbad`Blog</title>
    <updated>2021-03-08T13:43:14.923Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.myxy.net"/>
    <link rel="self" href="https://blog.myxy.net/atom.xml"/>
    <subtitle>记录一些东西</subtitle>
    <logo>https://blog.myxy.net/images/avatar.png</logo>
    <icon>https://blog.myxy.net/favicon.ico</icon>
    <rights>All rights reserved 2021, Maxbad`Blog</rights>
    <entry>
        <title type="html"><![CDATA[C++ 类的关键字]]></title>
        <id>https://blog.myxy.net/c-lei-de-guan-jian-zi/</id>
        <link href="https://blog.myxy.net/c-lei-de-guan-jian-zi/">
        </link>
        <updated>2021-03-08T07:39:32.000Z</updated>
        <content type="html"><![CDATA[<h1 id="final">final</h1>
<ul>
<li>禁用继承</li>
</ul>
<blockquote>
<p>C++11中允许将类标记为final，方法时直接在类名称后面使用关键字final，如此，意味着继承该类会导致编译错误。</p>
</blockquote>
<pre><code class="language-cpp">class Super final
{
    // 
};

</code></pre>
<ul>
<li>禁用重写
<blockquote>
<p>C++中还允许将方法标记为fianal，这意味着无法再子类中重写该方法。这时final关键字至于方法参数列表后面，如下</p>
</blockquote>
</li>
</ul>
<pre><code class="language-cpp">class Super
{
  public:
    Supe();
    virtual void SomeMethod() final;
};

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[限定对象只能在堆上创建]]></title>
        <id>https://blog.myxy.net/xian-ding-dui-xiang-zhi-neng-zai-dui-shang-chuang-jian/</id>
        <link href="https://blog.myxy.net/xian-ding-dui-xiang-zhi-neng-zai-dui-shang-chuang-jian/">
        </link>
        <updated>2021-03-08T06:46:28.000Z</updated>
        <content type="html"><![CDATA[<p><strong>限定对象在堆上创建的需求</strong></p>
<blockquote>
<blockquote>
<p>C++对象的一些使用场景其实已经有这种隐喻了，比如一个对象从std::enable_shared_from_this派生，当我们调用this-&gt;shared_from_this()的前提条件是这个对象已经被创建为shared_ptr，如果是一个栈对象去调用shared_from_this时会crash，所以使用派生于std::enable_shared_from_this的对象时，限定它只能在堆上创建可以保证代码的安全性。</p>
</blockquote>
</blockquote>
<pre><code class="language-cpp">struct dummy{
    class token{
    private:
        token(){}
        friend dummy;
    };

    static std::shared_ptr&lt;dummy&gt; create(){
      return std::make_shared&lt;dummy&gt;(token{});
    }

    dummy(token) : dummy() {
    }

private:
    dummy(){}
};

int main() {
  dummy d{}; //compile error
  dummy d(token{}); //compile error
  auto ptr = dummy::create(); //ok
}
</code></pre>
<p>这个代码借助了一个私有内部类token来避免在栈上创建dummy对象，因为外面无法访问这个token，只有它的友元类dummy才能访问token。另外一个问题是dummy的构造函数还是私有的，为什么这次改造之后可以用std::make_shared了？因为这里先通过public的dummy(token)去构造dummy对象的，然后dummy通过代理构造函数dummy()去真正构造一个dummy对象。</p>
<p>这个token在这里有两个作用，一个是用来避免在栈上构造dummy对象，一个是提供一个public的构造函数给std::make_shared使用。对于创建一个std::unique_ptr对象来说思路也是一样的，读者可以自行实现。至此，我们比较完美地实现了限定对象只能在堆上创建的目标。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程安全-map]]></title>
        <id>https://blog.myxy.net/xian-cheng-an-quan-map/</id>
        <link href="https://blog.myxy.net/xian-cheng-an-quan-map/">
        </link>
        <updated>2021-03-06T03:11:58.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-cpp">#pragma once
#include &lt;map&gt;
#include &lt;mutex&gt;

template&lt;typename Key, typename Val&gt;
class SafeMap
{
public:
	typedef typename std::map&lt;Key, Val&gt;::iterator this_iterator;
	typedef typename std::map&lt;Key, Val&gt;::const_iterator this_const_iterator;
	Val&amp; operator [](const Key&amp; key)
	{
		std::lock_guard&lt;std::mutex&gt; lk(mtx_);
		return dataMap_[key];
	}

	int erase(const Key&amp; key)
	{
		std::lock_guard&lt;std::mutex&gt; lk(mtx_);
		return dataMap_.erase(key);
	}

	this_iterator find(const Key&amp; key)
	{
		std::lock_guard&lt;std::mutex&gt; lk(mtx_);
		return dataMap_.find(key);
	}

	this_const_iterator find(const Key&amp; key) const
	{
		std::lock_guard&lt;std::mutex&gt; lk(mtx_);
		return dataMap_.find(key);
	}

	this_iterator end()
	{
		return dataMap_.end();
	}

	this_const_iterator end() const
	{
		return dataMap_.end();
	}

private:
	std::map&lt;Key, Val&gt; dataMap_;
	std::mutex mtx_;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程安全-队列]]></title>
        <id>https://blog.myxy.net/xian-cheng-an-quan-dui-lie/</id>
        <link href="https://blog.myxy.net/xian-cheng-an-quan-dui-lie/">
        </link>
        <updated>2021-03-06T03:11:00.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-cpp">#pragma once
#include &lt;iostream&gt;
#include &lt;condition_variable&gt;
#include &lt;mutex&gt;
#include &lt;queue&gt;
#include &lt;memory&gt;

/*
*
 * 线程安全队列
 * T为队列元素类型
 * 因为有std::mutex和std::condition_variable类成员,所以此类不支持复制构造函数也不支持赋值操作符(=)
 *
 * 来源: https://blog.csdn.net/u011726005/article/details/82670730
 */
template&lt;class T, class Container = std::queue&lt;T&gt;&gt;
class ThreadSafeQueue {
public:
	ThreadSafeQueue() = default;

	// 将元素加入队列
	template &lt;class Element&gt;
	void Push(Element&amp;&amp; element) {
		std::lock_guard&lt;std::mutex&gt; lock(mutex_);
		queue_.push(std::forward&lt;Element&gt;(element));
		not_empty_cv_.notify_one();
	}

	// 从队列中弹出一个元素,如果队列为空就阻塞
	void WaitAndPop(T&amp; t) {
		std::unique_lock&lt;std::mutex&gt; lock(mutex_);
		not_empty_cv_.wait(lock, [this]() {
			return !queue_.empty();
			});

		t = std::move(queue_.front());
		queue_.pop()
	}

	// 从队列中弹出一个元素,如果队列为空就阻塞
	std::shared_ptr&lt;T&gt; WaitAndPop() {
		std::unique_lock&lt;std::mutex&gt; lock(mutex_);
		not_empty_cv_.wait(lock, [this]() {
			return !queue_.empty();
			});

		std::shared_ptr&lt;T&gt; t_ptr = std::make_shared&lt;T&gt;(queue_.front());
		queue_.pop();

		return t_ptr;
	}

	// 从队列中弹出一个元素,如果队列为空返回false
	bool TryPop(T&amp; t) {
		std::lock_guard&lt;std::mutex&gt; lock(mutex_);
		if (queue_.empty()) {
			return false;
		}

		t = std::move(queue_.front());
		queue_.pop();
		return true;
	}

	// 从队列中弹出一个元素,如果队列为空返回空指针
	std::shared_ptr&lt;T&gt; TryPop() {
		std::lock_guard&lt;std::mutex&gt; lock(mutex_);
		if (queue_.empty()) {
			return std::shared_ptr&lt;T&gt;();
		}

		t = std::move(queue_.front());
		std::shared_ptr&lt;T&gt; t_ptr = std::make_shared&lt;T&gt;(queue_.front());
		queue_.pop();

		return t_ptr;
	}

	// 返回队列是否为空
	bool IsEmpty() const {
		std::lock_guard&lt;std::mutex&gt; lock(mutex_);
		return queue_.empty();
	}

	// 返回队列中元素数个
	size_t size() {
		std::lock_guard&lt;std::mutex&gt; lock(mutex_);
		return queue_.size();
	}

private:
	ThreadSafeQueue(const ThreadSafeQueue&amp;) = delete;
	ThreadSafeQueue&amp; operator=(const ThreadSafeQueue&amp;) = delete;
	ThreadSafeQueue(ThreadSafeQueue&amp;&amp;) = delete;
	ThreadSafeQueue&amp; operator=(ThreadSafeQueue&amp;&amp;) = delete;

private:
	Container queue_;

	std::condition_variable not_empty_cv_;
	mutable std::mutex mutex_;
};

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[番茄的一些记录]]></title>
        <id>https://blog.myxy.net/fan-qie-de-yi-xie-ji-lu/</id>
        <link href="https://blog.myxy.net/fan-qie-de-yi-xie-ji-lu/">
        </link>
        <updated>2021-01-25T07:40:17.000Z</updated>
        <content type="html"><![CDATA[<h1 id="快捷键">快捷键</h1>
<table>
<thead>
<tr>
<th>快捷键</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>alt+o</td>
<td style="text-align:left">换 .h 和 .cpp</td>
</tr>
<tr>
<td>alt+shift+o</td>
<td style="text-align:left">全局找文件</td>
</tr>
<tr>
<td>alt+shift+s</td>
<td style="text-align:left">全局找符号</td>
</tr>
<tr>
<td>alt+shift+f</td>
<td style="text-align:left">全局找当前光标符号</td>
</tr>
<tr>
<td>f8</td>
<td style="text-align:left">ctrl+shift+f 之后 f8，查找下一个当前光标符号的引用，这个不是 vax 的功能，是 vs 自带的</td>
</tr>
<tr>
<td>alt+g</td>
<td style="text-align:left">找定义</td>
</tr>
<tr>
<td>alt+shift+g</td>
<td style="text-align:left">找继承关系</td>
</tr>
<tr>
<td>alt+shift+q</td>
<td style="text-align:left">添加 include</td>
</tr>
<tr>
<td>alt+shift+r</td>
<td style="text-align:left">重构</td>
</tr>
<tr>
<td>ctrl+k,ctrl+s</td>
<td style="text-align:left">包裹代码</td>
</tr>
<tr>
<td>alt+m</td>
<td style="text-align:left">当前文件方法</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[std::string 构造函数]]></title>
        <id>https://blog.myxy.net/stdstring-gou-zao-han-shu/</id>
        <link href="https://blog.myxy.net/stdstring-gou-zao-han-shu/">
        </link>
        <updated>2021-01-11T03:28:26.000Z</updated>
        <content type="html"><![CDATA[<p>C++中的String的常用函数用法总结: <a href="https://blog.csdn.net/qq_37941471/article/details/82107077">https://blog.csdn.net/qq_37941471/article/details/82107077</a></p>
<ul>
<li>
<p>1,将构造的对象初始化为s的前n个字符，s不够n个时将相邻的内存单元的内容当作s的一部分继续复制:<br>
<code>string(const char *s, size_type n, const Allocator &amp;a = Allocator());</code></p>
<pre><code class="language-cpp">  std::string testStr(&quot;Telephone home.&quot;, 4);
  OutputDebugStringA(testStr.c_str());
  // 输出:Tele
</code></pre>
</li>
<li>
<p>2,将构造的对象初始化为s的后n个字符，也就是从s指向的内存的第n个字节开始复制：<br>
<code>string(const string &amp;str, size_type pos,size_type n = npos, const Allocator &amp;a = Allocator());</code></p>
</li>
</ul>
<pre><code class="language-cpp">    std::string text(&quot;Telephone home.&quot;);
    std::string testStr(text, 4);
    OutputDebugStringA(testStr.c_str());
    // 输出:phone home.
</code></pre>
<ul>
<li>3,创建一个n个字符的string对象：<br>
<code>string(size_type n, char c, const Allocator &amp;a = Allocator())</code><pre><code class="language-cpp">  std::string testStr(10, 'a');
  OutputDebugStringA(testStr.c_str());
  // 输出:aaaaaaaaaa
</code></pre>
</li>
</ul>
<p>其他文档:<a href="http://c.biancheng.net/view/1443.html">http://c.biancheng.net/view/1443.html</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue项目打包时，去掉console.log输出]]></title>
        <id>https://blog.myxy.net/vue-xiang-mu-da-bao-shi-qu-diao-consolelog-shu-chu/</id>
        <link href="https://blog.myxy.net/vue-xiang-mu-da-bao-shi-qu-diao-consolelog-shu-chu/">
        </link>
        <updated>2021-01-09T06:50:20.000Z</updated>
        <content type="html"><![CDATA[<p>安装插件：<code>npm install babel-plugin-transform-remove-console --save-dev</code></p>
<p>在<code>babel.config.js</code>文件的<code>plugins</code>中添加<code>transform-remove-console</code>，此时再build就不会有console警告了。</p>
<pre><code class="language-java">// 项目发布阶段需要用到的Babel插件
const prodPlugins = []
if (process.env.NODE_ENV === 'production') {
  prodPlugins.push('transform-remove-console')
}
module.exports = {
  presets: [
    '@vue/cli-plugin-babel/preset'
  ],
  plugins: [
    [
      'component',
      {
        libraryName: 'element-ui',
        styleLibraryName: 'theme-chalk'
      }
    ],
    // 发布产品时候的插件数组
    ...prodPlugins
  ]
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[proxy配置]]></title>
        <id>https://blog.myxy.net/proxy-pei-zhi/</id>
        <link href="https://blog.myxy.net/proxy-pei-zhi/">
        </link>
        <updated>2020-12-26T11:29:57.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-js">const address = require('address');
devServer: {
        publicPath: Setting.publicPath,
        host: address.ip(),
        noInfo: false,
        progress: true // 将运行进度输出到控制台。
         openPage: 'admin/version', // 默认打开页
         proxy: {
            '/v1': {
                target: 'http://' + address.ip() + ':8098',
                changeOrigin: true, // 是否跨域
                onProxyReq: function (proxyReq, req, res, options) {
                    console.log('发送', req.method, req.url);

                    if (req.body) {
                        console.log('发送 Body', req.body);
                    }
                },
                onProxyRes: function (proxyRes, req, res) {
                    console.log('收到', req.method, req.url);

                    let body = [];
                    proxyRes.on('data', function (chunk) {
                        body.push(chunk);
                    });
                    proxyRes.on('end', function () {
                        body = Buffer.concat(body).toString();
                        console.log('收到 Body', body);
                        // res.end('my response to cli');
                    });
                },
                onError: function (err, req, res) {
                    console.log('代理错误消息', err);
                },
                logLevel: 'debug'
            }
        } 
    },
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[prettier 配置]]></title>
        <id>https://blog.myxy.net/prettier-pei-zhi/</id>
        <link href="https://blog.myxy.net/prettier-pei-zhi/">
        </link>
        <updated>2020-12-22T03:42:30.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode">https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode</a></p>
<blockquote>
<p>自动格式化整理代码，vscode 需要去插件商店下载【Prettier - Code formatter 】这个插件</p>
</blockquote>
<pre><code class="language-json">{
  &quot;[vue]&quot;: {
    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;
  },
  &quot;editor.quickSuggestions&quot;: {
    &quot;strings&quot;: true
  },
  &quot;editor.tabSize&quot;: 2,
  &quot;editor.detectIndentation&quot;: false,
  &quot;emmet.triggerExpansionOnTab&quot;: true,
  &quot;editor.formatOnSave&quot;: true,
  &quot;javascript.format.enable&quot;: true,
  &quot;[json]&quot;: {
    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;
  },
  &quot;explorer.confirmDelete&quot;: false,
  &quot;javascript.updateImportsOnFileMove.enabled&quot;: &quot;always&quot;,
  &quot;typescript.updateImportsOnFileMove.enabled&quot;: &quot;always&quot;,
  &quot;files.exclude&quot;: {
    &quot;**/.idea&quot;: true
  },
  &quot;editor.codeActionsOnSave&quot;: {
    &quot;source.fixAll.stylelint&quot;: true,
    &quot;source.fixAll.eslint&quot;: true
  },
  &quot;[javascript]&quot;: {
    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;
  },
  &quot;[scss]&quot;: {
    &quot;editor.defaultFormatter&quot;: &quot;HookyQR.beautify&quot;
  },
  &quot;[jsonc]&quot;: {
    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;
  },
  &quot;[html]&quot;: {
    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;
  },
  &quot;editor.suggest.snippetsPreventQuickSuggestions&quot;: false,
  &quot;prettier.htmlWhitespaceSensitivity&quot;: &quot;ignore&quot;,
  &quot;prettier.vueIndentScriptAndStyle&quot;: true,
  &quot;vetur.format.defaultFormatter.html&quot;: &quot;prettier&quot;,
  &quot;files.autoSave&quot;: &quot;onFocusChange&quot;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ for遍历循环表达示 auto, auto&, auto&&]]></title>
        <id>https://blog.myxy.net/c-for-bian-li-xun-huan-biao-da-shi-auto-autoand-autoand/</id>
        <link href="https://blog.myxy.net/c-for-bian-li-xun-huan-biao-da-shi-auto-autoand-autoand/">
        </link>
        <updated>2020-12-18T06:44:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="创建拷贝无法修改dataarr中的元素">创建拷贝，无法修改dataArr中的元素</h2>
<pre><code class="language-cpp">for(auto x : dataArr)
</code></pre>
<h2 id="参考引用可以修改dataarr中的元素但一般用第二种">参考引用，可以修改dataArr中的元素，但一般用第二种</h2>
<pre><code class="language-cpp">for(auto&amp; iter : dataArr)
for(auto&amp;&amp; iter : dataArr)
</code></pre>
<h2 id="只读引用不能修改dataarr中的元素">只读引用，不能修改dataArr中的元素</h2>
<pre><code class="language-cpp">for(const auto&amp; iter : dataArr)
</code></pre>
]]></content>
    </entry>
</feed>