<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.myxy.net</id>
    <title>Maxbad`Blog</title>
    <updated>2020-09-07T08:26:23.032Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.myxy.net"/>
    <link rel="self" href="https://blog.myxy.net/atom.xml"/>
    <subtitle>记录一些东西</subtitle>
    <logo>https://blog.myxy.net/images/avatar.png</logo>
    <icon>https://blog.myxy.net/favicon.ico</icon>
    <rights>All rights reserved 2020, Maxbad`Blog</rights>
    <entry>
        <title type="html"><![CDATA[Promise]]></title>
        <id>https://blog.myxy.net/promise/</id>
        <link href="https://blog.myxy.net/promise/">
        </link>
        <updated>2020-09-07T08:11:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="promise是什么">promise是什么？</h1>
<ul>
<li>主要用于异步计算</li>
<li>可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果</li>
<li>可以在对象之间传递和操作promise，帮助我们处理队列</li>
</ul>
<blockquote>
<p><em>同步</em>：假设你去了一家饭店，找个位置，叫来服务员，这个时候服务员对你说，对不起我是“同步”服务员，我要服务完这张桌子才能招呼你。那桌客人明明已经吃上了，你只是想要个菜单，这么小的动作，服务员却要你等到别人的一个大动作完成之后，才能再来招呼你，这个便是同步的问题：也就是“顺序交付的工作1234，必须按照1234的顺序完成”。<br>
<em>异步</em>：则是将耗时很长的A交付的工作交给系统之后，就去继续做B交付的工作，。等到系统完成了前面的工作之后，再通过回调或者事件，继续做A剩下的工作。<br>
AB工作的完成顺序，和交付他们的时间顺序无关，所以叫“异步”。</p>
</blockquote>
<p>promise详解</p>
<pre><code>new Promise(
  function (resolve, reject) {
    // 一段耗时的异步操作
    resolve('成功') // 数据处理完成
    // reject('失败') // 数据处理出错
  }
).then(
  (res) =&gt; {console.log(res)},  // 成功
  (err) =&gt; {console.log(err)} // 失败
)
</code></pre>
<p><code>resolve</code>作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</p>
<p><code>reject</code>作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p><em>promise</em>有三个状态：<br>
1、pending[待定]初始状态<br>
2、fulfilled[实现]操作成功<br>
3、rejected[被否决]操作失败<br>
当promise状态发生改变，就会触发then()里的响应函数处理后续步骤；<br>
promise状态一经改变，不会再变。</p>
<p>Promise对象的状态改变，只有两种可能：<br>
从pending变为fulfilled<br>
从pending变为rejected。<br>
这两种情况只要发生，状态就凝固了，不会再变了。</p>
<p>1.promise简单用法</p>
<pre><code>function2(){
    // 你的逻辑代码 
    return Promise.resolve(/* 这里是需要返回的数据*/)
}

function3(){
    // 你的逻辑代码 
    return Promise.resolve(/* 这里是需要返回的数据*/)
}

// 调用
function1(){
    this.function2().then(val =&gt; { 
        this.function3();
    });
}
</code></pre>
<p>2.promise高阶用法</p>
<pre><code>init1(){
return new Promise((resolve, reject) =&gt; {
    let data={
        dateStr:this.time
    };
    api.get('url', null).then( res =&gt; {
       //自己的操作
        resolve()
    }).catch(err =&gt; {
        reject()
    });
});
};
init2(){
return new Promise((resolve, reject) =&gt; {
    let data={
        dateStr:this.time
    };
    api.get('url', null).then( res =&gt; {
       //自己的操作
        resolve()
    }).catch(err =&gt; {
        reject()
    });
});
};


//调用
Promise.all([this.init1(),this.init2()]).then(() =&gt; {
    //两个都调成功以后执行的操作
//主要是loading问题
}).catch(err =&gt; {
    // 抛出错误信息
});
</code></pre>
<p>https://www.jianshu.com/p/1b63a13c2701<br>
https://blog.csdn.net/qq_34645412/article/details/81170576</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[lodash]]></title>
        <id>https://blog.myxy.net/lodash/</id>
        <link href="https://blog.myxy.net/lodash/">
        </link>
        <updated>2020-09-05T02:43:11.000Z</updated>
        <content type="html"><![CDATA[<p><em>文档</em><br>
<a href="https://www.lodashjs.com/">https://www.lodashjs.com/</a><br>
<a href="http://lodash.think2011.net/">http://lodash.think2011.net/</a><br>
<a href="https://www.html.cn/doc/lodash/">https://www.html.cn/doc/lodash/</a></p>
<h2 id="isarray">isArray</h2>
<p><code>_.isArray(value)</code></p>
<blockquote>
<p>检查 value 是否是 Array 类对象。</p>
</blockquote>
<h2 id="iselement">isElement</h2>
<p><code>_.isElement(value)</code></p>
<blockquote>
<p>检查 value 是否是可能是 DOM 元素</p>
</blockquote>
<h2 id="isequal">isEqual</h2>
<blockquote>
<p>执行深比较来决定两者的值是否相等</p>
</blockquote>
<pre><code>var object = { 'user': 'fred' };
var other = { 'user': 'fred' };

_.isEqual(object, other);
// =&gt; true

object === other;
// =&gt; false
</code></pre>
<h2 id="isinteger">isInteger</h2>
<blockquote>
<p>检查 value 是否是整数</p>
</blockquote>
<h2 id="ismatch">isMatch</h2>
<p><code>_.isMatch(object, source)</code></p>
<blockquote>
<p>执行一个深比较来确定object 是否包含有 source 的属性值。</p>
</blockquote>
<pre><code>var object = { 'user': 'fred', 'age': 40 };

_.isMatch(object, { 'age': 40 });
// =&gt; true

_.isMatch(object, { 'age': 36 });
// =&gt; false
</code></pre>
<h2 id="isnil">isNil</h2>
<p><code>_.isNil(value)</code></p>
<blockquote>
<p>检查 value 是否是 null 或者 undefined。</p>
</blockquote>
<h2 id="isplainobject">isPlainObject</h2>
<blockquote>
<p>检查 value 是否是普通对象。 也就是说该对象由 Object 构造函数创建或者 [[Prototype]] 为空。</p>
</blockquote>
<pre><code>function Foo() {
  this.a = 1;
}

_.isPlainObject(new Foo);
// =&gt; false

_.isPlainObject([1, 2, 3]);
// =&gt; false

_.isPlainObject({ 'x': 0, 'y': 0 });
// =&gt; true

_.isPlainObject(Object.create(null));
// =&gt; true
</code></pre>
<h2 id="isundefined">isUndefined</h2>
<h2 id="isnull">isNull</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iview 表单验证]]></title>
        <id>https://blog.myxy.net/iview-biao-dan-yan-zheng/</id>
        <link href="https://blog.myxy.net/iview-biao-dan-yan-zheng/">
        </link>
        <updated>2020-09-02T05:14:38.000Z</updated>
        <content type="html"><![CDATA[<p>Form 组件基于 <a href="https://github.com/yiminghe/async-validator">async-validator</a>实现的数据验证，给 Form 设置属性 rules，同时给需要验证的 FormItem 设置属性 prop 指向对应字段即可。</p>
<p>完整的验证规则请参照开源项目 async-validator。</p>
<p>验证方法也支持 Promise。</p>
<p>https://www.jianshu.com/p/627c42d6da79<br>
https://www.cnblogs.com/wozho/p/10955525.html<br>
https://www.jianshu.com/p/2105c48b45c7</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ES6]]></title>
        <id>https://blog.myxy.net/es6/</id>
        <link href="https://blog.myxy.net/es6/">
        </link>
        <updated>2020-08-28T03:10:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="对象字面量简写">对象字面量简写</h2>
<p><code>https://zhuanlan.zhihu.com/p/56215043</code></p>
<h2 id="模板字符串">模板字符串</h2>
<blockquote>
<p>模板字符串就是一种字符串的新的表现形式,模板字符串的出现，极大的改变传统字符串的拼接方法，减少代码出现错误的几率。提高开发效率</p>
</blockquote>
<ul>
<li>基本用法</li>
</ul>
<pre><code>let s1 = ` hello `
let s2 = ' hello '
</code></pre>
<ul>
<li>字符串和变量拼接</li>
</ul>
<pre><code>let s3 =&quot; a &quot; + s1 + &quot; b &quot; + s2;
let s4 = ` a ${s1} b ${s2}`;  
</code></pre>
<ul>
<li>字符串换行</li>
</ul>
<pre><code>var box =`&lt;div&gt;
            &lt;p&gt;
              &lt;span&gt;123&lt;/span&gt;
            &lt;/p&gt;
            &lt;p&gt;${a1}&lt;/p&gt;
         &lt;/div&gt;`;
</code></pre>
<h2 id="解构赋值">解构赋值</h2>
<blockquote>
<p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构</p>
</blockquote>
<ul>
<li>对象结构赋值</li>
</ul>
<pre><code>var obj ={ name:&quot;abc&quot;,age:18 };
    //用解构赋值的方式获取name、age

    let { name } = obj; //创建了一个变量name，值=obj.name
    console.log(name);  //&quot;abc&quot;

    let { age } =obj;
    console.log(age);  //18
</code></pre>
<ul>
<li>函数参数结构赋值</li>
</ul>
<pre><code>function f1(obj){
        console.log(obj.age);
        console.log(obj.height)
    }
    //等价于
    function f1({ age,height }){
        console.log(age);
        console.log(height)
    }

    f1({age:5,height:180})
</code></pre>
<h2 id="rest参数">rest参数</h2>
<blockquote>
<p>ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。es6箭头函数内部不能使用arguments，为了弥补这个问题，rest参数应孕而生</p>
</blockquote>
<pre><code>function fn(){
        //arguments是函数内部的一个局部变量，
        //arguments.length表示函数的实参的个数
        console.log(arguments.length);

        for(var i =0 ; i&lt;arguments.length; i++){
            console.log(arguments[i]);
        }

    }
    fn(1,3,5)       //3
    // fn(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;) //5

    //...args就是rest参数
    //--&gt;产生了一个变量，这个变量是一个数组，数组里面包含了这个函数调用时传递的所有实参
    function q(...args){
        //验证args是不是数组？
        console.log(args instanceof Array);//true
        console.log(Object.prototype.toString.call(args));//&quot;[object Array]&quot;
        console.log(Array.isArray(args));   //true es5中的新方法

        console.log(args);
    }
    q(1,3,5);
    q(2,3,4,5,6,7,8);
</code></pre>
<h2 id="箭头函数">箭头函数</h2>
<blockquote>
<p>ES6 允许使用“箭头”（=&gt;）定义函数。<br>
<em>箭头函数和普通匿名函数有哪些不同？</em><br>
1.函数体内的this对象，就是定义所在的对象，而不是使用所在的对象<br>
2.不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误<br>
3.不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。<br>
4.不可以使用yield命令，因此箭头函数不能用作 Generator 函数。<br>
5.generator函数现在经常用async替代</p>
</blockquote>
<ul>
<li>用于替换匿名函数</li>
</ul>
<pre><code>基本用法

//匿名函数
div.onclick=function(){
    console.log(&quot;你好&quot;)
}
//箭头函数
div.onclick=()=&gt;{
    console.log(&quot;你好&quot;)
}
</code></pre>
<ul>
<li>有一个参数的箭头函数</li>
</ul>
<pre><code>var fn=(a)=&gt;{
        console.log(&quot;abc&quot;);
    }
    //等价于：
    var fn=a=&gt;{
        console.log(&quot;abc&quot;);
    }

</code></pre>
<ul>
<li>有2个及更多参数的箭头函数</li>
</ul>
<pre><code> var f=(a,b,c)=&gt;{
        console.log(&quot;abc&quot;)
    }
</code></pre>
<pre><code>var p={
        age:18,
        //es6中对象方法的箭头函数表示形式
        run:()=&gt;{
            setTimeout(()=&gt;{
                //this:window
                console.log(this);//this是window
            },100)
        },
        travel:function(){
            //this:p
            setTimeout(()=&gt;{
                console.log(this);//this是p
            },100)
        },
        //推荐使用的方式☆☆☆：es6中对象方法的简写形式
        say(){
            console.log(&quot;say方法中的this：&quot;,this);
            setTimeout(()=&gt;{
                console.log(&quot;say内部的延迟函数：&quot;,this);//this是p
            },100)
        },
    }

    p.run();

    p.travel();

    p.say();
</code></pre>
<h2 id="let">let</h2>
<blockquote>
<p>用来声明变量。它的用法类似于var,但是所声明的变量，只在let命令所在的代码块内有效。</p>
</blockquote>
<pre><code>for (let i = 0; i &lt; 10; i++) {
 
 }
console.log(i) //ReferenceError: i is not defined&lt;br&gt;&lt;br&gt;for(var i=0;i&lt;10;i++){&lt;br&gt;&lt;br&gt;}&lt;br&gt;console.log(i) //10&lt;br&gt;
</code></pre>
<h2 id="const">const</h2>
<blockquote>
<p>用来声明一个只读的常量，一旦声明，常量的值就不能改变。，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>
</blockquote>
<pre><code>const a = 10；
a = 20；
console.log(a)  //TypeError: Assignment to constant variable.
上面代码表明改变常量的值会报错。
</code></pre>
<h2 id="promise">Promise</h2>
<blockquote>
<p>Promise是异步编程一种解决方案(回调地狱)</p>
</blockquote>
<pre><code>在没有promise都是这样写的回调，一层一层的写，
$.get(&quot;/getUser&quot;,function(res){
        $.get(&quot;/getUserDetail&quot;,function(){
            $.get(&quot;/getCart&quot;,function(){
                $.get(&quot;/getBooks&quot;,function(){
                    //...
                })
            })
        })
    })
</code></pre>
<ul>
<li>promise的基本用法</li>
</ul>
<pre><code>var promise=new Promise((resolve,reject)=&gt;{
       //b 把需要执行的异步操作放在这里
       $.get(&quot;/getUser&quot;,res=&gt;{
           //获取数据的异步操作已经执行完毕了，等待下一步的执行，通过执行resolve函数，告诉外界你可以执行下一步操作了
           //c、
           resolve(res)
           //而执行的下一步操作，其实就是写在then的回调函数中的
       })
   })
   //a、
   promise.then(res=&gt;{
       //d、执行后续的操作
       console.log(res);
   })
</code></pre>
<ul>
<li>promise实现多层回调</li>
</ul>
<pre><code>
new Promise((resolve,reject)=&gt;{
        $.get(&quot;/getUser&quot;,res=&gt;{
            resolve(res)
        })
    }).then(res=&gt;{
        //用户基本信息
        return new Promise(resolve=&gt;{
            $.get(&quot;/getUserDetail&quot;,res=&gt;{
                resolve(res)
            })
        })
    }).then(res=&gt;{
        //用户详情
        return new Promise(resolve=&gt;{
            $.get(&quot;/getCart&quot;,res=&gt;{
                resolve(res)
            })
        })
    }).then(res=&gt;{
        //购物车信息
    })
</code></pre>
<ul>
<li>promise实现错误处理</li>
</ul>
<pre><code>new Promise((resolve,reject)=&gt;{
        $.ajax({
            url:&quot;/getUser&quot;,
            type:&quot;GET&quot;,
            success:res=&gt;{
                resolve(res);
            },
            error:res=&gt;{
                reject(res)
            }
        })
    }).then(resSuccess=&gt;{
        //成功的返回值
    },resError=&gt;{
        //失败的返回值
    })
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 vue-devtools]]></title>
        <id>https://blog.myxy.net/shi-yong-vue-devtools/</id>
        <link href="https://blog.myxy.net/shi-yong-vue-devtools/">
        </link>
        <updated>2020-08-10T11:18:10.000Z</updated>
        <content type="html"><![CDATA[<p>找到<a href="https://github.com/vuejs/vue-devtools">vue-devtools</a>的github项目，克隆到本地；<br>
进入到项目根目录，安装依赖 <code>npm install</code> 或着 <code>cpm install</code>；<br>
找到<code>vue-devtools/shells/chrome/manifest.json</code> 文件，修改 <code>persistent</code> 为 <code>true</code>；<br>
编译构建 <code>npm run build</code>；<br>
打开chrome浏览器，输入 <code>chrome://extensions</code> 进入扩展程序页面，点击 加载已解压的扩展程序, 选择 <code>vue-devtools&gt;shells&gt;chrome</code>文件夹 （记得打开开发者模式)<br>
<code>Vue.js devtools</code> 就安装好了，点击扩展应用卡片上的 详细信息，勾选(在所有网站上,允许访问文件网址,手机各项错误)三个选项。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[cjson 使用记录]]></title>
        <id>https://blog.myxy.net/cjson-shi-yong-ji-lu/</id>
        <link href="https://blog.myxy.net/cjson-shi-yong-ji-lu/">
        </link>
        <updated>2020-07-25T12:34:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="备忘">备忘</h1>
<h3 id="打印">打印</h3>
<p><code>cJSON_Print</code>会申请内存，使用完后要free掉。</p>
<pre><code class="language-cpp">	const  char* pstr = cJSON_Print(json);
	free(pstr);
</code></pre>
<p><code>cJSON_PrintUnformatted</code> 打印出的json字符串是紧凑的不用换行，适合传输json字符串时使用<br>
<code>cJSON_PrintBuffered</code> 可以事先指定分配一个缓冲区，如果足够大，则可以节省不断重新分配空间的时间； 如果指定缓冲区过小，则与cJSON_Print和cJSON_PrintUnformatted性能能相同。<br>
<code>cJSON_PrintPreallocated</code>  可以将json字符串填入给定的缓冲区，并指定缓冲区大小。 成功返回1，失败返回0。除了这个打印json字符串的函数，以上的函数在生成json字符串时若空间不足，都会重新分配一次空间。</p>
<h3 id="销毁">销毁</h3>
<p>JSON对象使用完成记得Delete</p>
<pre><code class="language-cpp">	cJSON* pjson = NULL;
	pjson = cJSON_Parse(&quot;{}&quot;);
	cJSON_Delete(pjson);
</code></pre>
<h3 id="解析">解析</h3>
<p><code>cJSON_ParseWithOpts</code>该函数是<code>cJSON_Parse</code>的实现，但是它比<code>cJSON_Parse</code>更灵活。</p>
<ul>
<li>如果cJSON_Parse解析错误，必须调用cJSON_GetErrorPtr找到解析错误位置</li>
<li>cJSON_Parse解析不严谨，如&quot;<code>{\&quot;name\&quot;: \&quot;Lee\&quot;} }</code>&quot;这个字符串，后边多了一个大括号，但还是解析成功了。</li>
<li><code>cJSON_ParseWithOpts</code>的return_parse_end参数可以获取解析失败的位置，          require_null_terminated参数为1会检查剩余未解析字符串是否是空字符串，若不为空字符串，则会释放内存，返回空。所以因该使用<code>cJSON_ParseWithOpts</code>解析json对象</li>
</ul>
<pre><code class="language-cpp">	char* end = NULL;
	cJSON* cj_ParseWithOpts = cJSON_ParseWithOpts(&quot;{\&quot;name\&quot;: \&quot;Lee\&quot;} }&quot;, &amp;end, 1);
	if (cj_ParseWithOpts) {
		printf(&quot;%s\n\n&quot;, cJSON_Print(cj_ParseWithOpts));
	}
	else {
		printf(&quot;[%s]\n\n&quot;, end);
	}
</code></pre>
<h1 id="数组倒删除">数组倒删除</h1>
<pre><code class="language-cpp">	cJSON* adArr = NULL;  //欲删除的数组
	int arrCount = cJSON_GetArraySize(adArr);
	if (arrCount &gt; 0)
	{
		for (int j = arrCount - 1; j &gt;= 0; j--)
		{
			cJSON_DeleteItemFromArray(adArr, j);  //删除json数组对象的第j个节点
		}
	}
</code></pre>
<h1 id="对象替换">对象替换</h1>
<pre><code class="language-cpp"> cJSON* itemObj = NULL;  

   //文本替换
   cJSON_ReplaceItemInObject(itemObj, &quot;username&quot;, cJSON_CreateString(&quot;tom&quot;));

   //数组清空
   cJSON_ReplaceItemInObject(itemObj, &quot;userlist&quot;, cJSON_CreateArray());
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[uin-app]]></title>
        <id>https://blog.myxy.net/uin-app/</id>
        <link href="https://blog.myxy.net/uin-app/">
        </link>
        <updated>2020-07-25T03:06:36.000Z</updated>
        <content type="html"><![CDATA[<h1 id="目录结构">目录结构</h1>
<p><code>components</code>  自定义组件目录<br>
<code>pages</code> 页面存放目录<br>
<code>static</code> 静态文件资源目录<br>
<code>unpackage</code> 编译后的文件存放目录<br>
<code>App.vue</code>    app.js <a href="https://uniapp.dcloud.io/collocation/App">查看文档</a><br>
<code>main.js</code>  应用入口(  引用全局组件 ) <a href="https://uniapp.dcloud.io/collocation/main">查看文档</a><br>
<code>manifest,json</code>  项目配置  <a href="https://uniapp.dcloud.io/collocation/manifest">查看文档</a><br>
<code>page.json</code> 页面配置 <a href="https://uniapp.dcloud.io/collocation/pages">查看文档</a><br>
<code>package.json</code>  <a href="https://uniapp.dcloud.io/collocation/package">查看文档</a><br>
<code>vue.config.js</code> 是一个可选的配置文件  <a href="https://uniapp.dcloud.io/collocation/vue-config">查看文档</a><br>
<code>uni.scss</code>  <a href="https://uniapp.dcloud.io/collocation/uni-scss">查看文档</a></p>
<p><code>utils</code> 自定义 - 公用的工具类<br>
<code>common</code>  自定义 - 公用的文件</p>
<table>
<thead>
<tr>
<th>符号</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@</td>
<td style="text-align:center">项目根目录</td>
</tr>
<tr>
<td>vh</td>
<td style="text-align:center">屏幕高度</td>
</tr>
<tr>
<td>vw</td>
<td style="text-align:center">屏幕宽度</td>
</tr>
<tr>
<td>px</td>
<td style="text-align:center">固定</td>
</tr>
<tr>
<td>rpx</td>
<td style="text-align:center">根据屏幕宽度750动态调整</td>
</tr>
<tr>
<td>@import './index.css'</td>
<td style="text-align:center">引入外部CSS文件</td>
</tr>
</tbody>
</table>
<p>尺寸单位 :  px  rpx rem</p>
<h1 id="模板语法与数据绑定">模板语法与数据绑定</h1>
<p><view class="content" v-bing:class="className" v-on:click="open"></view><br>
&lt;view class=&quot;content&quot; :class=&quot;className&quot; @click=&quot;open&quot;&gt;</view></p>
<table>
<thead>
<tr>
<th>全写</th>
<th style="text-align:center">简写</th>
</tr>
</thead>
<tbody>
<tr>
<td>v-bing</td>
<td style="text-align:center">:</td>
</tr>
<tr>
<td>v-on</td>
<td style="text-align:center">@</td>
</tr>
</tbody>
</table>
<h1 id="条件判断">条件判断</h1>
<pre><code>&lt;view v-if=&quot;show==='1'&quot;&gt; 1 &lt;/view&gt;  如果表达式返回真值为true,那么正常渲染内容
&lt;view v-else-if=&quot;show==='2'&quot;&gt; 2 &lt;/view&gt;  如果表达式返回真值为true,那么正常渲染内容
&lt;view v-else&gt; 3 &lt;/view&gt;
</code></pre>
<h1 id="列表渲染">列表渲染</h1>
<p>item : 被迭代的数组元素的别名<br>
index : 下标别名</p>
<pre><code>&lt;view v-for=&quot;(item,index) in arr&quot;&gt; {{ (index+1) + '---' + item }} &lt;/view&gt;
&lt;view v-for=&quot;(item,value) in obj&quot;&gt; {{ value + '---' + item }} &lt;/view&gt;
</code></pre>
<h1 id="基础组件">基础组件</h1>
<view> 
    <view></view>     试图容器 .
    <scroll-view></scroll-view>   可滚动视图区域    
    <button>vue</button>  按钮
    <input value="1" />     输入框
</view>
<h1 id="自定义组件">自定义组件</h1>
<h1 id="api">API</h1>
<p><a href="https://uniapp.dcloud.io/api/README">API</a></p>
<h1 id="条件编译">条件编译</h1>
<p><a href="https://uniapp.dcloud.io/platform">条件编译</a></p>
<h1 id="生命周期">生命周期</h1>
<p><a href="https://uniapp.dcloud.io/collocation/frame/lifecycle?id=%e5%ba%94%e7%94%a8%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f">应用生命周期</a><br>
<a href="https://uniapp.dcloud.io/collocation/frame/lifecycle?id=%e9%a1%b5%e9%9d%a2%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f">页面生命周期</a><br>
<a href="https://uniapp.dcloud.io/collocation/frame/lifecycle?id=%e7%bb%84%e4%bb%b6%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f">组件生命周期</a></p>
<p>uin.navigateTo()  //打开新页面. 返回键可返回到当前页面  只能打开非 tabBar 页面。<br>
uin.redirectTo()   //关闭当前页面,打开新页面,会触发页面销毁事件.   只能打开非 tabBar 页面。</p>
<p>uin.switchTab() 只能打开 tabBar 页面。<br>
uin.reLaunch() 可以打开任意页面。</p>
<h1 id="scss">SCSS</h1>
<p>.content{<br>
&amp;.box{}    <code>&amp;</code>表示父级<br>
}</p>
<h1 id="unicloule">uniCloule</h1>
<p><a href="https://uniapp.dcloud.io/uniCloud/README">查看文档</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GraceUI]]></title>
        <id>https://blog.myxy.net/graceui/</id>
        <link href="https://blog.myxy.net/graceui/">
        </link>
        <updated>2020-07-14T12:16:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="组件插槽">组件插槽</h2>
<pre><code>&lt;slot name=&quot;gHeader&quot;&gt;&lt;/slot&gt; 头部导航内容
&lt;slot name=&quot;gBody&quot;&gt;&lt;/slot&gt; 页面主体内容
&lt;slot name=&quot;gFooter&quot;&gt;&lt;/slot&gt; 页面底部导航内容
&lt;slot name=&quot;gRTArea&quot;&gt;&lt;/slot&gt; 页面悬浮挂件内容
</code></pre>
<h3 id="uni-app-开发时-app-端必须的设置manifastjson">uni-app 开发时 APP 端必须的设置（manifast.json）</h3>
<pre><code>/* 5+App特有相关 */
&quot;app-plus&quot;: {
    &quot;nvueCompiler&quot;:&quot;uni-app&quot;,
    &quot;safearea&quot;: {
        &quot;background&quot;: &quot;#FFFFFF&quot;,  
        &quot;bottom&quot;: {  
            &quot;offset&quot;: &quot;auto&quot;  
        }  
    },
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JSON_API]]></title>
        <id>https://blog.myxy.net/json_api/</id>
        <link href="https://blog.myxy.net/json_api/">
        </link>
        <updated>2020-07-11T15:18:46.000Z</updated>
        <content type="html"><![CDATA[<h1 id="获取ip地址">获取IP地址:</h1>
<pre><code>http://mam.netease.com/api/config/getClientIp
http://sdk.open.phone.igexin.com/api/addr.htm
http://vv6.video.qq.com/checktime?otype=json&amp;guid=123&amp;randnum=0123
http://pv.sohu.com/cityjson
http://ip.360.cn/IPShare/info

</code></pre>
<h1 id="时间戳获取">时间戳获取</h1>
<pre><code>http://api.m.taobao.com/rest/api3.do?api=mtop.common.getTimestamp
http://quan.suning.com/getSysTime.do
http://api.pinduoduo.com/api/server/_stm
https://a.jd.com//ajax/queryServerData.html
https://mbuy.vmall.com/getSkuRushbuyInfo.json
https://m.poizon.com/client/cold
https://tptm.hd.mi.com/gettimestamp
http://vv6.video.qq.com/checktime?otype=json&amp;guid=123&amp;randnum=0123

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iconfont 批量把图标加入购物车的方法]]></title>
        <id>https://blog.myxy.net/iconfont-pi-liang-ba-tu-biao-jia-ru-gou-wu-che-de-fang-fa/</id>
        <link href="https://blog.myxy.net/iconfont-pi-liang-ba-tu-biao-jia-ru-gou-wu-che-de-fang-fa/">
        </link>
        <updated>2020-07-11T14:26:29.000Z</updated>
        <content type="html"><![CDATA[<p>在浏览器中按 f12 打开【开发人员工具】，找到【console(控制台)】，输入以下代码，再按回车，稍等片刻即可把全部图标加入购物车</p>
<pre><code>function str_repeat(str, num){ return new Array( num + 1 ).join( str ); }var ll = document.getElementsByClassName('icon-gouwuche1'); for (var i=0; i&lt;ll.length;i++){ll[i].click();console.clear();console.warn(&quot;Iconfont自动加购物车脚本V2\n正在下载第&quot;+(i+1)+&quot;个图标\n共计&quot;+ll.length+&quot;个图标(&quot;+(Math.floor((i+1)*100/ll.length))+&quot;%)&quot;);console.log(str_repeat(&quot;|&quot;,(Math.floor((i+1)*34/ll.length))));}console.clear();console.log(&quot;所有图标已加入购物车成功!&quot;);
</code></pre>
]]></content>
    </entry>
</feed>