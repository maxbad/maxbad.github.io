<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.myxy.net</id>
    <title>Maxbad`Blog</title>
    <updated>2020-12-16T11:43:59.917Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.myxy.net"/>
    <link rel="self" href="https://blog.myxy.net/atom.xml"/>
    <subtitle>记录一些东西</subtitle>
    <logo>https://blog.myxy.net/images/avatar.png</logo>
    <icon>https://blog.myxy.net/favicon.ico</icon>
    <rights>All rights reserved 2020, Maxbad`Blog</rights>
    <entry>
        <title type="html"><![CDATA[C++ 类中的构造函数]]></title>
        <id>https://blog.myxy.net/c-lei-zhong-de-gou-zao-han-shu/</id>
        <link href="https://blog.myxy.net/c-lei-zhong-de-gou-zao-han-shu/">
        </link>
        <updated>2020-12-16T11:33:37.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/explicitly-defaulted-and-deleted-functions?view=msvc-160">https://docs.microsoft.com/zh-cn/cpp/cpp/explicitly-defaulted-and-deleted-functions?view=msvc-160</a></p>
<h2 id="编译器默认为一个类生成的默认函数">编译器默认为一个类生成的默认函数</h2>
<ul>
<li>默认构造函数</li>
<li>默认析构函数</li>
<li>默认拷贝构造函数</li>
<li>默认赋值函数</li>
<li>移动构造函数</li>
<li>移动拷贝函数</li>
</ul>
<pre><code class="language-cpp">class DataOnly {
public:
    DataOnly ()                  // 默认构造函数
    ~DataOnly ()                 // 默认析构函数

    DataOnly (const DataOnly &amp; rhs)         　 　  // 默认拷贝构造函数
    DataOnly &amp; operator=(const DataOnly &amp; rhs)    // 默认赋值函数

    DataOnly (const DataOnly &amp;&amp; rhs)         // C++11, 移动构造函数
    DataOnly &amp; operator=(DataOnly &amp;&amp; rhs)    // C++11, 移动拷贝函数
};
</code></pre>
<p>类不可复制的通用写法</p>
<pre><code class="language-cpp">struct noncopyable
{
  noncopyable() =default;
  noncopyable(const noncopyable&amp;) =delete;
  noncopyable&amp; operator=(const noncopyable&amp;) =delete;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[hpSocket线程池]]></title>
        <id>https://blog.myxy.net/hpsocket-xian-cheng-chi/</id>
        <link href="https://blog.myxy.net/hpsocket-xian-cheng-chi/">
        </link>
        <updated>2020-12-10T02:50:46.000Z</updated>
        <content type="html"><![CDATA[<p>HP-Socket v5.4.x版本开始，提供线程池组件IHPThreadPool，协助用户实现通信逻辑与业务逻辑分离，提高应用程序的整体执行效率。IHPThreadPool提供以下主要操作方法。这些方法成功返回TRUE，失败返回FALSE，失败可通过SYS_GetLastError() 获取系统错误代码。</p>
<h2 id="启动线程池">启动线程池</h2>
<pre><code class="language-cpp">BOOL Start(dwThreadCount = 0, dwMaxQueueSize = 0, enRejectedPolicy = TRP_CALL_FAIL, dwStackSize = 0)

dwThreadCount  线程数量，（默认：0）
&gt;0 ：dwThreadCount
=0 ：(CPU核数 * 2 + 2)
&lt;0 ：(CPU核数 * (-dwThreadCount))
dwMaxQueueSize  任务队列最大容量（默认：0，不限制）
enRejectedPolicy  任务拒绝处理策略
TRP_CALL_FAIL	：（默认）立刻返回失败
TRP_WAIT_FOR	：等待（直到成功、超时或线程池关闭等原因导致失败）
TRP_CALLER_RUN	：调用者线程直接执行
dwStackSize  线程堆栈空间大小（默认：0 -&gt; 操作系统默认）
</code></pre>
<h2 id="关闭线程池">关闭线程池</h2>
<blockquote>
<p>在规定时间内关闭线程池组件，如果工作线程在最大等待时间内未能正常关闭，会尝试强制关闭，这种情况下很可能会造成系统资源泄漏。</p>
</blockquote>
<pre><code class="language-cpp">BOOL Stop(dwMaxWait = INFINITE)

dwMaxWait  最大等待时间（毫秒，默认：INFINITE，一直等待）
</code></pre>
<h2 id="提交任务">提交任务</h2>
<pre><code class="language-cpp">BOOL Sbumit(fnTaskProc, pvArg, dwMaxWait = INFINITE)

fnTaskProc  任务处理函数
pvArg  任务参数
dwMaxWait  任务提交最大等待时间（仅对TRP_WAIT_FOR类型线程池生效，默认：INFINITE，一直等待）。
** SYS_GetLastError() 错误码ERROR_DESTINATION_ELEMENT_FULL表示任务队列已满。
</code></pre>
<h2 id="提交socket任务">提交Socket任务</h2>
<pre><code class="language-cpp">BOOL Sbumit(pTask, dwMaxWait = INFINITE)

pTask  任务参数
dwMaxWait  任务提交最大等待时间（仅对TRP_WAIT_FOR类型线程池生效，默认：INFINITE，一直等待）
** SYS_GetLastError() 错误码ERROR_DESTINATION_ELEMENT_FULL表示任务队列已满。
</code></pre>
<h2 id="动态调整线程池大小">动态调整线程池大小</h2>
<pre><code class="language-cpp">BOOL AdjustThreadCount(dwNewThreadCount)

dwNewThreadCount  线程数量
&gt;0 ：dwNewThreadCount
=0 ：(CPU核数 * 2 + 2)
&lt;0 ：(CPU核数 * (-dwNewThreadCount))
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[thread_local 线程本地数据]]></title>
        <id>https://blog.myxy.net/thread_local-xian-cheng-ben-di-shu-ju/</id>
        <link href="https://blog.myxy.net/thread_local-xian-cheng-ben-di-shu-ju/">
        </link>
        <updated>2020-12-04T13:39:07.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/y396397735/article/details/81271339">https://blog.csdn.net/y396397735/article/details/81271339</a></p>
<pre><code class="language-cpp">
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;

std::mutex coutMutex;

thread_local std::string s(&quot;hello from &quot;);

void addThreadLocal(std::string const&amp; s2){

  s+=s2;
  // protect std::cout
  std::lock_guard&lt;std::mutex&gt; guard(coutMutex);
  std::cout &lt;&lt; s &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;&amp;s: &quot; &lt;&lt; &amp;s &lt;&lt; std::endl;
  std::cout &lt;&lt; std::endl;

}

int main(){

  std::cout &lt;&lt; std::endl;

  std::thread t1(addThreadLocal,&quot;t1&quot;); 
  std::thread t2(addThreadLocal,&quot;t2&quot;); 
  std::thread t3(addThreadLocal,&quot;t3&quot;); 
  std::thread t4(addThreadLocal,&quot;t4&quot;); 

  t1.join();
  t2.join();
  t3.join();
  t4.join();

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11之重写说明符override和final]]></title>
        <id>https://blog.myxy.net/c11-zhi-chong-xie-shuo-ming-fu-override-he-final/</id>
        <link href="https://blog.myxy.net/c11-zhi-chong-xie-shuo-ming-fu-override-he-final/">
        </link>
        <updated>2020-12-01T13:12:46.000Z</updated>
        <content type="html"><![CDATA[<p>c++11引入关键字 <code>override</code>和<code>final</code> 用来解决继承中虚函数的问题。</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>override</td>
<td style="text-align:left">指明该函数是重载的基类中的一个函数</td>
</tr>
<tr>
<td>final</td>
<td style="text-align:left">A.禁止该函数从基类继承；B.禁止该函数的重载</td>
</tr>
</tbody>
</table>
<p>注意: 这俩关键字 必须作用于虚函数。否则，编译提示将出错。</p>
<ul>
<li>错误示范</li>
</ul>
<pre><code class="language-cpp">class case_err
{
public:
      // 错误，编译器提示： error C3668: “case_err::name()”: 包含重写说明符“override”的方法没有重写任何基类方法
      void name() override {}      

      // error C3609: “demo_class::gender”: “final”函数必须是虚函数
      void gender() final {}
};
</code></pre>
<ul>
<li>正确用法</li>
</ul>
<pre><code class="language-cpp">// 基类
class base_class
{
public:
	// 用作测试 override 关键字的函数
	virtual void show()  { std::cout &lt;&lt; &quot;base_class::show()\n&quot;; }
	
	// 用作测试 final 关键字的函数
	virtual void say() final { std::cout &lt;&lt; &quot;base_class::say()\n&quot;; }
};

// 派生类
class demo_class : public base_class
{
public:
	// override的作用：指明该函数时重载的基类中的一个函数
	// 这里明确指明该函数是继承基类的show函数
	virtual void show() override { std::cout &lt;&lt; &quot;demo_class::show()\n&quot;; }

	// 编译错误： error C3248: “base_class::say”: 声明为“final”的函数无法被“demo_class::say”重写
	// virtual void say() override { std::cout &lt;&lt; &quot;demo_class::say()\n&quot;; }
};
</code></pre>
<p>纯虚函数一种特殊的虚函数。 but，纯虚函数通常用作基类定义接口。 显然，纯虚函数不能使用关键字override. 那 final 关键字呢? 一个例子：</p>
<pre><code class="language-cpp">class base_class
{
public:
	virtual void run() final = 0;
};
</code></pre>
<p>理论分析： 纯虚函数 run 使用关键字 final后，run函数不能被派生类（子类）继承并实现，且语法也正确。 实际： 编译通过。<br>
but，类base_class及继承自base_class的类均无法创建对象。因为： base_class的run函数是一个纯虚函数且无法被派生类继承。结论： 纯虚函数使用final关键字，无实际意义。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[fn-log]]></title>
        <id>https://blog.myxy.net/fn-log/</id>
        <link href="https://blog.myxy.net/fn-log/">
        </link>
        <updated>2020-11-27T02:40:54.000Z</updated>
        <content type="html"><![CDATA[<p>文件名支持变量:</p>
<pre><code>$PNAME      // 进程名
$PID            // 进程ID
$YEAR              // 年
$MON             // 月
$DAY               // 日
$HOUR            // 小时
$MIN               // 分钟
$SEC                // 秒
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[_WIN32，WIN32，_WIN64 ,进程是否X64,系统是否X64]]></title>
        <id>https://blog.myxy.net/_win32win32_win64-jin-cheng-shi-fou-x64xi-tong-shi-fou-x64/</id>
        <link href="https://blog.myxy.net/_win32win32_win64-jin-cheng-shi-fou-x64xi-tong-shi-fou-x64/">
        </link>
        <updated>2020-11-26T10:39:49.000Z</updated>
        <content type="html"><![CDATA[<p>在 Win32 配置下，_WIN32 有定义，_WIN64 没有定义<br>
在 x64 配置下，两者都有定义。即 在 VC 下，_WIN32 一定有定义。<br>
因此，WIN32/_WIN32 可以用来判断是否 Windows 系统（对于跨平台程序），而 _WIN64 用来判断编译环境是 x86 还是 x64。</p>
<table>
<thead>
<tr>
<th>常量\定义</th>
<th style="text-align:center">预定义选项</th>
<th style="text-align:center">Windows.h</th>
<th style="text-align:right">VC编译器</th>
</tr>
</thead>
<tbody>
<tr>
<td>WIN32</td>
<td style="text-align:center">Win32</td>
<td style="text-align:center">√(minwindef.h)</td>
<td style="text-align:right">×</td>
</tr>
<tr>
<td>_WIN32</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:right">√</td>
</tr>
<tr>
<td>_WIN64</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:right">x64</td>
</tr>
</tbody>
</table>
<p>不通过宏判断,进程是否X64,系统是否X64</p>
<pre><code class="language-cpp">typedef BOOL(WINAPI* LPFN_ISWOW64PROCESS) (HANDLE, PBOOL);

LPFN_ISWOW64PROCESS fnIsWow64Process = NULL;

BOOL Isx64Application() {
	return (sizeof(LPFN_ISWOW64PROCESS) == 8) ? TRUE : FALSE;
}

BOOL IsWow64() {
	BOOL bIsWow64 = FALSE;
	if (!fnIsWow64Process)
		fnIsWow64Process = (LPFN_ISWOW64PROCESS)GetProcAddress(GetModuleHandle(TEXT(&quot;kernel32&quot;)), &quot;IsWow64Process&quot;);
	if (fnIsWow64Process)
		if (!fnIsWow64Process(GetCurrentProcess(), &amp;bIsWow64))
			return FALSE;
	return bIsWow64;
}

int main(void)
{
	if (Isx64Application())
		_tprintf(TEXT(&quot;The application is a x64 program.\n&quot;));
	else {
		if (!IsWow64())
			_tprintf(TEXT(&quot;The application is running under Windows x86.\n&quot;));
		else
			_tprintf(TEXT(&quot;The application is a x86 program running under Windows x64.\n&quot;));
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[_WIN32，WIN32，_WIN64 ]]></title>
        <id>https://blog.myxy.net/_win32win32_win64/</id>
        <link href="https://blog.myxy.net/_win32win32_win64/">
        </link>
        <updated>2020-11-26T10:39:49.000Z</updated>
        <content type="html"><![CDATA[<p>在 Win32 配置下，_WIN32 有定义，_WIN64 没有定义<br>
在 x64 配置下，两者都有定义。即 在 VC 下，_WIN32 一定有定义。<br>
因此，WIN32/_WIN32 可以用来判断是否 Windows 系统（对于跨平台程序），而 _WIN64 用来判断编译环境是 x86 还是 x64。</p>
<table>
<thead>
<tr>
<th>常量\定义</th>
<th style="text-align:center">预定义选项</th>
<th style="text-align:center">Windows.h</th>
<th style="text-align:right">VC编译器</th>
</tr>
</thead>
<tbody>
<tr>
<td>WIN32</td>
<td style="text-align:center">Win32</td>
<td style="text-align:center">√(minwindef.h)</td>
<td style="text-align:right">×</td>
</tr>
<tr>
<td>_WIN32</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:right">√</td>
</tr>
<tr>
<td>_WIN64</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:right">x64</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[API:路径分割 _splitpath_s()]]></title>
        <id>https://blog.myxy.net/lu-jing-fen-ge-_splitpath_s/</id>
        <link href="https://blog.myxy.net/lu-jing-fen-ge-_splitpath_s/">
        </link>
        <updated>2020-11-26T02:13:05.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-cpp">#include &lt;iostream&gt;  
#include &lt;cstdlib&gt;  
using namespace std;  
  
int main()  
{  
    char *path=&quot;c:\\111\\222\\xxxx.mp3&quot;;  
    char drive[5];  
    char dir[100];  
    char filename[100];  
    char fileext[10];  
    _splitpath(path,drive,dir,filename,fileext);  
    cout&lt;&lt;&quot;filepath: &quot;&lt;&lt;path&lt;&lt;endl  
        &lt;&lt;&quot;drive: &quot;&lt;&lt;drive&lt;&lt;endl            // c:
        &lt;&lt;&quot;dir: &quot;&lt;&lt;dir&lt;&lt;endl                    // \111\222\
        &lt;&lt;&quot;filename: &quot;&lt;&lt;filename&lt;&lt;endl      // xxx
        &lt;&lt;&quot;fileext: &quot;&lt;&lt;fileext&lt;&lt;endl;       // .mp3
    system(&quot;pause&quot;);  
    return 0;  
}  
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[继承类的 override 介绍]]></title>
        <id>https://blog.myxy.net/ji-cheng-lei-de-override-jie-shao/</id>
        <link href="https://blog.myxy.net/ji-cheng-lei-de-override-jie-shao/">
        </link>
        <updated>2020-11-21T08:45:07.000Z</updated>
        <content type="html"><![CDATA[<p>https://www.cnblogs.com/xinxue/p/5471708.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DisableThreadLibraryCalls 的作用]]></title>
        <id>https://blog.myxy.net/disablethreadlibrarycalls-de-zuo-yong/</id>
        <link href="https://blog.myxy.net/disablethreadlibrarycalls-de-zuo-yong/">
        </link>
        <updated>2020-11-21T03:13:28.000Z</updated>
        <content type="html"><![CDATA[<p>功能:<code>禁用指定的DLL的DLL_THREAD_ATTACH和DLL_THREAD_DETACH通知，这样可以减小某些程序的工作集大小。</code><br>
https://blog.csdn.net/wincearm/article/details/5706605</p>
]]></content>
    </entry>
</feed>