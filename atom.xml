<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.myxy.net</id>
    <title>Maxbad`Blog</title>
    <updated>2020-10-20T01:35:36.812Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.myxy.net"/>
    <link rel="self" href="https://blog.myxy.net/atom.xml"/>
    <subtitle>记录一些东西</subtitle>
    <logo>https://blog.myxy.net/images/avatar.png</logo>
    <icon>https://blog.myxy.net/favicon.ico</icon>
    <rights>All rights reserved 2020, Maxbad`Blog</rights>
    <entry>
        <title type="html"><![CDATA[C++基础 – 容器 – LIST]]></title>
        <id>https://blog.myxy.net/cji-chu-rong-qi-list/</id>
        <link href="https://blog.myxy.net/cji-chu-rong-qi-list/">
        </link>
        <updated>2020-10-20T01:27:31.000Z</updated>
        <content type="html"><![CDATA[<h2 id="list">list</h2>
<blockquote>
<p>std::list支持从容器的任何位置快速插入和删除元素，不支持随机访问。双向链表,头文件：<list></p>
</blockquote>
<ul>
<li>定义：</li>
</ul>
<pre><code class="language-cpp">template&lt;
    class T,
    class Allocator = std::allocator&lt;T&gt;
&gt; class list;
</code></pre>
<ul>
<li>参数解释：</li>
</ul>
<ol>
<li>T 元素类型,T必须满足可拷贝复制（CopyAssignable）和可拷贝构造（CopyConstructible）的要求</li>
<li>Allocator, 用于获取/释放内存及构造/析构内存中元素的分配器</li>
</ol>
<h2 id="常用函数">常用函数</h2>
<h2 id=""></h2>
<p><code>front()</code></p>
<pre><code class="language-cpp">reference front();
const_reference front() const;
</code></pre>
<p>返回容器的第一个元素的引用。空容器上行为未定义</p>
<p><code>back()</code></p>
<pre><code class="language-cpp">reference back();
const_reference back() const;
</code></pre>
<p>返回到容器中最后一个元素的引用。空容器上行为未定义</p>
<p><code>empty()</code></p>
<pre><code class="language-cpp">bool empty() const;
</code></pre>
<p>返回容器是否为空</p>
<p><code>size()</code></p>
<pre><code class="language-cpp">size_type size() const;
</code></pre>
<p>返回容器中元素个数</p>
<p><code>clear()</code></p>
<pre><code class="language-cpp">void clear();
</code></pre>
<p>删除容器内所有元素。调用后size()返回0</p>
<p><code>resize()</code></p>
<pre><code class="language-cpp">void resize(size_type count, T value = T());
</code></pre>
<p>重设容器的大小为count个元素。如果当前size()大于count，则在尾部增加元素，并以value的副本初始化。</p>
<p><code>insert()</code></p>
<pre><code class="language-cpp">iterator insert(iterator pos, const T&amp; value); //(1)
void insert(iterator pos, size_type count, const T&amp; value); //(2)
template&lt;class InputIt&gt;
void insert(iterator pos, InputIt first, InputIt last); //(3)
</code></pre>
<p>插入元素到容器的指定位置。</p>
<ol>
<li>在pos前插入value</li>
<li>在pos前插入value的count个副本</li>
<li>在pos前插入来自范围[first, last)的元素</li>
</ol>
<p><code>emplace()</code></p>
<pre><code class="language-cpp">template&lt;class... Args&gt;
iterator emplace(const_iterator pos, Args&amp;&amp;... args); //c++11
</code></pre>
<p>直接在pos前插入元素到容器，通过std::allocator_traits::construct构造元素,将参数args…作为std::forward<Args>(args)…转发给构造函数。返回指向插入元素的iterator</p>
<p><code>erase()</code></p>
<pre><code class="language-cpp">iterator erase(iterator pos); //(1)
iterator erase(iterator first, iterator last); //(2)
</code></pre>
<p>从容器内删除指定元素,返回被移除元素之后的迭代器</p>
<ol>
<li>删除位于pos的元素</li>
<li>删除范围[first, last)中的元素</li>
</ol>
<p><code>push_back()</code></p>
<pre><code class="language-cpp">void push_back(const T&amp; value);
</code></pre>
<p>将元素value添加到容器尾部</p>
<p><code>emplace_back()</code></p>
<pre><code class="language-cpp">template&lt;class... Args&gt;
void emplace_back(Args&amp;&amp;... args); //c++11
</code></pre>
<p>添加新元素到容器尾部。通过std::allocator_traits::construct构造，参数args…以std::forward(args)…转发到构造函数。</p>
<p><code>pop_back()</code></p>
<pre><code class="language-cpp">void pop_back();
</code></pre>
<p>移除容器最后一个元素。在空容器上调用，行为未定义</p>
<p><code>push_front()</code></p>
<pre><code class="language-cpp">void push_front(const T&amp; value);
</code></pre>
<p>将元素value添加到容器的头部</p>
<p><code>emplace_front()</code></p>
<pre><code class="language-cpp">template&lt;class... Args&gt;
void emplace_front(Args&amp;&amp;... args);
</code></pre>
<p>插入元素到容器开始，通过std::allocator_traits::construct构造元素,将参数args…作为std::forward(args)…转发给构造函数</p>
<p><code>pop_front()</code></p>
<pre><code class="language-cpp">void pop_front();
</code></pre>
<p>移除容器第一个元素,如果容器为空，则行为未定义</p>
<p><code>swap()</code></p>
<pre><code class="language-cpp">void swap(list&amp; other);
</code></pre>
<p>将内容和other的交换</p>
<p><code>merge()</code></p>
<pre><code class="language-cpp">void merge(list&amp; other); //(1)
template&lt;class T&gt;
void merge(list&amp; other, Compare comp) //(2)
</code></pre>
<p>归并两个已排序链表为一个。操作后other变为空。</p>
<ol>
<li>使用operator&lt; 归并</li>
<li>使用comp 归并</li>
</ol>
<p><code>splice()</code></p>
<pre><code class="language-cpp">void splice(const_iterator pos, list&amp; other); //(1)
void splice(const_iterator pos, list&amp; other, const_iterator it); //(2)
void splice(const_iterator pos, list&amp; other, const_iterator first, const_iterator last); //(3)
</code></pre>
<p>从一个list转移元素给另一个。不复制或者移动元素，仅重值向链表节点的内部指针。</p>
<ol>
<li>从other转移所有元素到<em>this中，元素被插入到pos指向的元素之前。操作后容器other变成空。如果other和</em>this指代同一对象则行为未定义</li>
<li>从other转移it所指代的元素到*this。元素被插入到pos所指向的元素之前。</li>
<li>从other转移范围[first, last)中的元素到*this。元素被插入到pos所指向的元素之前。如果pos是范围[first, last)中的迭代器则行为未定义</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c++智能指针]]></title>
        <id>https://blog.myxy.net/czhi-neng-zhi-zhen/</id>
        <link href="https://blog.myxy.net/czhi-neng-zhi-zhen/">
        </link>
        <updated>2020-10-13T01:32:21.000Z</updated>
        <content type="html"><![CDATA[<p>文章来源:<a href="https://www.zhihu.com/question/319277442/answer/1517987598">https://www.zhihu.com/question/319277442/answer/1517987598</a></p>
<h1 id="stdunique_ptr">std::unique_ptr</h1>
<p>std::unique_ptr 对其持有的堆内存具有唯一拥有权，也就是说引用计数永远是 1，std::unique_ptr 对象销毁时会释放其持有的堆内存。</p>
<p>可以使用以下方式初始化一个 std::unique_ptr 对象：</p>
<pre><code class="language-cpp">//初始化方式1
std::unique_ptr&lt;int&gt; sp1(new int(123));

//初始化方式2
std::unique_ptr&lt;int&gt; sp2;
sp2.reset(new int(123));

//初始化方式3
std::unique_ptr&lt;int&gt; sp3 = std::make_unique&lt;int&gt;(123);  // C++14支持
</code></pre>
<p>你应该尽量使用初始化方式 3 的方式去创建一个 std::unique_ptr 而不是方式 1 和 2，因为形式 3 更安全，原因 Scott Meyers 在其《Effective Modern C++》中已经解释过了，有兴趣的读者可以阅读此书相关章节。</p>
<h1 id="stdshared_ptr">std::shared_ptr</h1>
<p>std::unique_ptr 对其持有的资源具有独占性，而 std::shared_ptr 持有的资源可以在多个 std::shared_ptr 之间共享，每多一个 std::shared_ptr 对资源的引用，资源引用计数将增加 1，每一个指向该资源的 std::shared_ptr 对象析构时，资源引用计数减 1，最后一个 std::shared_ptr 对象析构时，发现资源计数为 0，将释放其持有的资源。多个线程之间，递增和减少资源的引用计数是安全的。（注意：这不意味着多个线程同时操作 std::shared_ptr 引用的对象是安全的）。std::shared_ptr 提供了一个 use_count() 方法来获取当前持有资源的引用计数。除了上面描述的，std::shared_ptr 用法和 std::unique_ptr 基本相同。</p>
<p>下面是一个初始化 std::shared_ptr 的示例：</p>
<pre><code class="language-cpp">//初始化方式1
std::shared_ptr&lt;int&gt; sp1(new int(123));

//初始化方式2
std::shared_ptr&lt;int&gt; sp2;
sp2.reset(new int(123));

//初始化方式3
std::shared_ptr&lt;int&gt; sp3;
sp3 = std::make_shared&lt;int&gt;(123);
</code></pre>
<p>和 std::unique_ptr 一样，你应该优先使用 std::make_shared 去初始化一个 std::shared_ptr 对象。</p>
<p>实际开发中，有时候需要在类中返回包裹当前对象（this）的一个 std::shared_ptr 对象给外部使用，C++ 新标准也为我们考虑到了这一点，有如此需求的类只要继承自 std::enable_shared_from_this 模板对象即可。用法如下：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

class A : public std::enable_shared_from_this&lt;A&gt;
{
public:
    A()
    {
        std::cout &lt;&lt; &quot;A constructor&quot; &lt;&lt; std::endl;
    }

    ~A()
    {
        std::cout &lt;&lt; &quot;A destructor&quot; &lt;&lt; std::endl;
    }

    std::shared_ptr&lt;A&gt; getSelf()
    {
        return shared_from_this();
    }
};

int main()
{
    std::shared_ptr&lt;A&gt; sp1(new A());

    std::shared_ptr&lt;A&gt; sp2 = sp1-&gt;getSelf();

    std::cout &lt;&lt; &quot;use count: &quot; &lt;&lt; sp1.use_count() &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p>上述代码中，类 A 的继承 std::enable_shared_from_this 并提供一个 getSelf() 方法返回自身的 std::shared_ptr 对象，在 getSelf() 中调用 shared_from_this() 即可。</p>
<p>std::enable_shared_from_this 用起来比较方便，但是也存在很多不易察觉的陷阱。<br>
陷阱一：不应该共享栈对象的 this 给智能指针对象<br>
陷阱二：避免 std::enable_shared_from_this 的循环引用问题</p>
<h1 id="stdweak_ptr">std::weak_ptr</h1>
<p>std::weak_ptr 是一个不控制资源生命周期的智能指针，是对对象的一种弱引用，只是提供了对其管理的资源的一个访问手段，引入它的目的为协助 std::shared_ptr 工作。</p>
<p>std::weak_ptr 可以从一个 std::shared_ptr 或另一个 std::weak_ptr 对象构造，std::shared_ptr 可以直接赋值给 std::weak_ptr ，也可以通过 std::weak_ptr 的 lock() 函数来获得 std::shared_ptr。它的构造和析构不会引起引用计数的增加或减少。std::weak_ptr 可用来解决 std::shared_ptr 相互引用时的死锁问题（即两个std::shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为 0， 资源永远不会释放）。</p>
<p>示例代码如下：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

int main()
{
    //创建一个std::shared_ptr对象
    std::shared_ptr&lt;int&gt; sp1(new int(123));
    std::cout &lt;&lt; &quot;use count: &quot; &lt;&lt; sp1.use_count() &lt;&lt; std::endl;

    //通过构造函数得到一个std::weak_ptr对象
    std::weak_ptr&lt;int&gt; sp2(sp1);
    std::cout &lt;&lt; &quot;use count: &quot; &lt;&lt; sp1.use_count() &lt;&lt; std::endl;

    //通过赋值运算符得到一个std::weak_ptr对象
    std::weak_ptr&lt;int&gt; sp3 = sp1;
    std::cout &lt;&lt; &quot;use count: &quot; &lt;&lt; sp1.use_count() &lt;&lt; std::endl;

    //通过一个std::weak_ptr对象得到另外一个std::weak_ptr对象
    std::weak_ptr&lt;int&gt; sp4 = sp2;
    std::cout &lt;&lt; &quot;use count: &quot; &lt;&lt; sp1.use_count() &lt;&lt; std::endl;

    return 0;

// 执行结果如下:
//use count: 1
//use count: 1
//use count: 1
//use count: 1
}
</code></pre>
<p>无论通过何种方式创建 std::weak_ptr 都不会增加资源的引用计数，因此每次输出引用计数的值都是 1。<br>
既然，std::weak_ptr 不管理对象的生命周期，那么其引用的对象可能在某个时刻被销毁了，如何得知呢？std::weak_ptr 提供了一个 expired() 方法来做这一项检测，返回 true，说明其引用的资源已经不存在了；返回 false，说明该资源仍然存在，这个时候可以使用 std::weak_ptr 的 lock() 方法得到一个 std::shared_ptr 对象然后继续操作资源，以下代码演示了该用法：</p>
<pre><code class="language-cpp">//tmpConn_ 是一个 std::weak_ptr&lt;TcpConnection&gt; 对象
//tmpConn_引用的TcpConnection已经销毁，直接返回
if (tmpConn_.expired())
    return;

std::shared_ptr&lt;TcpConnection&gt; conn = tmpConn_.lock();
if (conn)
{
    //对conn进行操作，省略...
}
</code></pre>
<p>有读者可能对上述代码产生疑问，既然使用了 std::weak_ptr 的 expired() 方法判断了对象是否存在，为什么不直接使用 std::weak_ptr 对象对引用资源进行操作呢？实际上这是行不通的，std::weak_ptr 类没有重写 operator-&gt; 和 operator 方法，因此不能像 <em>std::shared_ptr 或 std::unique_ptr 一样直接操作对象，同时 std::weak_ptr 类也没有重写 operator! 操作，因此也不能通过 std::weak_ptr</em>* 对象直接判断其引用的资源是否存在：</p>
<pre><code class="language-cpp">#include &lt;memory&gt;

class A
{
public:
    void doSomething()
    {

    }
};

int main()
{    
    std::shared_ptr&lt;A&gt; sp1(new A());

    std::weak_ptr&lt;A&gt; sp2(sp1);

    //正确代码
    if (sp1)
    {
        //正确代码
        sp1-&gt;doSomething();
        (*sp1).doSomething();
    }

    //正确代码
    if (!sp1)
    {

    }

    //错误代码，无法编译通过
    //if (sp2)
    //{
    //    //错误代码，无法编译通过
    //    sp2-&gt;doSomething();
    //    (*sp2).doSomething();
    //}

    //错误代码，无法编译通过
    //if (!sp2)
    //{

    //}

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis持久化RDB和AOF]]></title>
        <id>https://blog.myxy.net/redis-chi-jiu-hua-rdb-he-aof/</id>
        <link href="https://blog.myxy.net/redis-chi-jiu-hua-rdb-he-aof/">
        </link>
        <updated>2020-10-11T09:46:54.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。你甚至可以关闭持久化功能，让数据只在服务器运行时存在。</p>
</blockquote>
<h1 id="rdb特性">rdb特性</h1>
<blockquote>
<p>持久化可以在指定的时间间隔内生成数据集的时间点快照</p>
</blockquote>
<pre><code>fork一个进程，遍历hash table，利用copy on write，把整个db dump保存下来。
save, shutdown, slave 命令会触发这个操作。
粒度比较大，如果save, shutdown, slave 之前crash了，则中间的操作没办法恢复。
平时写操作的时候不触发写，只有手动提交save命令，或者是关闭命令时，才触发备份操作。
</code></pre>
<h1 id="aof特性">aof特性</h1>
<blockquote>
<p>牺牲一些性能，换取更高的缓存一致性,持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集</p>
</blockquote>
<pre><code>把写操作指令，持续的写到一个类似日志文件里。（类似于从postgresql等数据库导出sql一样，只记录写操作）
粒度较小，crash之后，只有crash之前没有来得及做日志的操作没办法恢复。
持续的用日志记录写操作，crash后利用日志恢复；
</code></pre>
<p><a href="https://www.cnblogs.com/shizhengwen/p/9283973.html">https://www.cnblogs.com/shizhengwen/p/9283973.html</a></p>
<ul>
<li>Redis 默认开启RDB持久化方式，在指定的时间间隔内，执行指定次数的写操作，则将内存中的数据写入到磁盘中。</li>
<li>RDB 持久化适合大规模的数据恢复但它的数据一致性和完整性较差。</li>
<li>Redis 需要手动开启AOF持久化方式，默认是每秒将写操作日志追加到AOF文件中。</li>
<li>AOF 的数据完整性比RDB高，但记录内容多了，会影响数据恢复的效率。</li>
<li>Redis 针对 AOF文件大的问题，提供重写的瘦身机制。</li>
<li>若只打算用Redis 做缓存，可以关闭持久化。</li>
<li>若打算使用Redis 的持久化。建议RDB和AOF都开启。其实RDB更适合做数据的备份，留一后手。AOF出问题了，还有RDB。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis的RDB和AOF选择]]></title>
        <id>https://blog.myxy.net/redis-de-rdb-he-aof-xuan-ze/</id>
        <link href="https://blog.myxy.net/redis-de-rdb-he-aof-xuan-ze/">
        </link>
        <updated>2020-10-11T09:46:54.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>aof，rdb是两种 redis持久化的机制,用于crash后，redis的恢复。</p>
</blockquote>
<h1 id="rdb特性">rdb特性</h1>
<blockquote>
<p>写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份.</p>
</blockquote>
<pre><code>fork一个进程，遍历hash table，利用copy on write，把整个db dump保存下来。
save, shutdown, slave 命令会触发这个操作。
粒度比较大，如果save, shutdown, slave 之前crash了，则中间的操作没办法恢复。
平时写操作的时候不触发写，只有手动提交save命令，或者是关闭命令时，才触发备份操作。
</code></pre>
<h1 id="aof特性">aof特性</h1>
<blockquote>
<p>牺牲一些性能，换取更高的缓存一致性</p>
</blockquote>
<pre><code>把写操作指令，持续的写到一个类似日志文件里。（类似于从postgresql等数据库导出sql一样，只记录写操作）
粒度较小，crash之后，只有crash之前没有来得及做日志的操作没办法恢复。
持续的用日志记录写操作，crash后利用日志恢复；
</code></pre>
<ul>
<li>Redis 默认开启RDB持久化方式，在指定的时间间隔内，执行指定次数的写操作，则将内存中的数据写入到磁盘中。</li>
<li>RDB 持久化适合大规模的数据恢复但它的数据一致性和完整性较差。</li>
<li>Redis 需要手动开启AOF持久化方式，默认是每秒将写操作日志追加到AOF文件中。</li>
<li>AOF 的数据完整性比RDB高，但记录内容多了，会影响数据恢复的效率。</li>
<li>Redis 针对 AOF文件大的问题，提供重写的瘦身机制。</li>
<li>若只打算用Redis 做缓存，可以关闭持久化。</li>
<li>若打算使用Redis 的持久化。建议RDB和AOF都开启。其实RDB更适合做数据的备份，留一后手。AOF出问题了，还有RDB。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c++ 宏]]></title>
        <id>https://blog.myxy.net/c-hong/</id>
        <link href="https://blog.myxy.net/c-hong/">
        </link>
        <updated>2020-10-11T08:28:31.000Z</updated>
        <content type="html"><![CDATA[<h2 id="宏的妙用">宏“#”的妙用</h2>
<blockquote>
<p>如果熟悉 C++ 宏的小伙伴，可能知道里面有个 # 的用法，可以将对应的参数变成字符串，效果如下：</p>
</blockquote>
<pre><code class="language-cpp">#define  toStr(x)  #x
char *str = toStr(hello);  
//  等价于 
char *str = &quot;hello&quot;;
</code></pre>
<p>那么对于单个变量最简单的宏实现方式就是：</p>
<pre><code class="language-cpp">#define logs(x)  std::cout &lt;&lt; #x&quot;:&quot; &lt;&lt; x &lt;&lt; std::endl;
......
int delay = 5;
int other = 3;
logs(delay);
logs(other);

// 输出结果
// delay:5
// other:3
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[std::string 转 std::wstring]]></title>
        <id>https://blog.myxy.net/stdstring-zhuan-stdwstring/</id>
        <link href="https://blog.myxy.net/stdstring-zhuan-stdwstring/">
        </link>
        <updated>2020-10-11T07:04:31.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-cpp">
inline std::wstring StringToWString(const std::string&amp; str)
{
    int len = ::MultiByteToWideChar(CP_ACP, 0, str.c_str(), -1, NULL, 0);

    std::wstring buff(len, 0);
    ::MultiByteToWideChar(CP_ACP, 0, str.c_str(), -1, (LPWSTR)buff.data(), len);

    if(buff[buff.size()-1] == '\0')
        buff.erase( buff.begin() + (buff.size()-1) );

    return buff;
}
</code></pre>
<h2 id="任意类型转-stdwstring">任意类型转 std::wstring</h2>
<pre><code class="language-cpp">template&lt;class T&gt;
inline std::wstring ToWString(const T&amp; arg) 
{
    std::wstringstream temp;
    temp &lt;&lt; arg;
    return temp.str();
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11函数返回多个不同类型的值, std::tuple]]></title>
        <id>https://blog.myxy.net/c11-han-shu-fan-hui-duo-ge-bu-tong-lei-xing-de-zhi-stdtuple/</id>
        <link href="https://blog.myxy.net/c11-han-shu-fan-hui-duo-ge-bu-tong-lei-xing-de-zhi-stdtuple/">
        </link>
        <updated>2020-10-10T12:36:08.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-cpp">std::tuple&lt;bool, std::vector&lt;std::string&gt; &gt; find_urls(const std::string&amp; content) {
    ...
	return std::make_tuple(true, urls);
}

bool error = false;
std::vector&lt;std::string&gt; urls;

std::string content = &quot;...&quot;

std::tie(error, urls) = find_urls(content);
if (error) {
	parse_content(urls)
}

auto result = find_urls(content);
if (std::get&lt;0&gt;(result)) {
	parse_content(std::get&lt;1&gt;(result));
}
</code></pre>
<h1 id="c11新特性-stdtuple">C++11新特性-std::tuple</h1>
<ul>
<li>引入头文件</li>
</ul>
<pre><code class="language-cpp">#include &lt;tuple&gt;
</code></pre>
<ul>
<li>std::tuple初始化</li>
</ul>
<pre><code class="language-cpp">std::tuple&lt;int, std::string, float&gt; t1(10, &quot;Test&quot;, 3.14);
</code></pre>
<blockquote>
<p>这里要注意，不是所有的C++ 11编译器都支持copy-list-initialization的方式。如下代码所示。</p>
</blockquote>
<pre><code class="language-cpp">std::tuple&lt;int, int&gt; foo_tuple() 
{
  return {1, -1};  // Error until N4387
  return std::tuple&lt;int, int&gt;{1, -1}; // Always works
  return std::make_tuple(1, -1); // Always works
}
</code></pre>
<ul>
<li>打印std::tuple</li>
</ul>
<blockquote>
<p>打印std::tuple可以将它的元素逐个打印出来，不过非常繁琐，我们可以通过如下通用的打印函数，帮助我们一次性的将tuple的所有要素打印出来。</p>
</blockquote>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;tuple&gt;
#include &lt;string&gt;
 
// helper function to print a tuple of any size
template&lt;class Tuple, std::size_t N&gt;
struct TuplePrinter {
    static void print(const Tuple&amp; t) 
    {
        TuplePrinter&lt;Tuple, N-1&gt;::print(t);
        std::cout &lt;&lt; &quot;, &quot; &lt;&lt; std::get&lt;N-1&gt;(t);
    }
};
 
template&lt;class Tuple&gt;
struct TuplePrinter&lt;Tuple, 1&gt; {
    static void print(const Tuple&amp; t) 
    {
        std::cout &lt;&lt; std::get&lt;0&gt;(t);
    }
};
 
template&lt;typename... Args, std::enable_if_t&lt;sizeof...(Args) == 0, int&gt; = 0&gt;
void print(const std::tuple&lt;Args...&gt;&amp; t)
{
    std::cout &lt;&lt; &quot;()\n&quot;;
}
 
template&lt;typename... Args, std::enable_if_t&lt;sizeof...(Args) != 0, int&gt; = 0&gt;
void print(const std::tuple&lt;Args...&gt;&amp; t)
{
    std::cout &lt;&lt; &quot;(&quot;;
    TuplePrinter&lt;decltype(t), sizeof...(Args)&gt;::print(t);
    std::cout &lt;&lt; &quot;)\n&quot;;
}
// end helper function
 
int main()
{
    std::tuple&lt;int, std::string, float&gt; t1(10, &quot;Test&quot;, 3.14);
    print(t1);
}
</code></pre>
<p>输出：</p>
<pre><code class="language-cpp">(10, Test, 3.14)
</code></pre>
<ul>
<li>合并多个std::tuple</li>
</ul>
<blockquote>
<p>std::tuple_cat函数可以将多个std::tuple合并为一个tuple。</p>
</blockquote>
<pre><code class="language-cpp">int main()
{
    std::tuple&lt;int, std::string, float&gt; t1(10, &quot;Test&quot;, 3.14);
    int n = 7;
    auto t2 = std::tuple_cat(t1, std::make_tuple(&quot;Foo&quot;, &quot;bar&quot;), t1, std::tie(n));
    n = 42;
    print(t2);
}
</code></pre>
<p>输出：</p>
<pre><code class="language-cpp">(10, Test, 3.14, Foo, bar, 10, Test, 3.14, 42)
</code></pre>
<ul>
<li>std::tuple的解包(unpack)</li>
</ul>
<blockquote>
<p>std::tie能够将std::tuple包含的要素解包(unpack)成单个的对象。</p>
</blockquote>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;tuple&gt;
#include &lt;string&gt;
int main() {
  auto info = std::make_tuple(3.8, 'A', &quot;Lisa Simpson&quot;);
  
  double score = 0.0;
  char grade;
  std::string name;
  std::tie(score, grade, name) = info;
  std::cout &lt;&lt; &quot;score:&quot; &lt;&lt; score &lt;&lt; &quot;, grade:&quot; &lt;&lt; grade &lt;&lt; &quot;, name:&quot; &lt;&lt; name &lt;&lt; std::endl;
return 0;
}
</code></pre>
<p>输出:</p>
<pre><code class="language-cpp">score:3.8, grade:A, name:Lisa Simpson
</code></pre>
<p>std::tie还支持std::pair对象的解包(unpack)。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;tuple&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
int main() {
  auto info = std::make_pair(3.8, &quot;Lisa Simpson&quot;);
  
  double score = 0.0;
  std::string name;
  std::tie(score, name) = info;
  std::cout &lt;&lt; &quot;score:&quot; &lt;&lt; score &lt;&lt; &quot;, name:&quot; &lt;&lt; name &lt;&lt; std::endl;
return 0;
}
</code></pre>
<p>输出:</p>
<pre><code class="language-cpp">score:3.8, name:Lisa Simpson
</code></pre>
<p>当我们不关注tuple中的某个元素时，可以使用std::ignore忽略该元素。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;tuple&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
int main() {
  auto info = std::make_pair(3.8, &quot;Lisa Simpson&quot;);
  
  double score = 0.0;
  std::string name;
  std::tie(score, std::ignore) = info;
  std::cout &lt;&lt; &quot;score:&quot; &lt;&lt; score &lt;&lt; &quot;, name:&quot; &lt;&lt; name &lt;&lt; std::endl;
return 0;
}
</code></pre>
<p>输出:</p>
<pre><code class="language-cpp">score:3.8, name:
</code></pre>
<p>参考资料:<a href="https://zh.cppreference.com/w/cpp/utility/tuple/tuple_cat">https://zh.cppreference.com/w/cpp/utility/tuple/tuple_cat</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11函数返回多个不同类型的值]]></title>
        <id>https://blog.myxy.net/c11-han-shu-fan-hui-duo-ge-bu-tong-lei-xing-de-zhi/</id>
        <link href="https://blog.myxy.net/c11-han-shu-fan-hui-duo-ge-bu-tong-lei-xing-de-zhi/">
        </link>
        <updated>2020-10-10T12:36:08.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-cpp">std::tuple&lt;bool, std::vector&lt;std::string&gt; &gt; find_urls(const std::string&amp; content) {
    ...
	return std::make_tuple(true, urls);
}

bool error = false;
std::vector&lt;std::string&gt; urls;

std::string content = &quot;...&quot;

std::tie(error, urls) = find_urls(content);
if (error) {
	parse_content(urls)
}

auto result = find_urls(content);
if (std::get&lt;0&gt;(result)) {
	parse_content(std::get&lt;1&gt;(result));
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11：参数按成员函数启动线程]]></title>
        <id>https://blog.myxy.net/c11can-shu-an-cheng-yuan-han-shu-qi-dong-xian-cheng/</id>
        <link href="https://blog.myxy.net/c11can-shu-an-cheng-yuan-han-shu-qi-dong-xian-cheng/">
        </link>
        <updated>2020-10-08T06:19:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="使用非静态类成员上述作为线程启动函数">使用非静态类成员上述作为线程启动函数</h2>
<pre><code class="language-cpp">#include &lt;thread&gt;
 
class Task {
public:
Task(){
    cnt_thread.store(0);
	exit_workThread.store(false);
    
  std::thread th(&amp;Task::execute, this, &quot;Sample Task&quot;); 
  th.detach();

}
~Task(){
	exit_workThread.store(true);
    while (cnt_thread);
}
  void execute(std::string command) {      
	cnt_thread++;
    int i = 0;
    while(1)
    {
        if (exit_workThread)
			break;
              std::cout&lt;&lt;command&lt;&lt;&quot; :: &quot;&lt;&lt;i&lt;&lt;std::endl;
		this_thread::sleep_for(std::chrono::seconds(1));
              i++
    }  
	cnt_thread--;
  }
  private:  
	std::atomic&lt;int&gt;         cnt_thread;
	std::atomic&lt;bool&gt;        exit_workThread;
};
 
int main() {
  Task * taskPtr = new Task();  
 getchar();
  delete taskPtr;
  
  return 0;
}
 
</code></pre>
<h2 id="使用静态成员函数作为线程启动函数">使用静态成员函数作为线程启动函数</h2>
<blockquote>
<p>由于静态函数不依赖于任何类对象，所以我们可以直接将静态成员函数作为线程启动函数，而不必传递对象指针。</p>
</blockquote>
<pre><code class="language-cpp">#include &lt;thread&gt;
 
class Task {
public:
    static void test(std::string command) {
        for(int i = 0; i &lt; 5; i++) {
            std::cout&lt;&lt;command&lt;&lt;&quot; :: &quot;&lt;&lt;i&lt;&lt;std::endl;
        }
    }
};
 
int main() {
    // Create a thread using static member function
    std::thread th(&amp;Task::test, &quot;Task&quot;);
 
    th.join();
    return 0;
}

// 输出如下:
Task :: 0
Task :: 1
Task :: 2
Task :: 3
Task :: 4
</code></pre>
<p>参考链接<br>
<a href="https://thispointer.com/c11-start-thread-by-member-function-with-arguments/">https://thispointer.com/c11-start-thread-by-member-function-with-arguments/</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[功能日志回调接口]]></title>
        <id>https://blog.myxy.net/gong-neng-ri-zhi-hui-diao-jie-kou/</id>
        <link href="https://blog.myxy.net/gong-neng-ri-zhi-hui-diao-jie-kou/">
        </link>
        <updated>2020-09-27T07:23:50.000Z</updated>
        <content type="html"><![CDATA[<p>功能日志接口</p>
<pre><code class="language-cpp">// 定义一个输出接口
void on_error(std::function&lt;void(std::string const&amp;)&gt; const&amp; callback) {
    m_err_callback = callback;
}

// 全局变量
std::function&lt;void(std::string const&amp;)&gt; m_err_callback = nullptr; 

// 格式化日志
	void trigger_message(const char* format, ...) {
		if (m_err_callback) {
			std::string text;
			va_list ap = 0;
			va_start(ap, format);
			text.resize(_vscprintf(format, ap) + 1);
			vsprintf_s(&amp;text[0], text.capacity(), format, ap);
			va_end(ap);
			m_err_callback(text.data());
		}
	}

// 使用
trigger_message(&quot;[%s:%d],ConnectRedisCache faild&quot;, __FUNCTION__, __LINE__);
</code></pre>
]]></content>
    </entry>
</feed>