<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.myxy.net</id>
    <title>Maxbad`Blog</title>
    <updated>2021-03-12T12:03:31.174Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.myxy.net"/>
    <link rel="self" href="https://blog.myxy.net/atom.xml"/>
    <subtitle>记录一些东西</subtitle>
    <logo>https://blog.myxy.net/images/avatar.png</logo>
    <icon>https://blog.myxy.net/favicon.ico</icon>
    <rights>All rights reserved 2021, Maxbad`Blog</rights>
    <entry>
        <title type="html"><![CDATA[从资源文件中加载二进制数据]]></title>
        <id>https://blog.myxy.net/cong-zi-yuan-wen-jian-zhong-jia-zai-er-jin-zhi-shu-ju/</id>
        <link href="https://blog.myxy.net/cong-zi-yuan-wen-jian-zhong-jia-zai-er-jin-zhi-shu-ju/">
        </link>
        <updated>2021-03-12T11:34:09.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-cpp">
	static uint8_t* load_binary (HMODULE hModule, LPCTSTR resType, LPCTSTR resName) {
		HRSRC _hRsrc = ::FindResource (hModule, resName, resType);
		if (!_hRsrc)
			return nullptr;
		HGLOBAL _hGlobal = ::LoadResource (hModule, _hRsrc);
		if (!_hGlobal)
			return nullptr;
		LPVOID _src_ptr = ::LockResource (_hGlobal);
		DWORD _size = ::SizeofResource (hModule, _hRsrc);
		uint8_t *_ptr = new uint8_t [_size];
		memcpy (_ptr, _src_ptr, _size);
		//::UnlockResource (_hGlobal);
		::FreeResource (_hGlobal);
		return _ptr;
	}


    uint8_t *pdata =load_binary ((HMODULE) CPaintManagerUI::GetInstance (), _T (&quot;IPDB&quot;), MAKEINTRESOURCE (IDR_IPDB1));
if (pdata) {
			delete [] pdata;
			pdata = nullptr;
		}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows环境下“路径”处理]]></title>
        <id>https://blog.myxy.net/windows-huan-jing-xia-lu-jing-chu-li/</id>
        <link href="https://blog.myxy.net/windows-huan-jing-xia-lu-jing-chu-li/">
        </link>
        <updated>2021-03-12T03:11:38.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-cpp">#include &lt;Shlwapi.h&gt;
#pragma comment(lib, &quot;shlwapi.lib&quot;)


// 路径截断与合并函数
PathRemoveArgs                去除路径后面的参数
PathRemoveBackslash           去除路径最后的反斜杠“\”
PathAddBackslash              在路径最后加上反斜杠“\”
PathRemoveBlanks              去除路径前后的空格
PathAddExtension              在文件路径后面加上扩展名
PathRemoveExtension           去除文件路径扩展名
PathRenameExtension           更改文件路径扩展名
PathRemoveFileSpec            去除文件名，得到目录
PathUnquoteSpaces             去除路径中的首尾引号
PathQuoteSpaces               判断路径中是否有空格，有的话，就是用“”引号把整个路径包含起来
PathAppend                    将一个路径追加到另一个路径后面
PathCombine                   合并两个路径
PathSkipRoot                  去掉路径中的磁盘符或UNC部分。
PathStripPath                 去掉路径中的目录部分，得到文件名。
PathStripToRoot               去掉路径的文件部分，得到根目录。
PathCompactPath               根据像素值生成符合长度的路径。
                              如原始路径：          C:\path1\path2\sample.txt
                              根据120像素截断后为：  C:\pat...\sample.txt
                              根据25像素截断后为:   ...\sample.txt
 
PathCompactPathEx             根据字符个数来生成符合长度的路径。
PathSetDlgItemPath            将路径数据设置到对话框的子控件上。
PathUndecorate                去除路径中的修饰 
PathUnExpandEnvStrings        将路径中部分数据替换为系统环境变量格式

// 路径查找比较函数
PathFindOnPath                从路径中查找路径
PathFindExtension             查找路径的扩展名
PathFindFileName              获取路径的文件名
PathFindNextComponent         查找匹配路径（不太熟悉）
PathFindSuffixArray           查找给定的文件名是否有给定的后缀。
PathGetArgs                   获取路径参数
PathGetCharType               获取路径字符类型
PathGetDriveNumber            根据逻辑盘符返回驱动器序号

// 路径验证函数
PathCleanupSpec               去除路径中不合法的字符
PathCommonPrefix              比较并提取两个路径相同的前缀
PathFileExists                验证路径是否存在
PathMatchSpec                 判断路径是否匹配制定的扩展名。
PathIsDirectory               判断路径是否是一个有效的目录
PathIsFileSpec                验证路径是否一个文件名（有可能是一个路径）
PathIsExe                     验证路径是否是可执行文件。注意：不仅仅是.exe，还有.bat，.com，.src等
PathIsRoot                    路径是否为根路径
PathIsRelative                判断路径是否是相对路径
PathIsContentType             检测文件是否为制定类型。
                              例如：PathIsContentType( “hello.txt” , “text/plain” ) 返回TRUE
　                                  PathIsContentType( “hello.txt” , “image/gif” ) 返回FALSE
PathIsHTMLFile                判断路径是否是html文件类型——根据系统注册类型判断。
PathIsLFNFileSpec             判断路径是否是长路径格式
PathIsNetworkPath             判断路径是否是一个网络路径。
PathIsPrefix                  判断路径是否含有指定前缀
PathIsSameRoot                判断路径是否有相同根目录
PathIsSlow                    判断路径是否是一个高度延迟的网络连接
PathIsSystemFolder            判断路径是否有系统属性（属性可以自己设定）
PathIsUNC                     路径是否是UNC格式（网络路径）
PathIsUNCServer               路径是否是UNC服务器
PathIsUNCServerShare          路径是否仅仅是UNC的共享路径格式
PathIsURL                     路径是否是http格式。
PathYetAnotherMakeUniqueName  基于已存在的文件，自动创建一个唯一的文件名。比较有用，比如存在“新建文件”，此函数会创建文件名“新建文件夹 (2)”。



</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[取EXE文件自身所在的文件夹]]></title>
        <id>https://blog.myxy.net/qu-exe-wen-jian-zi-shen-suo-zai-de-wen-jian-jia/</id>
        <link href="https://blog.myxy.net/qu-exe-wen-jian-zi-shen-suo-zai-de-wen-jian-jia/">
        </link>
        <updated>2021-03-12T02:29:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="方式一">方式一:</h2>
<pre><code class="language-cpp">
TCHAR run_path[MAX_PATH] = { 0, };
//获取应用程序或者DLL的完整路径
::GetModuleFileName(NULL, run_path, MAX_PATH);
//去掉路径末尾的文件名留下反斜杠
(_tcsrchr(run_path, TEXT('\\')))[1] = 0;
// 设置运行目录
::SetCurrentDirectory(run_path);
</code></pre>
<h2 id="方式二">方式二:</h2>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;Shlwapi.h&gt;
#pragma comment(lib,&quot;shlwapi.lib&quot;)
 
int main()  
{  
	TCHAR szPath[MAX_PATH];
	//获取应用程序或者DLL的完整路径
	::GetModuleFileName(NULL, szPath, MAX_PATH);
	//去掉路径末尾的文件名和反斜杠
	::PathRemoveFileSpec(szPath);
 
	printf(&quot;%ls\n&quot;, szPath);
 
	return 0;
}
</code></pre>
<h2 id="方式三">方式三</h2>
<pre><code class="language-cpp">void GetModuleFilePath(IN char* pPath, IN DWORD nSize)
{
	char path_buffer[_MAX_PATH] = { 0 };
	char drive[_MAX_DRIVE] = { 0 };
	char dir[_MAX_DIR] = { 0 };
	char fname[_MAX_FNAME] = { 0 };
	char ext[_MAX_EXT] = { 0 };
	if (NULL == pPath)
	{
		return;
	}
	GetModuleFileNameA(NULL, path_buffer, _MAX_PATH);
	_splitpath(path_buffer, drive, dir, fname, ext);
	strcat(pPath, drive);
	strcat(pPath, dir);
}

	char path_buffer[_MAX_PATH] = { 0 };
	GetModuleFilePath(path_buffer, _MAX_PATH);

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[打印 HRESULT 返回值]]></title>
        <id>https://blog.myxy.net/da-yin-hresult-fan-hui-zhi/</id>
        <link href="https://blog.myxy.net/da-yin-hresult-fan-hui-zhi/">
        </link>
        <updated>2021-03-09T05:01:52.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-cpp">#include &lt;comdef.h&gt;
 
 // 打开服务
HRESULT pulhResult = 0;
SC_HANDLE schSCManager;
schSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
if (NULL == schSCManager)
{
    pulhResult = HRESULT_FROM_WIN32(GetLastError());
    // 方法一
    _com_error err(pulhResult);
    LPCTSTR errMsg = err.ErrorMessage();
    wprintf(L&quot;%s&quot;,errMsg);
    // 方法二
 std::string err_msg =   std::system_category().message(pulhResult)
printf(&quot;%s&quot;,err_msg.c_str());

    return pulhResult;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ 类的关键字]]></title>
        <id>https://blog.myxy.net/c-lei-de-guan-jian-zi/</id>
        <link href="https://blog.myxy.net/c-lei-de-guan-jian-zi/">
        </link>
        <updated>2021-03-08T07:39:32.000Z</updated>
        <content type="html"><![CDATA[<h1 id="final">final</h1>
<ul>
<li>禁用继承</li>
</ul>
<blockquote>
<p>C++11中允许将类标记为final，方法时直接在类名称后面使用关键字final，如此，意味着继承该类会导致编译错误。</p>
</blockquote>
<pre><code class="language-cpp">class Super final
{
    // 
};

</code></pre>
<ul>
<li>禁用重写
<blockquote>
<p>C++中还允许将方法标记为fianal，这意味着无法再子类中重写该方法。这时final关键字至于方法参数列表后面，如下</p>
</blockquote>
</li>
</ul>
<pre><code class="language-cpp">class Super
{
  public:
    Supe();
    virtual void SomeMethod() final;
};

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[限定对象只能在堆上创建]]></title>
        <id>https://blog.myxy.net/xian-ding-dui-xiang-zhi-neng-zai-dui-shang-chuang-jian/</id>
        <link href="https://blog.myxy.net/xian-ding-dui-xiang-zhi-neng-zai-dui-shang-chuang-jian/">
        </link>
        <updated>2021-03-08T06:46:28.000Z</updated>
        <content type="html"><![CDATA[<p><strong>限定对象在堆上创建的需求</strong></p>
<blockquote>
<blockquote>
<p>C++对象的一些使用场景其实已经有这种隐喻了，比如一个对象从std::enable_shared_from_this派生，当我们调用this-&gt;shared_from_this()的前提条件是这个对象已经被创建为shared_ptr，如果是一个栈对象去调用shared_from_this时会crash，所以使用派生于std::enable_shared_from_this的对象时，限定它只能在堆上创建可以保证代码的安全性。</p>
</blockquote>
</blockquote>
<pre><code class="language-cpp">struct dummy{
    class token{
    private:
        token(){}
        friend dummy;
    };

    static std::shared_ptr&lt;dummy&gt; create(){
      return std::make_shared&lt;dummy&gt;(token{});
    }

    dummy(token) : dummy() {
    }

private:
    dummy(){}
};

int main() {
  dummy d{}; //compile error
  dummy d(token{}); //compile error
  auto ptr = dummy::create(); //ok
}
</code></pre>
<p>这个代码借助了一个私有内部类token来避免在栈上创建dummy对象，因为外面无法访问这个token，只有它的友元类dummy才能访问token。另外一个问题是dummy的构造函数还是私有的，为什么这次改造之后可以用std::make_shared了？因为这里先通过public的dummy(token)去构造dummy对象的，然后dummy通过代理构造函数dummy()去真正构造一个dummy对象。</p>
<p>这个token在这里有两个作用，一个是用来避免在栈上构造dummy对象，一个是提供一个public的构造函数给std::make_shared使用。对于创建一个std::unique_ptr对象来说思路也是一样的，读者可以自行实现。至此，我们比较完美地实现了限定对象只能在堆上创建的目标。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程安全-map]]></title>
        <id>https://blog.myxy.net/xian-cheng-an-quan-map/</id>
        <link href="https://blog.myxy.net/xian-cheng-an-quan-map/">
        </link>
        <updated>2021-03-06T03:11:58.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-cpp">#pragma once
#include &lt;map&gt;
#include &lt;mutex&gt;

template&lt;typename Key, typename Val&gt;
class SafeMap
{
public:
	typedef typename std::map&lt;Key, Val&gt;::iterator this_iterator;
	typedef typename std::map&lt;Key, Val&gt;::const_iterator this_const_iterator;
	Val&amp; operator [](const Key&amp; key)
	{
		std::lock_guard&lt;std::mutex&gt; lk(mtx_);
		return dataMap_[key];
	}

	int erase(const Key&amp; key)
	{
		std::lock_guard&lt;std::mutex&gt; lk(mtx_);
		return dataMap_.erase(key);
	}

	this_iterator find(const Key&amp; key)
	{
		std::lock_guard&lt;std::mutex&gt; lk(mtx_);
		return dataMap_.find(key);
	}

	this_const_iterator find(const Key&amp; key) const
	{
		std::lock_guard&lt;std::mutex&gt; lk(mtx_);
		return dataMap_.find(key);
	}

	this_iterator end()
	{
		return dataMap_.end();
	}

	this_const_iterator end() const
	{
		return dataMap_.end();
	}

private:
	std::map&lt;Key, Val&gt; dataMap_;
	std::mutex mtx_;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程安全-队列]]></title>
        <id>https://blog.myxy.net/xian-cheng-an-quan-dui-lie/</id>
        <link href="https://blog.myxy.net/xian-cheng-an-quan-dui-lie/">
        </link>
        <updated>2021-03-06T03:11:00.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-cpp">#pragma once
#include &lt;iostream&gt;
#include &lt;condition_variable&gt;
#include &lt;mutex&gt;
#include &lt;queue&gt;
#include &lt;memory&gt;

/*
*
 * 线程安全队列
 * T为队列元素类型
 * 因为有std::mutex和std::condition_variable类成员,所以此类不支持复制构造函数也不支持赋值操作符(=)
 *
 * 来源: https://blog.csdn.net/u011726005/article/details/82670730
 */
template&lt;class T, class Container = std::queue&lt;T&gt;&gt;
class ThreadSafeQueue {
public:
	ThreadSafeQueue() = default;

	// 将元素加入队列
	template &lt;class Element&gt;
	void Push(Element&amp;&amp; element) {
		std::lock_guard&lt;std::mutex&gt; lock(mutex_);
		queue_.push(std::forward&lt;Element&gt;(element));
		not_empty_cv_.notify_one();
	}

	// 从队列中弹出一个元素,如果队列为空就阻塞
	void WaitAndPop(T&amp; t) {
		std::unique_lock&lt;std::mutex&gt; lock(mutex_);
		not_empty_cv_.wait(lock, [this]() {
			return !queue_.empty();
			});

		t = std::move(queue_.front());
		queue_.pop()
	}

	// 从队列中弹出一个元素,如果队列为空就阻塞
	std::shared_ptr&lt;T&gt; WaitAndPop() {
		std::unique_lock&lt;std::mutex&gt; lock(mutex_);
		not_empty_cv_.wait(lock, [this]() {
			return !queue_.empty();
			});

		std::shared_ptr&lt;T&gt; t_ptr = std::make_shared&lt;T&gt;(queue_.front());
		queue_.pop();

		return t_ptr;
	}

	// 从队列中弹出一个元素,如果队列为空返回false
	bool TryPop(T&amp; t) {
		std::lock_guard&lt;std::mutex&gt; lock(mutex_);
		if (queue_.empty()) {
			return false;
		}

		t = std::move(queue_.front());
		queue_.pop();
		return true;
	}

	// 从队列中弹出一个元素,如果队列为空返回空指针
	std::shared_ptr&lt;T&gt; TryPop() {
		std::lock_guard&lt;std::mutex&gt; lock(mutex_);
		if (queue_.empty()) {
			return std::shared_ptr&lt;T&gt;();
		}

		t = std::move(queue_.front());
		std::shared_ptr&lt;T&gt; t_ptr = std::make_shared&lt;T&gt;(queue_.front());
		queue_.pop();

		return t_ptr;
	}

	// 返回队列是否为空
	bool IsEmpty() const {
		std::lock_guard&lt;std::mutex&gt; lock(mutex_);
		return queue_.empty();
	}

	// 返回队列中元素数个
	size_t size() {
		std::lock_guard&lt;std::mutex&gt; lock(mutex_);
		return queue_.size();
	}

private:
	ThreadSafeQueue(const ThreadSafeQueue&amp;) = delete;
	ThreadSafeQueue&amp; operator=(const ThreadSafeQueue&amp;) = delete;
	ThreadSafeQueue(ThreadSafeQueue&amp;&amp;) = delete;
	ThreadSafeQueue&amp; operator=(ThreadSafeQueue&amp;&amp;) = delete;

private:
	Container queue_;

	std::condition_variable not_empty_cv_;
	mutable std::mutex mutex_;
};

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[番茄的一些记录]]></title>
        <id>https://blog.myxy.net/fan-qie-de-yi-xie-ji-lu/</id>
        <link href="https://blog.myxy.net/fan-qie-de-yi-xie-ji-lu/">
        </link>
        <updated>2021-01-25T07:40:17.000Z</updated>
        <content type="html"><![CDATA[<h1 id="快捷键">快捷键</h1>
<table>
<thead>
<tr>
<th>快捷键</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>alt+o</td>
<td style="text-align:left">换 .h 和 .cpp</td>
</tr>
<tr>
<td>alt+shift+o</td>
<td style="text-align:left">全局找文件</td>
</tr>
<tr>
<td>alt+shift+s</td>
<td style="text-align:left">全局找符号</td>
</tr>
<tr>
<td>alt+shift+f</td>
<td style="text-align:left">全局找当前光标符号</td>
</tr>
<tr>
<td>f8</td>
<td style="text-align:left">ctrl+shift+f 之后 f8，查找下一个当前光标符号的引用，这个不是 vax 的功能，是 vs 自带的</td>
</tr>
<tr>
<td>alt+g</td>
<td style="text-align:left">找定义</td>
</tr>
<tr>
<td>alt+shift+g</td>
<td style="text-align:left">找继承关系</td>
</tr>
<tr>
<td>alt+shift+q</td>
<td style="text-align:left">添加 include</td>
</tr>
<tr>
<td>alt+shift+r</td>
<td style="text-align:left">重构</td>
</tr>
<tr>
<td>ctrl+k,ctrl+s</td>
<td style="text-align:left">包裹代码</td>
</tr>
<tr>
<td>alt+m</td>
<td style="text-align:left">当前文件方法</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[std::string 构造函数]]></title>
        <id>https://blog.myxy.net/stdstring-gou-zao-han-shu/</id>
        <link href="https://blog.myxy.net/stdstring-gou-zao-han-shu/">
        </link>
        <updated>2021-01-11T03:28:26.000Z</updated>
        <content type="html"><![CDATA[<p>C++中的String的常用函数用法总结: <a href="https://blog.csdn.net/qq_37941471/article/details/82107077">https://blog.csdn.net/qq_37941471/article/details/82107077</a></p>
<ul>
<li>
<p>1,将构造的对象初始化为s的前n个字符，s不够n个时将相邻的内存单元的内容当作s的一部分继续复制:<br>
<code>string(const char *s, size_type n, const Allocator &amp;a = Allocator());</code></p>
<pre><code class="language-cpp">  std::string testStr(&quot;Telephone home.&quot;, 4);
  OutputDebugStringA(testStr.c_str());
  // 输出:Tele
</code></pre>
</li>
<li>
<p>2,将构造的对象初始化为s的后n个字符，也就是从s指向的内存的第n个字节开始复制：<br>
<code>string(const string &amp;str, size_type pos,size_type n = npos, const Allocator &amp;a = Allocator());</code></p>
</li>
</ul>
<pre><code class="language-cpp">    std::string text(&quot;Telephone home.&quot;);
    std::string testStr(text, 4);
    OutputDebugStringA(testStr.c_str());
    // 输出:phone home.
</code></pre>
<ul>
<li>3,创建一个n个字符的string对象：<br>
<code>string(size_type n, char c, const Allocator &amp;a = Allocator())</code><pre><code class="language-cpp">  std::string testStr(10, 'a');
  OutputDebugStringA(testStr.c_str());
  // 输出:aaaaaaaaaa
</code></pre>
</li>
</ul>
<p>其他文档:<a href="http://c.biancheng.net/view/1443.html">http://c.biancheng.net/view/1443.html</a></p>
]]></content>
    </entry>
</feed>