<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.myxy.net</id>
    <title>Maxbad`Blog</title>
    <updated>2020-05-09T02:05:38.511Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.myxy.net"/>
    <link rel="self" href="https://blog.myxy.net/atom.xml"/>
    <subtitle>记录一些东西</subtitle>
    <logo>https://blog.myxy.net/images/avatar.png</logo>
    <icon>https://blog.myxy.net/favicon.ico</icon>
    <rights>All rights reserved 2020, Maxbad`Blog</rights>
    <entry>
        <title type="html"><![CDATA[C++17：folder expression（折叠表达式）]]></title>
        <id>https://blog.myxy.net/c17folder-expressionzhe-die-biao-da-shi/</id>
        <link href="https://blog.myxy.net/c17folder-expressionzhe-die-biao-da-shi/">
        </link>
        <updated>2020-05-08T06:15:00.000Z</updated>
        <content type="html"><![CDATA[<p>（1）先举一个不是很恰当的例子给大家看一下折叠表达式具体是怎么使用的：</p>
<pre><code class="language-cpp">int sum_1_to_5()
{
  return (1 + 2 + 3 + 4 + 5);
}

sum_1_to_5();
</code></pre>
<p>我们使用</p>
<pre><code class="language-cpp">template&lt;typename ...Args&gt;
int sum(Args&amp;&amp;... args) 
{
    return (args + ... + 0); 
}

sum(1, 2, 3, 4, 5);
</code></pre>
<p>也就是说折叠表达式能够自动的将指定的操作应用于形参包。<code>(args + ... + 0)</code> 等价于<code>(1+2+3+4+5+0)</code></p>
<p>（2）语法</p>
<pre><code class="language-cpp">( pack op ... )                             (1) 
( ... op pack )                             (2) 
( pack op ... op init )                 (3) 
( init op ... op pack )                 (4) 
</code></pre>
<p><code>pack</code>指的是参数包，<code>op</code>指的是具体的操作，<code>init</code>指的是具体的初始值。<br>
上述的语法等价于<br>
(1) 称为一元右折叠：unary right fold<br>
(2) 称为一元左折叠：unary left fold<br>
(3) 称为二元右折叠：binary right fold<br>
(4) 称为二元左折叠：binary left fold<br>
上述的表达式等价于：<br>
<code>(E op ...)</code> &lt;=&gt; <code>(E1 op (... op (E N-1 op EN))) （1）</code><br>
<code>(... op E)</code>&lt;=&gt; <code>(((E1 op E2) op ...) op EN) （2）</code><br>
<code>(E op ... op I)</code>&lt;=&gt; <code>(E1 op (... op (EN−1 op (EN op I)))) （3）</code><br>
<code>(I op ... op E)</code>&lt;=&gt; <code>((((I op E1) op E2) op ...) op EN) （4）</code><br>
E 为有N个元素的参数包，<code>op</code>为具体的操作符，<code>I</code>为初始值。在（3），（4）中，两个<code>op</code>一定要是一样的。</p>
<p>需要比较值得重点关注的一点是，二元<code>op</code>的取值范围为:<br>
<code>+</code>，<code>-</code>，<code>*</code>， <code>/</code>， <code>%</code>， <code>^</code>， <code>&amp;</code>， <code>|</code>， <code>=</code>， <code>&lt;</code>， <code>&gt;</code>， <code>&lt;&lt;</code>， <code>&gt;&gt;</code>， <code>+=</code>， <code>-=</code>， <code>*=</code>， <code>/=</code>， <code>%=</code>， <code>^=</code>， <code>&amp;=</code>， <code>|=</code>， <code>&lt;&lt;=</code>， <code>&gt;&gt;=</code>， <code>==</code>， <code>!=</code>， <code>&lt;=</code>， <code>&gt;=</code>， <code>&amp;&amp;</code>， <code>||</code> ，<code>,，</code> <code>.*</code>， <code>-&gt;*</code>。</p>
<p>再给大家两个比较简单的例子:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

//(1) ( pack op ... )
template&lt;class T, class... Args&gt;
void push_back_vec(std::vector&lt;T&gt;&amp; v, Args&amp;&amp;... args)
{
   static_assert((std::is_constructible_v&lt;T, Args&amp;&gt; &amp;&amp; ...));
   (v.push_back(args), ...);
}

//(4) (init op ... op pack)
template&lt;class ...Args&gt;
void printer(Args&amp;&amp;... args)
{
   (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; '\n';
}

int main()
{
   std::vector&lt;int&gt; v;
   push_back_vec(v, 6, 2, 45, 12);
   for (int i : v) std::cout &lt;&lt; i &lt;&lt; ' ';   //6 2 45 12
   std::cout &lt;&lt; &quot;\n&quot;;
   
   printer(1, 2, 3, &quot;abc&quot;);   //123abc
   return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++98、C++11使用C++17的 string_view]]></title>
        <id>https://blog.myxy.net/c98c11-shi-yong-c17-de-string_view/</id>
        <link href="https://blog.myxy.net/c98c11-shi-yong-c17-de-string_view/">
        </link>
        <updated>2020-05-08T04:09:36.000Z</updated>
        <content type="html"><![CDATA[<p>项目地址:<a href="https://github.com/martinmoene/string-view-lite">string-view-lite</a></p>
<p>使用示例:</p>
<pre><code class="language-cpp">#include &quot;nonstd/string_view.hpp&quot;
#include &lt;iostream&gt;

using namespace std::literals;
using namespace nonstd::literals;
using namespace nonstd;
    
void write( string_view sv )
{
    std::cout &lt;&lt; sv;
}

int main()
{
    write( &quot;hello&quot;     );   // C-string
    write( &quot;, &quot;s       );   // std::string
    write( &quot;world!&quot;_sv );   // nonstd::string_view
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[编程字体]]></title>
        <id>https://blog.myxy.net/bian-cheng-zi-ti/</id>
        <link href="https://blog.myxy.net/bian-cheng-zi-ti/">
        </link>
        <updated>2020-05-05T07:12:24.000Z</updated>
        <summary type="html"><![CDATA[<p>最近，微软和 JetBrains 纷纷推出了自己的编程字体，你现在在用哪款呢？</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近，微软和 JetBrains 纷纷推出了自己的编程字体，你现在在用哪款呢？</p>
<!-- more -->
<p><a href="https://github.com/belluzj/fantasque-sans">Fantasque Sans Mono</a>它是专门为程序员打造</p>
<p><a href="https://www.jetbrains.com/lp/mono/">JetBrains Mono</a>JetBrains 出的一款编程字体。主要特性包含增加字母高度，以获得更好的阅读体验；符号的独特性，例如 0 中间包含一个点；9°角的斜体设计等。</p>
<p><a href="https://github.com/microsoft/cascadia-code">Cascadia Code</a> 微软出的一款编程字体,它被默认集成到了 Windows Terminal 终端命令程序.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[语法]]></title>
        <id>https://blog.myxy.net/yu-fa/</id>
        <link href="https://blog.myxy.net/yu-fa/">
        </link>
        <updated>2020-05-05T05:45:20.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://guides.github.com/features/mastering-markdown/">Mastering Markdown</a>作为一个强大的文本表示格式，能够轻而易举地渲染成HTML文档，以下是语法：</p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://guides.github.com/features/mastering-markdown/">Mastering Markdown</a>作为一个强大的文本表示格式，能够轻而易举地渲染成HTML文档，以下是语法：</p>
<!-- more -->
<h1 id="链接">链接</h1>
<p><code>[baidu](https://www.baidu.com/)</code><br>
<a href="https://www.baidu.com/">baidu</a></p>
<h1 id="图片">图片</h1>
<p><code>![LOGO](https://www.baidu.com/img/bd_logo1.png)</code><br>
<img src="https://www.baidu.com/img/bd_logo1.png" alt="LOGO" loading="lazy"></p>
<h1 id="标题">标题</h1>
<h4 id="markdown的标题越大字体越小">MarkDown的标题越大字体越小</h4>
<p><code># 一级标题</code><br>
<code>## 二级标题</code><br>
<code>### 三级标题</code><br>
<code>#### 四级标题</code><br>
<code>##### 五级标题</code><br>
<code>###### 六级标题</code></p>
<h1 id="一级标题">一级标题</h1>
<h2 id="二级标题">二级标题</h2>
<h3 id="三级标题">三级标题</h3>
<h4 id="四级标题">四级标题</h4>
<h5 id="五级标题">五级标题</h5>
<h6 id="六级标题">六级标题</h6>
<h1 id="无序列表">无序列表</h1>
<h4 id="三个符号的效果一致且可以混用">三个符号的效果一致,且可以混用</h4>
<p><code>+ a</code><br>
<code>- b</code><br>
<code>* c</code></p>
<ul>
<li>a</li>
</ul>
<ul>
<li>b</li>
</ul>
<ul>
<li>c</li>
</ul>
<h1 id="有序列表">有序列表</h1>
<p><code>1. a</code><br>
<code>2. b</code><br>
<code>3. c</code></p>
<ol>
<li>a</li>
<li>b</li>
<li>c</li>
</ol>
<h1 id="引用块">引用块</h1>
<p><code>&gt;这是引用内容</code></p>
<blockquote>
<p>这是引用内容</p>
</blockquote>
<p>#examples)<br>
👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[定时消失的信息框] Windows API函数之MessageBoxTimeout]]></title>
        <id>https://blog.myxy.net/messageboxtimeout/</id>
        <link href="https://blog.myxy.net/messageboxtimeout/">
        </link>
        <updated>2020-05-05T03:55:43.000Z</updated>
        <content type="html"><![CDATA[<p>Windows下的消息框MessagBox，会把程序阻塞住，需要用户与其交互后才能继续往下执行。你可能希望有一个既能弹出消息框，而又不阻塞在界面上，能够超时自动消失，类似于Android下的Toast。如果你有时间可以自己实现一个这样的窗口类，所幸Window已经提供了这样的功能了。你只需要建立一个头文件，把它包含进需要调用的源文件里面。比如这个头文件叫MsgBoxTimeout.h，其内容为：</p>
<pre><code class="language-cpp">#pragma once 
#include &lt;Windows.h&gt; 
// 此函数由user32.dll导出，windows2000及以下没有此函数 
// 添加MessageBoxTimeout支持
extern &quot;C&quot;
{
	int WINAPI MessageBoxTimeoutA(IN HWND hWnd, IN LPCSTR lpText, IN LPCSTR lpCaption, IN UINT uType, IN WORD wLanguageId, IN DWORD dwMilliseconds);
	int WINAPI MessageBoxTimeoutW(IN HWND hWnd, IN LPCWSTR lpText, IN LPCWSTR lpCaption, IN UINT uType, IN WORD wLanguageId, IN DWORD dwMilliseconds);
} 
#ifdef UNICODE
#define MessageBoxTimeout MessageBoxTimeoutW
#else
#define MessageBoxTimeout MessageBoxTimeoutA
#endif

//使用方法:
// 设置1000ms自动关闭该提示对话框
MessageBoxTimeout(NULL, L&quot;倒计时&quot;, L&quot;提示&quot;, MB_OKCANCEL, 0, 1000);
</code></pre>
<p>该API函数的参数与MessageBox的区别在于后面多了两个参数，其中wLanguageId缺省传0尽可，dwMilliseconds是希望此消息框停留的毫秒数。<br>
<a href="https://baike.baidu.com/item/MessageBoxTimeout">参考:https://baike.baidu.com/item/MessageBoxTimeout</a></p>
]]></content>
    </entry>
</feed>