<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.myxy.net</id>
    <title>Maxbad`Blog</title>
    <updated>2020-12-04T13:40:52.736Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.myxy.net"/>
    <link rel="self" href="https://blog.myxy.net/atom.xml"/>
    <subtitle>记录一些东西</subtitle>
    <logo>https://blog.myxy.net/images/avatar.png</logo>
    <icon>https://blog.myxy.net/favicon.ico</icon>
    <rights>All rights reserved 2020, Maxbad`Blog</rights>
    <entry>
        <title type="html"><![CDATA[thread_local 线程本地数据]]></title>
        <id>https://blog.myxy.net/thread_local-xian-cheng-ben-di-shu-ju/</id>
        <link href="https://blog.myxy.net/thread_local-xian-cheng-ben-di-shu-ju/">
        </link>
        <updated>2020-12-04T13:39:07.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/y396397735/article/details/81271339">https://blog.csdn.net/y396397735/article/details/81271339</a></p>
<pre><code class="language-cpp">
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;

std::mutex coutMutex;

thread_local std::string s(&quot;hello from &quot;);

void addThreadLocal(std::string const&amp; s2){

  s+=s2;
  // protect std::cout
  std::lock_guard&lt;std::mutex&gt; guard(coutMutex);
  std::cout &lt;&lt; s &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;&amp;s: &quot; &lt;&lt; &amp;s &lt;&lt; std::endl;
  std::cout &lt;&lt; std::endl;

}

int main(){

  std::cout &lt;&lt; std::endl;

  std::thread t1(addThreadLocal,&quot;t1&quot;); 
  std::thread t2(addThreadLocal,&quot;t2&quot;); 
  std::thread t3(addThreadLocal,&quot;t3&quot;); 
  std::thread t4(addThreadLocal,&quot;t4&quot;); 

  t1.join();
  t2.join();
  t3.join();
  t4.join();

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11之重写说明符override和final]]></title>
        <id>https://blog.myxy.net/c11-zhi-chong-xie-shuo-ming-fu-override-he-final/</id>
        <link href="https://blog.myxy.net/c11-zhi-chong-xie-shuo-ming-fu-override-he-final/">
        </link>
        <updated>2020-12-01T13:12:46.000Z</updated>
        <content type="html"><![CDATA[<p>c++11引入关键字 <code>override</code>和<code>final</code> 用来解决继承中虚函数的问题。</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>override</td>
<td style="text-align:left">指明该函数是重载的基类中的一个函数</td>
</tr>
<tr>
<td>final</td>
<td style="text-align:left">A.禁止该函数从基类继承；B.禁止该函数的重载</td>
</tr>
</tbody>
</table>
<p>注意: 这俩关键字 必须作用于虚函数。否则，编译提示将出错。</p>
<ul>
<li>错误示范</li>
</ul>
<pre><code class="language-cpp">class case_err
{
public:
      // 错误，编译器提示： error C3668: “case_err::name()”: 包含重写说明符“override”的方法没有重写任何基类方法
      void name() override {}      

      // error C3609: “demo_class::gender”: “final”函数必须是虚函数
      void gender() final {}
};
</code></pre>
<ul>
<li>正确用法</li>
</ul>
<pre><code class="language-cpp">// 基类
class base_class
{
public:
	// 用作测试 override 关键字的函数
	virtual void show()  { std::cout &lt;&lt; &quot;base_class::show()\n&quot;; }
	
	// 用作测试 final 关键字的函数
	virtual void say() final { std::cout &lt;&lt; &quot;base_class::say()\n&quot;; }
};

// 派生类
class demo_class : public base_class
{
public:
	// override的作用：指明该函数时重载的基类中的一个函数
	// 这里明确指明该函数是继承基类的show函数
	virtual void show() override { std::cout &lt;&lt; &quot;demo_class::show()\n&quot;; }

	// 编译错误： error C3248: “base_class::say”: 声明为“final”的函数无法被“demo_class::say”重写
	// virtual void say() override { std::cout &lt;&lt; &quot;demo_class::say()\n&quot;; }
};
</code></pre>
<p>纯虚函数一种特殊的虚函数。 but，纯虚函数通常用作基类定义接口。 显然，纯虚函数不能使用关键字override. 那 final 关键字呢? 一个例子：</p>
<pre><code class="language-cpp">class base_class
{
public:
	virtual void run() final = 0;
};
</code></pre>
<p>理论分析： 纯虚函数 run 使用关键字 final后，run函数不能被派生类（子类）继承并实现，且语法也正确。 实际： 编译通过。<br>
but，类base_class及继承自base_class的类均无法创建对象。因为： base_class的run函数是一个纯虚函数且无法被派生类继承。结论： 纯虚函数使用final关键字，无实际意义。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[fn-log]]></title>
        <id>https://blog.myxy.net/fn-log/</id>
        <link href="https://blog.myxy.net/fn-log/">
        </link>
        <updated>2020-11-27T02:40:54.000Z</updated>
        <content type="html"><![CDATA[<p>文件名支持变量:</p>
<pre><code>$PNAME      // 进程名
$PID            // 进程ID
$YEAR              // 年
$MON             // 月
$DAY               // 日
$HOUR            // 小时
$MIN               // 分钟
$SEC                // 秒
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[_WIN32，WIN32，_WIN64 ,进程是否X64,系统是否X64]]></title>
        <id>https://blog.myxy.net/_win32win32_win64-jin-cheng-shi-fou-x64xi-tong-shi-fou-x64/</id>
        <link href="https://blog.myxy.net/_win32win32_win64-jin-cheng-shi-fou-x64xi-tong-shi-fou-x64/">
        </link>
        <updated>2020-11-26T10:39:49.000Z</updated>
        <content type="html"><![CDATA[<p>在 Win32 配置下，_WIN32 有定义，_WIN64 没有定义<br>
在 x64 配置下，两者都有定义。即 在 VC 下，_WIN32 一定有定义。<br>
因此，WIN32/_WIN32 可以用来判断是否 Windows 系统（对于跨平台程序），而 _WIN64 用来判断编译环境是 x86 还是 x64。</p>
<table>
<thead>
<tr>
<th>常量\定义</th>
<th style="text-align:center">预定义选项</th>
<th style="text-align:center">Windows.h</th>
<th style="text-align:right">VC编译器</th>
</tr>
</thead>
<tbody>
<tr>
<td>WIN32</td>
<td style="text-align:center">Win32</td>
<td style="text-align:center">√(minwindef.h)</td>
<td style="text-align:right">×</td>
</tr>
<tr>
<td>_WIN32</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:right">√</td>
</tr>
<tr>
<td>_WIN64</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:right">x64</td>
</tr>
</tbody>
</table>
<p>不通过宏判断,进程是否X64,系统是否X64</p>
<pre><code class="language-cpp">typedef BOOL(WINAPI* LPFN_ISWOW64PROCESS) (HANDLE, PBOOL);

LPFN_ISWOW64PROCESS fnIsWow64Process = NULL;

BOOL Isx64Application() {
	return (sizeof(LPFN_ISWOW64PROCESS) == 8) ? TRUE : FALSE;
}

BOOL IsWow64() {
	BOOL bIsWow64 = FALSE;
	if (!fnIsWow64Process)
		fnIsWow64Process = (LPFN_ISWOW64PROCESS)GetProcAddress(GetModuleHandle(TEXT(&quot;kernel32&quot;)), &quot;IsWow64Process&quot;);
	if (fnIsWow64Process)
		if (!fnIsWow64Process(GetCurrentProcess(), &amp;bIsWow64))
			return FALSE;
	return bIsWow64;
}

int main(void)
{
	if (Isx64Application())
		_tprintf(TEXT(&quot;The application is a x64 program.\n&quot;));
	else {
		if (!IsWow64())
			_tprintf(TEXT(&quot;The application is running under Windows x86.\n&quot;));
		else
			_tprintf(TEXT(&quot;The application is a x86 program running under Windows x64.\n&quot;));
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[_WIN32，WIN32，_WIN64 ]]></title>
        <id>https://blog.myxy.net/_win32win32_win64/</id>
        <link href="https://blog.myxy.net/_win32win32_win64/">
        </link>
        <updated>2020-11-26T10:39:49.000Z</updated>
        <content type="html"><![CDATA[<p>在 Win32 配置下，_WIN32 有定义，_WIN64 没有定义<br>
在 x64 配置下，两者都有定义。即 在 VC 下，_WIN32 一定有定义。<br>
因此，WIN32/_WIN32 可以用来判断是否 Windows 系统（对于跨平台程序），而 _WIN64 用来判断编译环境是 x86 还是 x64。</p>
<table>
<thead>
<tr>
<th>常量\定义</th>
<th style="text-align:center">预定义选项</th>
<th style="text-align:center">Windows.h</th>
<th style="text-align:right">VC编译器</th>
</tr>
</thead>
<tbody>
<tr>
<td>WIN32</td>
<td style="text-align:center">Win32</td>
<td style="text-align:center">√(minwindef.h)</td>
<td style="text-align:right">×</td>
</tr>
<tr>
<td>_WIN32</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:right">√</td>
</tr>
<tr>
<td>_WIN64</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:right">x64</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[API:路径分割 _splitpath_s()]]></title>
        <id>https://blog.myxy.net/lu-jing-fen-ge-_splitpath_s/</id>
        <link href="https://blog.myxy.net/lu-jing-fen-ge-_splitpath_s/">
        </link>
        <updated>2020-11-26T02:13:05.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-cpp">#include &lt;iostream&gt;  
#include &lt;cstdlib&gt;  
using namespace std;  
  
int main()  
{  
    char *path=&quot;c:\\111\\222\\xxxx.mp3&quot;;  
    char drive[5];  
    char dir[100];  
    char filename[100];  
    char fileext[10];  
    _splitpath(path,drive,dir,filename,fileext);  
    cout&lt;&lt;&quot;filepath: &quot;&lt;&lt;path&lt;&lt;endl  
        &lt;&lt;&quot;drive: &quot;&lt;&lt;drive&lt;&lt;endl            // c:
        &lt;&lt;&quot;dir: &quot;&lt;&lt;dir&lt;&lt;endl                    // \111\222\
        &lt;&lt;&quot;filename: &quot;&lt;&lt;filename&lt;&lt;endl      // xxx
        &lt;&lt;&quot;fileext: &quot;&lt;&lt;fileext&lt;&lt;endl;       // .mp3
    system(&quot;pause&quot;);  
    return 0;  
}  
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[继承类的 override 介绍]]></title>
        <id>https://blog.myxy.net/ji-cheng-lei-de-override-jie-shao/</id>
        <link href="https://blog.myxy.net/ji-cheng-lei-de-override-jie-shao/">
        </link>
        <updated>2020-11-21T08:45:07.000Z</updated>
        <content type="html"><![CDATA[<p>https://www.cnblogs.com/xinxue/p/5471708.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DisableThreadLibraryCalls 的作用]]></title>
        <id>https://blog.myxy.net/disablethreadlibrarycalls-de-zuo-yong/</id>
        <link href="https://blog.myxy.net/disablethreadlibrarycalls-de-zuo-yong/">
        </link>
        <updated>2020-11-21T03:13:28.000Z</updated>
        <content type="html"><![CDATA[<p>功能:<code>禁用指定的DLL的DLL_THREAD_ATTACH和DLL_THREAD_DETACH通知，这样可以减小某些程序的工作集大小。</code><br>
https://blog.csdn.net/wincearm/article/details/5706605</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[API:字符串拷贝 strdup()]]></title>
        <id>https://blog.myxy.net/strdupzi-fu-chuan-kao-bei/</id>
        <link href="https://blog.myxy.net/strdupzi-fu-chuan-kao-bei/">
        </link>
        <updated>2020-11-21T02:30:00.000Z</updated>
        <content type="html"><![CDATA[<p><code>strdup()</code> 函数是c语言中常用的一种字符串拷贝库函数，一般和<code>free()</code>函数成对出现。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一些常用系统API]]></title>
        <id>https://blog.myxy.net/yi-xie-chang-yong-xi-tong-api/</id>
        <link href="https://blog.myxy.net/yi-xie-chang-yong-xi-tong-api/">
        </link>
        <updated>2020-11-19T05:31:59.000Z</updated>
        <content type="html"><![CDATA[<p>##设置当前目录为运行目录</p>
<pre><code class="language-cpp">	TCHAR run_path[MAX_PATH] = { 0, };
	::GetModuleFileName(NULL, run_path, MAX_PATH);
	(_tcsrchr(run_path, '\\'))[1] = 0;
	::SetCurrentDirectory(run_path);
</code></pre>
]]></content>
    </entry>
</feed>