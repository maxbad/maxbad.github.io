<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.myxy.net</id>
    <title>Maxbad`Blog</title>
    <updated>2020-10-10T12:54:00.691Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.myxy.net"/>
    <link rel="self" href="https://blog.myxy.net/atom.xml"/>
    <subtitle>记录一些东西</subtitle>
    <logo>https://blog.myxy.net/images/avatar.png</logo>
    <icon>https://blog.myxy.net/favicon.ico</icon>
    <rights>All rights reserved 2020, Maxbad`Blog</rights>
    <entry>
        <title type="html"><![CDATA[C++11函数返回多个不同类型的值, std::tuple]]></title>
        <id>https://blog.myxy.net/c11-han-shu-fan-hui-duo-ge-bu-tong-lei-xing-de-zhi-stdtuple/</id>
        <link href="https://blog.myxy.net/c11-han-shu-fan-hui-duo-ge-bu-tong-lei-xing-de-zhi-stdtuple/">
        </link>
        <updated>2020-10-10T12:36:08.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-cpp">std::tuple&lt;bool, std::vector&lt;std::string&gt; &gt; find_urls(const std::string&amp; content) {
    ...
	return std::make_tuple(true, urls);
}

bool error = false;
std::vector&lt;std::string&gt; urls;

std::string content = &quot;...&quot;

std::tie(error, urls) = find_urls(content);
if (error) {
	parse_content(urls)
}

auto result = find_urls(content);
if (std::get&lt;0&gt;(result)) {
	parse_content(std::get&lt;1&gt;(result));
}
</code></pre>
<h1 id="c11新特性-stdtuple">C++11新特性-std::tuple</h1>
<ul>
<li>引入头文件</li>
</ul>
<pre><code class="language-cpp">#include &lt;tuple&gt;
</code></pre>
<ul>
<li>std::tuple初始化</li>
</ul>
<pre><code class="language-cpp">std::tuple&lt;int, std::string, float&gt; t1(10, &quot;Test&quot;, 3.14);
</code></pre>
<blockquote>
<p>这里要注意，不是所有的C++ 11编译器都支持copy-list-initialization的方式。如下代码所示。</p>
</blockquote>
<pre><code class="language-cpp">std::tuple&lt;int, int&gt; foo_tuple() 
{
  return {1, -1};  // Error until N4387
  return std::tuple&lt;int, int&gt;{1, -1}; // Always works
  return std::make_tuple(1, -1); // Always works
}
</code></pre>
<ul>
<li>打印std::tuple</li>
</ul>
<blockquote>
<p>打印std::tuple可以将它的元素逐个打印出来，不过非常繁琐，我们可以通过如下通用的打印函数，帮助我们一次性的将tuple的所有要素打印出来。</p>
</blockquote>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;tuple&gt;
#include &lt;string&gt;
 
// helper function to print a tuple of any size
template&lt;class Tuple, std::size_t N&gt;
struct TuplePrinter {
    static void print(const Tuple&amp; t) 
    {
        TuplePrinter&lt;Tuple, N-1&gt;::print(t);
        std::cout &lt;&lt; &quot;, &quot; &lt;&lt; std::get&lt;N-1&gt;(t);
    }
};
 
template&lt;class Tuple&gt;
struct TuplePrinter&lt;Tuple, 1&gt; {
    static void print(const Tuple&amp; t) 
    {
        std::cout &lt;&lt; std::get&lt;0&gt;(t);
    }
};
 
template&lt;typename... Args, std::enable_if_t&lt;sizeof...(Args) == 0, int&gt; = 0&gt;
void print(const std::tuple&lt;Args...&gt;&amp; t)
{
    std::cout &lt;&lt; &quot;()\n&quot;;
}
 
template&lt;typename... Args, std::enable_if_t&lt;sizeof...(Args) != 0, int&gt; = 0&gt;
void print(const std::tuple&lt;Args...&gt;&amp; t)
{
    std::cout &lt;&lt; &quot;(&quot;;
    TuplePrinter&lt;decltype(t), sizeof...(Args)&gt;::print(t);
    std::cout &lt;&lt; &quot;)\n&quot;;
}
// end helper function
 
int main()
{
    std::tuple&lt;int, std::string, float&gt; t1(10, &quot;Test&quot;, 3.14);
    print(t1);
}
</code></pre>
<p>输出：</p>
<pre><code class="language-cpp">(10, Test, 3.14)
</code></pre>
<ul>
<li>合并多个std::tuple</li>
</ul>
<blockquote>
<p>std::tuple_cat函数可以将多个std::tuple合并为一个tuple。</p>
</blockquote>
<pre><code class="language-cpp">int main()
{
    std::tuple&lt;int, std::string, float&gt; t1(10, &quot;Test&quot;, 3.14);
    int n = 7;
    auto t2 = std::tuple_cat(t1, std::make_tuple(&quot;Foo&quot;, &quot;bar&quot;), t1, std::tie(n));
    n = 42;
    print(t2);
}
</code></pre>
<p>输出：</p>
<pre><code class="language-cpp">(10, Test, 3.14, Foo, bar, 10, Test, 3.14, 42)
</code></pre>
<ul>
<li>std::tuple的解包(unpack)</li>
</ul>
<blockquote>
<p>std::tie能够将std::tuple包含的要素解包(unpack)成单个的对象。</p>
</blockquote>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;tuple&gt;
#include &lt;string&gt;
int main() {
  auto info = std::make_tuple(3.8, 'A', &quot;Lisa Simpson&quot;);
  
  double score = 0.0;
  char grade;
  std::string name;
  std::tie(score, grade, name) = info;
  std::cout &lt;&lt; &quot;score:&quot; &lt;&lt; score &lt;&lt; &quot;, grade:&quot; &lt;&lt; grade &lt;&lt; &quot;, name:&quot; &lt;&lt; name &lt;&lt; std::endl;
return 0;
}
</code></pre>
<p>输出:</p>
<pre><code class="language-cpp">score:3.8, grade:A, name:Lisa Simpson
</code></pre>
<p>std::tie还支持std::pair对象的解包(unpack)。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;tuple&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
int main() {
  auto info = std::make_pair(3.8, &quot;Lisa Simpson&quot;);
  
  double score = 0.0;
  std::string name;
  std::tie(score, name) = info;
  std::cout &lt;&lt; &quot;score:&quot; &lt;&lt; score &lt;&lt; &quot;, name:&quot; &lt;&lt; name &lt;&lt; std::endl;
return 0;
}
</code></pre>
<p>输出:</p>
<pre><code class="language-cpp">score:3.8, name:Lisa Simpson
</code></pre>
<p>当我们不关注tuple中的某个元素时，可以使用std::ignore忽略该元素。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;tuple&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
int main() {
  auto info = std::make_pair(3.8, &quot;Lisa Simpson&quot;);
  
  double score = 0.0;
  std::string name;
  std::tie(score, std::ignore) = info;
  std::cout &lt;&lt; &quot;score:&quot; &lt;&lt; score &lt;&lt; &quot;, name:&quot; &lt;&lt; name &lt;&lt; std::endl;
return 0;
}
</code></pre>
<p>输出:</p>
<pre><code class="language-cpp">score:3.8, name:
</code></pre>
<p>参考资料:<a href="https://zh.cppreference.com/w/cpp/utility/tuple/tuple_cat">https://zh.cppreference.com/w/cpp/utility/tuple/tuple_cat</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11函数返回多个不同类型的值]]></title>
        <id>https://blog.myxy.net/c11-han-shu-fan-hui-duo-ge-bu-tong-lei-xing-de-zhi/</id>
        <link href="https://blog.myxy.net/c11-han-shu-fan-hui-duo-ge-bu-tong-lei-xing-de-zhi/">
        </link>
        <updated>2020-10-10T12:36:08.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-cpp">std::tuple&lt;bool, std::vector&lt;std::string&gt; &gt; find_urls(const std::string&amp; content) {
    ...
	return std::make_tuple(true, urls);
}

bool error = false;
std::vector&lt;std::string&gt; urls;

std::string content = &quot;...&quot;

std::tie(error, urls) = find_urls(content);
if (error) {
	parse_content(urls)
}

auto result = find_urls(content);
if (std::get&lt;0&gt;(result)) {
	parse_content(std::get&lt;1&gt;(result));
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11：参数按成员函数启动线程]]></title>
        <id>https://blog.myxy.net/c11can-shu-an-cheng-yuan-han-shu-qi-dong-xian-cheng/</id>
        <link href="https://blog.myxy.net/c11can-shu-an-cheng-yuan-han-shu-qi-dong-xian-cheng/">
        </link>
        <updated>2020-10-08T06:19:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="使用非静态类成员上述作为线程启动函数">使用非静态类成员上述作为线程启动函数</h2>
<pre><code class="language-cpp">#include &lt;thread&gt;
 
class Task {
public:
  void execute(std::string command) {
    for(int i = 0; i &lt; 5; i++) {
    std::cout&lt;&lt;command&lt;&lt;&quot; :: &quot;&lt;&lt;i&lt;&lt;std::endl;
    }
  }
};
 
int main() {
  Task * taskPtr = new Task();
 
  // Create a thread using member function
  std::thread th(&amp;Task::execute, taskPtr, &quot;Sample Task&quot;);
 
  th.join();
 
  delete taskPtr;
  
  return 0;
}

// 输出如下:
Sample Task :: 0
Sample Task :: 1
Sample Task :: 2
Sample Task :: 3
Sample Task :: 4
</code></pre>
<h2 id="使用静态成员函数作为线程启动函数">使用静态成员函数作为线程启动函数</h2>
<blockquote>
<p>由于静态函数不依赖于任何类对象，所以我们可以直接将静态成员函数作为线程启动函数，而不必传递对象指针。</p>
</blockquote>
<pre><code class="language-cpp">#include &lt;thread&gt;
 
class Task {
public:
    static void test(std::string command) {
        for(int i = 0; i &lt; 5; i++) {
            std::cout&lt;&lt;command&lt;&lt;&quot; :: &quot;&lt;&lt;i&lt;&lt;std::endl;
        }
    }
};
 
int main() {
    // Create a thread using static member function
    std::thread th(&amp;Task::test, &quot;Task&quot;);
 
    th.join();
    return 0;
}

// 输出如下:
Task :: 0
Task :: 1
Task :: 2
Task :: 3
Task :: 4
</code></pre>
<p>参考链接<br>
<a href="https://thispointer.com/c11-start-thread-by-member-function-with-arguments/">https://thispointer.com/c11-start-thread-by-member-function-with-arguments/</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[功能日志回调接口]]></title>
        <id>https://blog.myxy.net/gong-neng-ri-zhi-hui-diao-jie-kou/</id>
        <link href="https://blog.myxy.net/gong-neng-ri-zhi-hui-diao-jie-kou/">
        </link>
        <updated>2020-09-27T07:23:50.000Z</updated>
        <content type="html"><![CDATA[<p>功能日志接口</p>
<pre><code class="language-cpp">// 定义一个输出接口
void on_error(std::function&lt;void(std::string const&amp;)&gt; const&amp; callback) {
    m_err_callback = callback;
}

// 全局变量
std::function&lt;void(std::string const&amp;)&gt; m_err_callback = nullptr; 

// 格式化日志
	void trigger_message(const char* format, ...) {
		if (m_err_callback) {
			std::string text;
			va_list ap = 0;
			va_start(ap, format);
			text.resize(_vscprintf(format, ap) + 1);
			vsprintf_s(&amp;text[0], text.capacity(), format, ap);
			va_end(ap);
			m_err_callback(text.data());
		}
	}

// 使用
trigger_message(&quot;[%s:%d],ConnectRedisCache faild&quot;, __FUNCTION__, __LINE__);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11新特性]]></title>
        <id>https://blog.myxy.net/c11-xin-te-xing/</id>
        <link href="https://blog.myxy.net/c11-xin-te-xing/">
        </link>
        <updated>2020-09-23T00:52:22.000Z</updated>
        <content type="html"><![CDATA[<p>转自:<a href="https://zhuanlan.zhihu.com/p/139515439">https://zhuanlan.zhihu.com/p/139515439</a></p>
<h2 id="auto-decltype">auto &amp; decltype</h2>
<p>https://zhuanlan.zhihu.com/p/137662774</p>
<h2 id="左值右值">左值右值</h2>
<p>https://zhuanlan.zhihu.com/p/137662465</p>
<h2 id="列表初始化">列表初始化</h2>
<p>https://zhuanlan.zhihu.com/p/137851769</p>
<h2 id="stdfunction-stdbind-lambda表达式">std::function &amp; std::bind &amp; lambda表达式</h2>
<p>https://zhuanlan.zhihu.com/p/137884434</p>
<h2 id="模板的改进">模板的改进</h2>
<p>https://zhuanlan.zhihu.com/p/137851516</p>
<h2 id="并发">并发</h2>
<p>https://zhuanlan.zhihu.com/p/137914574</p>
<h2 id="智能指针">智能指针</h2>
<p>https://zhuanlan.zhihu.com/p/137958974</p>
<h2 id="基于范围的for循环">基于范围的for循环</h2>
<pre><code class="language-cpp">vector&lt;int&gt; vec;

for (auto iter = vec.begin(); iter != vec.end(); iter++) { // before c++11
    cout &lt;&lt; *iter &lt;&lt; endl;
}

for (int i : vec) { // c++11基于范围的for循环
    cout &lt;&lt; &quot;i&quot; &lt;&lt; endl;
}
</code></pre>
<h2 id="委托构造函数">委托构造函数</h2>
<pre><code class="language-cpp">struct A {
    A(){}
    A(int a) { a_ = a; }

    A(int a, int b) : A(a) { b_ = b; }

    A(int a, int b, int c) : A(a, b) { c_ = c; }

    int a_;
    int b_;
    int c_;
};
</code></pre>
<h2 id="继承构造函数">继承构造函数</h2>
<blockquote>
<p>只需要使用<code>using Base::Base</code>继承构造函数，就免去了很多重写代码的麻烦。</p>
</blockquote>
<pre><code class="language-cpp">struct Base {
    Base() {}
    Base(int a) { a_ = a; }

    Base(int a, int b) : Base(a) { b_ = b; }

    Base(int a, int b, int c) : Base(a, b) { c_ = c; }

    int a_;
    int b_;
    int c_;
};

struct Derived : Base {
    using Base::Base;
};

int main() {
    Derived a(1, 2, 3);
    return 0;
}
</code></pre>
<h2 id="nullptr">nullptr</h2>
<blockquote>
<p>nullptr是c++11用来表示空指针新引入的常量值，在c++中如果表示空指针语义时建议使用nullptr而不要使用NULL，因为NULL本质上是个int型的0，其实不是个指针。举例：</p>
</blockquote>
<pre><code class="language-cpp">void func(void *ptr) {
    cout &lt;&lt; &quot;func ptr&quot; &lt;&lt; endl;
}

void func(int i) {
    cout &lt;&lt; &quot;func i&quot; &lt;&lt; endl;
}

int main() {
    func(NULL); // 编译失败，会产生二义性
    func(nullptr); // 输出func ptr
    return 0;
}
</code></pre>
<h2 id="final-override">final &amp; override</h2>
<blockquote>
<p>c++11关于继承新增了两个关键字，final用于修饰一个类，表示禁止该类进一步派生和虚函数的进一步重载，override用于修饰派生类中的成员函数，标明该函数重写了基类函数，如果一个函数声明了override但父类却没有这个虚函数，编译报错，使用override关键字可以避免开发者在重写基类函数时无意产生的错误。</p>
</blockquote>
<pre><code class="language-cpp">struct Base {
    virtual void func() {
        cout &lt;&lt; &quot;base&quot; &lt;&lt; endl;
    }
};

struct Derived : public Base{
    void func() override { // 确保func被重写
        cout &lt;&lt; &quot;derived&quot; &lt;&lt; endl;
    }

    void fu() override { // error，基类没有fu()，不可以被重写
        
    }
};
</code></pre>
<pre><code class="language-cpp">struct Base final {
    virtual void func() {
        cout &lt;&lt; &quot;base&quot; &lt;&lt; endl;
    }
};

struct Derived : public Base{ // 编译失败，final修饰的类不可以被继承
    void func() override {
        cout &lt;&lt; &quot;derived&quot; &lt;&lt; endl;
    }

};
</code></pre>
<h2 id="default">default</h2>
<blockquote>
<p>c++11引入default特性，多数时候用于声明构造函数为默认构造函数，如果类中有了自定义的构造函数，编译器就不会隐式生成默认构造函数，如下代码：</p>
</blockquote>
<pre><code class="language-cpp">struct A {
    int a;
    A(int i) { a = i; }
};

int main() {
    A a; // 编译出错
    return 0;
}
</code></pre>
<blockquote>
<p>上面代码编译出错，因为没有匹配的构造函数，因为编译器没有生成默认构造函数，而通过default，程序员只需在函数声明后加上“=default;”，就可将该函数声明为 defaulted 函数，编译器将为显式声明的 defaulted 函数自动生成函数体，如下：</p>
</blockquote>
<pre><code class="language-cpp">struct A {
    A() = default;
    int a;
    A(int i) { a = i; }
};

int main() {
    A a;
    return 0;
}
// 编译通过。
</code></pre>
<h2 id="delete">delete</h2>
<blockquote>
<p>c++中，如果开发人员没有定义特殊成员函数，那么编译器在需要特殊成员函数时候会隐式自动生成一个默认的特殊成员函数，例如拷贝构造函数或者拷贝赋值操作符，如下代码：</p>
</blockquote>
<pre><code class="language-cpp">struct A {
    A() = default;
    int a;
    A(int i) { a = i; }
};

int main() {
    A a1;
    A a2 = a1;  // 正确，调用编译器隐式生成的默认拷贝构造函数
    A a3;
    a3 = a1;  // 正确，调用编译器隐式生成的默认拷贝赋值操作符
}
</code></pre>
<blockquote>
<p>而我们有时候想禁止对象的拷贝与赋值，可以使用delete修饰，如下：</p>
</blockquote>
<pre><code class="language-cpp">struct A {
    A() = default;
    A(const A&amp;) = delete;
    A&amp; operator=(const A&amp;) = delete;
    int a;
    A(int i) { a = i; }
};

int main() {
    A a1;
    A a2 = a1;  // 错误，拷贝构造函数被禁用
    A a3;
    a3 = a1;  // 错误，拷贝赋值操作符被禁用
}
</code></pre>
<blockquote>
<p>delele函数在c++11中很常用，std::unique_ptr就是通过delete修饰来禁止对象的拷贝的。</p>
</blockquote>
<h2 id="explicit">explicit</h2>
<blockquote>
<p>explicit专用于修饰构造函数，表示只能显式构造，不可以被隐式转换，根据代码看explicit的作用：</p>
</blockquote>
<ul>
<li>不用explicit：</li>
</ul>
<pre><code class="language-cpp">struct A {
    A(int value) { // 没有explicit关键字
        cout &lt;&lt; &quot;value&quot; &lt;&lt; endl;
    }
};

int main() {
    A a = 1; // 可以隐式转换
    return 0;
}
</code></pre>
<ul>
<li>使用explicit:</li>
</ul>
<pre><code class="language-cpp">struct A {
    explicit A(int value) {
        cout &lt;&lt; &quot;value&quot; &lt;&lt; endl;
    }
};

int main() {
    A a = 1; // error，不可以隐式转换
    A aa(2); // ok
    return 0;
}
</code></pre>
<h2 id="const">const</h2>
<p>因为要讲后面的constexpr，所以这里简单介绍下const。</p>
<p>const字面意思为只读，可用于定义变量，表示变量是只读的，不可以更改，如果更改，编译期间就会报错。</p>
<p>主要用法如下：</p>
<ul>
<li>用于定义常量，const的修饰的变量不可更改。</li>
</ul>
<pre><code class="language-cpp">const int value = 5;
</code></pre>
<ul>
<li>指针也可以使用const，这里有个小技巧，从右向左读，即可知道const究竟修饰的是指针还是指针所指向的内容。</li>
</ul>
<pre><code class="language-cpp">char *const ptr; // 指针本身是常量
const char* ptr; // 指针指向的变量为常量
</code></pre>
<ul>
<li>在函数参数中使用const，一般会传递类对象时会传递一个const的引用或者指针，这样可以避免对象的拷贝，也可以防止对象被修改。<pre><code class="language-cpp"></code></pre>
</li>
</ul>
<p>class A{};<br>
void func(const A&amp; a);</p>
<pre><code>- const修饰类的成员变量，表示是成员常量，不能被修改，可以在初始化列表中被赋值。
```cpp
class A {
    const int value = 5;
};
class B {
    const int value;
    B(int v) : value(v){}
};
</code></pre>
<ul>
<li>修饰类成员函数，表示在该函数内不可以修改该类的成员变量。</li>
</ul>
<pre><code class="language-cpp">class A{
    void func() const;
};
</code></pre>
<ul>
<li>修饰类对象，类对象只能调用该对象的const成员函数。</li>
</ul>
<pre><code class="language-cpp">class A {
    void func() const;
};
const A a;
a.func();
</code></pre>
<h2 id="constexpr">constexpr</h2>
<blockquote>
<p>constexpr是c++11新引入的关键字，用于编译时的常量和常量函数，这里直接介绍constexpr和const的区别：<br>
两者都代表可读，const只表示read only的语义，只保证了运行时不可以被修改，但它修饰的仍然有可能是个动态变量，而constexpr修饰的才是真正的常量，它会在编译期间就会被计算出来，整个运行过程中都不可以被改变，constexpr可以用于修饰函数，这个函数的返回值会尽可能在编译期间被计算出来当作一个常量，但是如果编译期间此函数不能被计算出来，那它就会当作一个普通函数被处理。如下代码：</p>
</blockquote>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

constexpr int func(int i) {
    return i + 1;
}

int main() {
    int i = 2;
    func(i);// 普通函数
    func(2);// 编译期间就会被计算出来
}
</code></pre>
<h2 id="enum-class">enum class</h2>
<blockquote>
<p>c++11新增有作用域的枚举类型，看代码</p>
</blockquote>
<p>不带作用域的枚举代码：</p>
<pre><code class="language-cpp">enum AColor {
    kRed,
    kGreen,
    kBlue
};

enum BColor {
    kWhite,
    kBlack,
    kYellow
};

int main() {
    if (kRed == kWhite) {
        cout &lt;&lt; &quot;red == white&quot; &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<p>如上代码，不带作用域的枚举类型可以自动转换成整形，且不同的枚举可以相互比较，代码中的红色居然可以和白色比较，这都是潜在的难以调试的bug，而这种完全可以通过有作用域的枚举来规避。</p>
<p>有作用域的枚举代码：</p>
<pre><code class="language-cpp">enum class AColor {
    kRed,
    kGreen,
    kBlue
};

enum class BColor {
    kWhite,
    kBlack,
    kYellow
};

int main() {
    if (AColor::kRed == BColor::kWhite) { // 编译失败
        cout &lt;&lt; &quot;red == white&quot; &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<p>使用带有作用域的枚举类型后，对不同的枚举进行比较会导致编译失败，消除潜在bug，同时带作用域的枚举类型可以选择底层类型，默认是int，可以改成char等别的类型。</p>
<pre><code class="language-cpp">enum class AColor : char {
    kRed,
    kGreen,
    kBlue
};
</code></pre>
<p><em>我们平时编程过程中使用枚举，一定要使用有作用域的枚举取代传统的枚举。</em></p>
<h2 id="非受限联合体">非受限联合体</h2>
<blockquote>
<p>c++11之前union中数据成员的类型不允许有非POD类型，而这个限制在c++11被取消，允许数据成员类型有非POD类型，看代码：</p>
</blockquote>
<pre><code class="language-cpp">struct A {
    int a;
    int *b;
};

union U {
    A a; // 非POD类型 c++11之前不可以这样定义联合体
    int b;
};
</code></pre>
<p>对于什么是POD类型，大家可以自行查下资料，大体上可以理解为对象可以直接memcpy的类型。</p>
<h2 id="sizeof">sizeof</h2>
<p>c++11中sizeof可以用的类的数据成员上，看代码：</p>
<ul>
<li>c++11前：</li>
</ul>
<pre><code class="language-cpp">struct A {
    int data[10];
    int a;
};

int main() {
    A a;
    cout &lt;&lt; &quot;size &quot; &lt;&lt; sizeof(a.data) &lt;&lt; endl;
    return 0;
}
</code></pre>
<ul>
<li>c++11后：</li>
</ul>
<pre><code class="language-cpp">struct A {
    int data[10];
    int a;
};

int main() {
    cout &lt;&lt; &quot;size &quot; &lt;&lt; sizeof(A::data) &lt;&lt; endl;
    return 0;
}
</code></pre>
<p>想知道类中数据成员的大小在c++11中是不是方便了许多，而不需要定义一个对象，在计算对象的成员大小。</p>
<h2 id="assertion">assertion</h2>
<blockquote>
<p>c++11引入static_assert声明，静态断言,用于在编译期间检查，如果第一个参数值为false，则打印message，编译失败。</p>
</blockquote>
<pre><code class="language-cpp">// static_assert(常量表达式，&quot;提示字符串&quot;)
const int n = 5;
static_assert(n &gt; 0, &quot;value must &gt; 0&quot;);
</code></pre>
<h2 id="自定义字面量">自定义字面量</h2>
<p>c++11可以自定义字面量，我们平时c++中都或多或少使用过chrono中的时间，例如：</p>
<pre><code class="language-cpp">std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 100ms
std::this_thread::sleep_for(std::chrono::seconds(100)); // 100s
</code></pre>
<p>其实没必要这么麻烦，也可以这么写：</p>
<pre><code class="language-cpp">std::this_thread::sleep_for(100ms); // c++14里可以这么使用，这里只是举个自定义字面量使用的例子
std::this_thread::sleep_for(100s);
</code></pre>
<p>这就是自定义字面量的使用，示例如下：</p>
<pre><code class="language-cpp">struct mytype {
    unsigned long long value;
};
constexpr mytype operator&quot;&quot; _mytype ( unsigned long long n ) {
    return mytype{n};
}
mytype mm = 123_mytype;
cout &lt;&lt; mm.value &lt;&lt; endl;
</code></pre>
<p>关于自定义字面量，可以看下chrono的源代码，相信大家会有很大收获，需要源码分析chrono的话，可以留言给我。</p>
<h2 id="内存对齐">内存对齐</h2>
<ul>
<li>什么是内存对齐<br>
理论上计算机对于任何变量的访问都可以从任意位置开始，然而实际上系统会对这些变量的存放地址有限制，通常将变量首地址设为某个数N的倍数，这就是内存对齐。</li>
<li>为什么要内存对齐<br>
1: 硬件平台限制，内存以字节为单位，不同硬件平台不一定支持任何内存地址的存取，一般可能以双字节、4字节等为单位存取内存，为了保证处理器正确存取数据，需要进行内存对齐。<br>
2: 提高CPU内存访问速度，一般处理器的内存存取粒度都是N的整数倍，假如访问N大小的数据，没有进行内存对齐，有可能就需要两次访问才可以读取出数据，而进行内存对齐可以一次性把数据全部读取出来，提高效率。<br>
在c++11之前如果想创建内存对齐需要：</li>
</ul>
<pre><code class="language-cpp">void align_cpp11_before()
{
    static char data[sizeof(void *) + sizeof(A)];
    const uintptr_t kAlign = sizeof(void *) - 1;
    char *align_ptr =
        reinterpret_cast&lt;char *&gt;(reinterpret_cast&lt;uintptr_t&gt;(data + kAlign) &amp; ~kAlign);
    A *attr = new (align_ptr) A;
}
</code></pre>
<p>c++11关于内存对齐新增了一些函数：</p>
<pre><code class="language-cpp">void align_cpp11_after()
{
    static std::aligned_storage&lt;sizeof(A),
                                alignof(A)&gt;::type data;
    A *attr = new (&amp;data) A;
}
</code></pre>
<p>还有：alignof()、std::alignment_of()、alignas()，关于内存对齐详情可以看这篇文章:https://zhuanlan.zhihu.com/p/139520591</p>
<h2 id="thread_local">thread_local</h2>
<p>c++11引入thread_local，用thread_local修饰的变量具有thread周期，每一个线程都拥有并只拥有一个该变量的独立实例，一般用于需要保证线程安全的函数中。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;

class A {
   public:
    A() {}
    ~A() {}

    void test(const std::string &amp;name) {
        thread_local int count = 0;
        ++count;
        std::cout &lt;&lt; name &lt;&lt; &quot;: &quot; &lt;&lt; count &lt;&lt; std::endl;
    }
};

void func(const std::string &amp;name) {
    A a1;
    a1.test(name);
    a1.test(name);
    A a2;
    a2.test(name);
    a2.test(name);
}

int main() {
    std::thread(func, &quot;thread1&quot;).join();
    std::thread(func, &quot;thread2&quot;).join();
    return 0;
}

// 输出
// thread1: 1
// thread1: 2
// thread1: 3
// thread1: 4
// thread2: 1
// thread2: 2
// thread2: 3
// thread2: 4
</code></pre>
<p>验证上述说法，对于一个线程私有变量，一个线程拥有且只拥有一个该实例，类似于static。</p>
<h2 id="基础数值类型">基础数值类型</h2>
<p>c++11新增了几种数据类型：long long、char16_t、char32_t等</p>
<h2 id="随机数功能">随机数功能</h2>
<p>c++11关于随机数功能则较之前丰富了很多，典型的可以选择概率分布类型，先看如下代码：</p>
<pre><code class="language-cpp">#include &lt;time.h&gt;

#include &lt;iostream&gt;
#include &lt;random&gt;

using namespace std;

int main() {
    std::default_random_engine random(time(nullptr));

    std::uniform_int_distribution&lt;int&gt; int_dis(0, 100); // 整数均匀分布
    std::uniform_real_distribution&lt;float&gt; real_dis(0.0, 1.0); // 浮点数均匀分布

    for (int i = 0; i &lt; 10; ++i) {
        cout &lt;&lt; int_dis(random) &lt;&lt; ' ';
    }
    cout &lt;&lt; endl;

    for (int i = 0; i &lt; 10; ++i) {
        cout &lt;&lt; real_dis(random) &lt;&lt; ' ';
    }
    cout &lt;&lt; endl;

    return 0;
}

// 输出
// 38 100 93 7 66 0 68 99 41 7
// 0.232202 0.617716 0.959241 0.970859 0.230406 0.430682 0.477359 0.971858 0.0171148 0.64863
</code></pre>
<p>代码中举例的是整数均匀分布和浮点数均匀分布，c++11提供的概率分布类型还有好多，例如伯努利分布、正态分布等，具体可以见最后的参考资料。</p>
<h2 id="正则表达式">正则表达式</h2>
<p>c++11引入了regex库更好的支持正则表达式，见代码：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;regex&gt;
#include &lt;string&gt;

int main() {
    std::string s = &quot;I know, I'll use2 regular expressions.&quot;;
    // 忽略大小写
    std::regex self_regex(&quot;REGULAR EXPRESSIONS&quot;, std::regex_constants::icase); 
    if (std::regex_search(s, self_regex)) {
        std::cout &lt;&lt; &quot;Text contains the phrase 'regular expressions'\n&quot;;
    }

    std::regex word_regex(&quot;(\\w+)&quot;);  // 匹配字母数字等字符
    auto words_begin = std::sregex_iterator(s.begin(), s.end(), word_regex);
    auto words_end = std::sregex_iterator();

    std::cout &lt;&lt; &quot;Found &quot; &lt;&lt; std::distance(words_begin, words_end) &lt;&lt; &quot; words\n&quot;;

    const int N = 6;
    std::cout &lt;&lt; &quot;Words longer than &quot; &lt;&lt; N &lt;&lt; &quot; characters:\n&quot;;
    for (std::sregex_iterator i = words_begin; i != words_end; ++i) {
        std::smatch match = *i;
        std::string match_str = match.str();
        if (match_str.size() &gt; N) {
            std::cout &lt;&lt; &quot;  &quot; &lt;&lt; match_str &lt;&lt; '\n';
        }
    }

    std::regex long_word_regex(&quot;(\\w{7,})&quot;);
    // 超过7个字符的单词用[]包围
    std::string new_s = std::regex_replace(s, long_word_regex, &quot;[$&amp;]&quot;);
    std::cout &lt;&lt; new_s &lt;&lt; '\n';
}
</code></pre>
<h2 id="chrono">chrono</h2>
<p>c++11关于时间引入了chrono库，源于boost，功能强大，chrono主要有三个点：</p>
<ul>
<li>duration</li>
<li>time_point</li>
<li>clocks</li>
</ul>
<h3 id="duration">duration</h3>
<p>std::chrono::duration表示一段时间，常见的单位有s、ms等，示例代码：</p>
<pre><code class="language-cpp">// 拿休眠一段时间举例，这里表示休眠100ms
std::this_thread::sleep_for(std::chrono::milliseconds(100));
</code></pre>
<p>sleep_for里面其实就是std::chrono::duration，表示一段时间，实际是这样：</p>
<pre><code class="language-cpp">typedef duration&lt;int64_t, milli&gt; milliseconds;
typedef duration&lt;int64_t&gt; seconds;
</code></pre>
<p>duration具体模板如下：</p>
<pre><code class="language-cpp">template &lt;class Rep, class Period = ratio&lt;1&gt; &gt; class duration;
</code></pre>
<p>Rep表示一种数值类型，用来表示Period的数量，比如int、float、double，Period是ratio类型，用来表示【用秒表示的时间单位】比如second，常用的duration&lt;Rep, Period&gt;已经定义好了，在std::chrono::duration下：</p>
<ul>
<li>ratio&lt;3600, 1&gt;：hours</li>
<li>ratio&lt;60, 1&gt;：minutes</li>
<li>ratio&lt;1, 1&gt;：seconds</li>
<li>ratio&lt;1, 1000&gt;：microseconds</li>
<li>ratio&lt;1, 1000000&gt;：microseconds</li>
<li>ratio&lt;1, 1000000000&gt;：nanosecons<br>
ratio的具体模板如下：</li>
</ul>
<pre><code class="language-cpp">template &lt;intmax_t N, intmax_t D = 1&gt; class ratio;
</code></pre>
<p>N代表分子，D代表分母，所以ratio表示一个分数，我们可以自定义Period，比如ratio&lt;2, 1&gt;表示单位时间是2秒。</p>
<h3 id="time_point">time_point</h3>
<p>表示一个具体时间点，如2020年5月10日10点10分10秒，拿获取当前时间举例：</p>
<pre><code class="language-cpp">std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; Now() { 
    return std::chrono::high_resolution_clock::now(); 
}
// std::chrono::high_resolution_clock为高精度时钟，下面会提到
</code></pre>
<h3 id="clocks">clocks</h3>
<p>时钟，chrono里面提供了三种时钟：</p>
<ul>
<li>steady_clock</li>
<li>system_clock</li>
<li>high_resolution_clock</li>
</ul>
<h4 id="steady_clock">steady_clock</h4>
<p>稳定的时间间隔，表示相对时间，相对于系统开机启动的时间，无论系统时间如何被更改，后一次调用now()肯定比前一次调用now()的数值大，可用于计时。</p>
<h4 id="system_clock">system_clock</h4>
<p>表示当前的系统时钟，可以用于获取当前时间：<br>
更多查看:https://zhuanlan.zhihu.com/p/139519294</p>
<pre><code class="language-cpp">int main() {
    using std::chrono::system_clock;
    system_clock::time_point today = system_clock::now();

    std::time_t tt = system_clock::to_time_t(today);
    std::cout &lt;&lt; &quot;today is: &quot; &lt;&lt; ctime(&amp;tt);

    return 0;
}
// today is: Sun May 10 09:48:36 2020
</code></pre>
<h3 id="high_resolution_clock">high_resolution_clock</h3>
<p>high_resolution_clock表示系统可用的最高精度的时钟，实际上就是system_clock或者steady_clock其中一种的定义，官方没有说明具体是哪个，不同系统可能不一样，我之前看gcc chrono源码中high_resolution_clock是steady_clock的typedef。</p>
<h2 id="新增数据结构">新增数据结构</h2>
<ul>
<li>std::forward_list：单向链表，只可以前进，在特定场景下使用，相比于std::list节省了内存，提高了性能</li>
</ul>
<pre><code class="language-cpp">std::forward_list&lt;int&gt; fl = {1, 2, 3, 4, 5};
for (const auto &amp;elem : fl) {
    cout &lt;&lt; elem;
}
</code></pre>
<ul>
<li>std::unordered_set：基于hash表实现的set，内部不会排序，使用方法和set类似</li>
<li>std::unordered_map：基于hash表实现的map，内部不会排序，使用方法和set类似</li>
<li>std::array：数组，在越界访问时抛出异常，建议使用std::array替代普通的数组</li>
<li>std::tuple：元组类型，类似pair，但比pair扩展性好</li>
</ul>
<pre><code class="language-cpp">typedef std::tuple&lt;int, double, int, double&gt; Mytuple;
Mytuple t(0, 1, 2, 3);
std::cout &lt;&lt; &quot;0 &quot; &lt;&lt; std::get&lt;0&gt;(t);
std::cout &lt;&lt; &quot;1 &quot; &lt;&lt; std::get&lt;1&gt;(t);
std::cout &lt;&lt; &quot;2 &quot; &lt;&lt; std::get&lt;2&gt;(t);
std::cout &lt;&lt; &quot;3 &quot; &lt;&lt; std::get&lt;3&gt;(t);
</code></pre>
<h2 id="新增算法">新增算法</h2>
<ul>
<li>all_of：检测表达式是否对范围[first, last)中所有元素都返回true，如果都满足，则返回true</li>
</ul>
<pre><code class="language-cpp">std::vector&lt;int&gt; v(10, 2);
if (std::all_of(v.cbegin(), v.cend(), [](int i) { return i % 2 == 0; })) {
  std::cout &lt;&lt; &quot;All numbers are even\n&quot;;
}
</code></pre>
<ul>
<li>any_of：检测表达式是否对范围[first, last)中至少一个元素返回true，如果满足，则返回true，否则返回false，用法和上面一样</li>
<li>none_of：检测表达式是否对范围[first, last)中所有元素都不返回true，如果都不满足，则返回true，否则返回false，用法和上面一样</li>
<li>find_if_not：找到第一个不符合要求的元素迭代器，和find_if相反</li>
<li>copy_if：复制满足条件的元素</li>
<li>itoa：对容器内的元素按序递增</li>
</ul>
<pre><code class="language-cpp">std::vector&lt;int&gt; l(10);
std::iota(l.begin(), l.end(), 19); // 19为初始值
for (auto n : l) std::cout &lt;&lt; n &lt;&lt; ' ';
// 19 20 21 22 23 24 25 26 27 28
</code></pre>
<ul>
<li>minmax_element：返回容器内最大元素和最小元素位置</li>
</ul>
<pre><code class="language-cpp">int main() {
    std::vector&lt;int&gt; v = {3, 9, 1, 4, 2, 5, 9};

    auto result = std::minmax_element(v.begin(), v.end());
    std::cout &lt;&lt; &quot;min element at: &quot; &lt;&lt; *(result.first) &lt;&lt; '\n';
    std::cout &lt;&lt; &quot;max element at: &quot; &lt;&lt; *(result.second) &lt;&lt; '\n';
    return 0;
}
// min element at: 1
// max element at: 9
</code></pre>
<ul>
<li>is_sorted、is_sorted_until：返回容器内元素是否已经排好序。</li>
</ul>
<p>关于c++11的新特性基本上就是这些，相信各位看完一定会有所收获。<br>
参考资料<br>
https://zh.cppreference.com/w/cpp/language/range-for<br>
https://juejin.im/post/5dcaa857e51d457f7675360b<br>
https://zhuanlan.zhihu.com/p/21930436<br>
https://zh.wikipedia.org/wiki/Nullptr<br>
https://zh.wikipedia.org/wiki/Constexpr<br>
https://zh.cppreference.com/w/cpp/language/enum<br>
https://kheresy.wordpress.com/2019/03/27/using-enum-class/<br>
https://zh.cppreference.com/w/cpp/language/union<br>
http://c.biancheng.net/view/7165.html<br>
https://zhuanlan.zhihu.com/p/77585472<br>
http://www.cplusplus.com/reference/random/<br>
https://zh.cppreference.com/w/cpp/regex<br>
https://www.cnblogs.com/jwk000/p/3560086.html<br>
https://zh.cppreference.com/w/cpp/algorithm/all_any_none_of</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis2]]></title>
        <id>https://blog.myxy.net/redis2/</id>
        <link href="https://blog.myxy.net/redis2/">
        </link>
        <updated>2020-09-22T01:42:16.000Z</updated>
        <content type="html"><![CDATA[<h1 id="结构类型">结构类型</h1>
<table>
<thead>
<tr>
<th>结构类型</th>
<th style="text-align:left">结构存储的值</th>
<th style="text-align:left">结构的读写能力</th>
</tr>
</thead>
<tbody>
<tr>
<td>STRING</td>
<td style="text-align:left">可以是字符串,整数或者浮点数</td>
<td style="text-align:left">对整个字符串或者字符串的其中一部分执行操作;对整数和浮点数执行自增(increment)或者自减(decrement)操作</td>
</tr>
<tr>
<td>LIST</td>
<td style="text-align:left">一个链表,链表上的每个节点都包含了一个字符串</td>
<td style="text-align:left">从链表的两端推入或者弹出元素;根据偏移量对链表进行修剪(trim);读取单个或者多个元素;根据值查找或者移除元素</td>
</tr>
<tr>
<td>SET</td>
<td style="text-align:left">包含字符串的无序收集器(unordered collection),并且被包含的每个字符串都是独一无二,各不相同的</td>
<td style="text-align:left">添加,获取,移除单个元素;检查一个元素是否存在于集合中,计算交集,并集,差集;从集合里面随机获取元素</td>
</tr>
<tr>
<td>HASH</td>
<td style="text-align:left">包含键值对的无序散列表</td>
<td style="text-align:left">添加,获取,移除单个键值对;获取所有键值对</td>
</tr>
<tr>
<td>ZSET(有序集合)</td>
<td style="text-align:left">字符串成员(member)与浮点数分值(score)之间的有序映射,元素的排列顺序由分值的大小决定</td>
<td style="text-align:left">添加,获取,删除单个元素;根据分值范围(fange)或者成员来获取元素</td>
</tr>
</tbody>
</table>
<h2 id="string-字符串">STRING (字符串)</h2>
<blockquote>
<p>可存储: 字节串,整数,浮点数</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://blog.myxy.net/post-images/1600741899944.jpg" alt="" loading="lazy"></figure>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">行为</th>
<th style="text-align:left">其他</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td style="text-align:left">获取存储在给定键中的值</td>
<td style="text-align:left">不存在返回nil</td>
</tr>
<tr>
<td>SET</td>
<td style="text-align:left">设置存储在给定键中的值</td>
<td style="text-align:left">执行成功返回OK</td>
</tr>
<tr>
<td>DEL</td>
<td style="text-align:left">删除存储在给定键中的值</td>
<td style="text-align:left">这个命令可以用于所有类型,成功删除的值的数量</td>
</tr>
<tr>
<td>INCR</td>
<td style="text-align:left">将键存储的值加上1</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>DECR</td>
<td style="text-align:left">将键存储的值减去1</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>INCRBY</td>
<td style="text-align:left">将键存储的值加上整数 amount</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>DECRBY</td>
<td style="text-align:left">将键存储的值减去整数 amount</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>INCRBYFPOAT</td>
<td style="text-align:left">将键存储的值加上浮点数 amount</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h2 id="list-列表有序">LIST (列表)(有序)</h2>
<blockquote>
<p>列表结构可以<code>有序</code>地存储多个字符串,可重复<br>
<img src="https://blog.myxy.net/post-images/1600741872621.jpg" alt="" loading="lazy"></p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">行为</th>
<th style="text-align:left">其他</th>
</tr>
</thead>
<tbody>
<tr>
<td>RPUSH</td>
<td style="text-align:left">将给定值推入列表的右端</td>
<td style="text-align:left">返回列表当前的长度</td>
</tr>
<tr>
<td>LPUSH</td>
<td style="text-align:left">将一个或多个值推入列表的左端</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>LRANGE</td>
<td style="text-align:left">获取列表在给定范围上的所有值</td>
<td style="text-align:left">从0到-1范围可以去除全部列表</td>
</tr>
<tr>
<td>LINDEX</td>
<td style="text-align:left">获取列表在给定位置上的单个元素</td>
<td style="text-align:left">取单个</td>
</tr>
<tr>
<td>LPOP</td>
<td style="text-align:left">从列表的左端弹出一个值,并返回被弹出的值</td>
<td style="text-align:left">被弹出的元素将不再存在于列表</td>
</tr>
<tr>
<td>RPOP</td>
<td style="text-align:left">移除并返回列表最右端的元素</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>LTRIM</td>
<td style="text-align:left">对列表进行修剪,只保留从start偏移量到end偏移量范围内的元素,其中偏移量为start和偏移量为end的元素也会被保留</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>BLPOP</td>
<td style="text-align:left">从第一个非空列表中弹出位于最左端的元素,或者在timeout秒之内阻塞并等待可弹出的元素出现</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>BRPOP</td>
<td style="text-align:left">从第一个非空列表中弹出位于最右端的元素,或者在timeout秒之内阻塞并等待可弹出的元素出现</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>RPOPLPUSH</td>
<td style="text-align:left">从source-key列表中弹出位于最右端的元素,然后将这个元素推入dest-key列表的最左端,并向用户返回这个元素</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>BRPOPLPUSH</td>
<td style="text-align:left">从source-key列表中弹出位于最右端的元素,然后将这个元素推入dest-key列表的最左端,并向用户返回这个元素;如果source-key为空,那么在timeout秒之内阻塞并等待可弹出的元素出现</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h2 id="set-集合无序">SET (集合)(无序)</h2>
<blockquote>
<p>通过散列表来保证自己存储的每个字符串都是各不相同的(这些散列表只有键,但没有与键相关联的值),<code>无序</code>方式存储元素<br>
<img src="https://blog.myxy.net/post-images/1600741849673.jpg" alt="" loading="lazy"></p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">行为</th>
<th style="text-align:left">其他</th>
</tr>
</thead>
<tbody>
<tr>
<td>SADD</td>
<td style="text-align:left">将给定元素添加到集合</td>
<td style="text-align:left">返回1表示成功,返回0表示已存在</td>
</tr>
<tr>
<td>SMEMBERS</td>
<td style="text-align:left">返回集合包含的所有元素</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>SISMEMBER</td>
<td style="text-align:left">检查给定元素是否存在于集合中</td>
<td style="text-align:left">返回1表示存在,返回0表示不存在</td>
</tr>
<tr>
<td>SREM</td>
<td style="text-align:left">如果给定的元素存在于集合中,那么移除这个元素</td>
<td style="text-align:left">返回被移除元素的数量</td>
</tr>
<tr>
<td>SINTER</td>
<td style="text-align:left">交集</td>
<td style="text-align:left">返回那些同事存在于所有集合中的元素</td>
</tr>
<tr>
<td>SUNION</td>
<td style="text-align:left">并集</td>
<td style="text-align:left">返回那些至少存在于一个集合中的元素</td>
</tr>
<tr>
<td>SDIFF</td>
<td style="text-align:left">差集</td>
<td style="text-align:left">返回那些存在于第一个集合,但不存在与其他集合中的元素</td>
</tr>
<tr>
<td>SCARD</td>
<td style="text-align:left">返回集合包含的元素的数量</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>SRANDMEMBER</td>
<td style="text-align:left">从集合里面随机返回一个或多个元素,单count为正数时,命令返回的随机元素不会重复;当count为负数时.命令返回的随机数可能会出现重复</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>SPOP</td>
<td style="text-align:left">随机移除集合中的一个元素,并返回被移除的元素</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>SMOVE</td>
<td style="text-align:left">如果集合source-key包含元素item,那么从集合source-key里面移除元素item.,并将元素item添加到集合dest-key中;如果item被成功移除,那么返回1否则返回0</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>SDIFFSTORE</td>
<td style="text-align:left">将那些存在于第一个集合但并不存在于其他集合中的元素(差集运算)存储到dest-key键里面</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>SINTERSTORE</td>
<td style="text-align:left">将那些同时存在于所有集合的元素(交集运算)存储到dest-key键里面</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>SUNIONSTORE</td>
<td style="text-align:left">将那些是少存在于一个集合中的元素(并集计算)存储到dest-key键里面</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h2 id="hash-散列">HASH (散列)</h2>
<blockquote>
<p>可以存储多个键值对之间的映射,值可以是字符串也可以是数值,并且数值可以自增或自减操作.<br>
<img src="https://blog.myxy.net/post-images/1600741809702.jpg" alt="" loading="lazy"></p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">行为</th>
<th style="text-align:left">其他</th>
</tr>
</thead>
<tbody>
<tr>
<td>HSET</td>
<td style="text-align:left">在散列里面关联起给定的键值对</td>
<td style="text-align:left">1表示成功,0表示已存在</td>
</tr>
<tr>
<td>HGET</td>
<td style="text-align:left">获取指定散列键的值</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>HGETALL</td>
<td style="text-align:left">获取散列包含的所有键值对</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>HDEL</td>
<td style="text-align:left">如果给定的键存在于散列里面,那么移除这个键</td>
<td style="text-align:left">1表示成功,0表示不存在</td>
</tr>
<tr>
<td>HMGET</td>
<td style="text-align:left">从散列里面获取一个或多个键的值</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>HMSET</td>
<td style="text-align:left">为散列里面的一个或多个键设置值</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>HDEL</td>
<td style="text-align:left">删除散列里面的一个或多个键值对,返回成功找到并删除的键值对数量</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>HLEN</td>
<td style="text-align:left">返回散列包含的键值对数量</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>HEXISTS</td>
<td style="text-align:left">检查给定键是否存在于散列中</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>HKEYS</td>
<td style="text-align:left">获取散列包含的所有键</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>HVALS</td>
<td style="text-align:left">获取散列包含的所有值</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>HGETALL</td>
<td style="text-align:left">获取散列包含的所有键值对</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>HINCRBY</td>
<td style="text-align:left">将键key存储的值加上整数increment</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>HINCRBYFLOAT</td>
<td style="text-align:left">将键key存储的值加上浮点数increment</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h2 id="zset-有序集合">ZSET (有序集合)</h2>
<blockquote>
<p>有序集合的键被称为成员(member),每个成员都是各不相同的,有序集合的值被称为分值(score),分值必须为浮点数,有序集合是Redis里面唯一一个既可以根据成员访问元素(散列一样),有可以根据分值以及分值的排序来访问元素的结构<br>
<img src="https://blog.myxy.net/post-images/1600742459363.jpg" alt="" loading="lazy"></p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">行为</th>
<th style="text-align:left">其他</th>
</tr>
</thead>
<tbody>
<tr>
<td>ZADD</td>
<td style="text-align:left">将一个带有给定分值的成员添加到有序集合里面</td>
<td style="text-align:left">返回添加元素的数量</td>
</tr>
<tr>
<td>ZRANGE</td>
<td style="text-align:left">返回有序集合中排名介于start和stop之间的成员,如果给定了可选的withsocores选项,那么命令会将成员的分值也一并返回</td>
<td style="text-align:left">从0开始-1结束可返回全部</td>
</tr>
<tr>
<td>ZRANGEBYSCORE</td>
<td style="text-align:left">获取有序集合在给定分值范围内的所有元素</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>ZREM</td>
<td style="text-align:left">如果给定成员存在于有序集合,那么移除这个成员</td>
<td style="text-align:left">返回被移除元素的数量</td>
</tr>
<tr>
<td>ZCARD</td>
<td style="text-align:left">返回有序集合包含的成员数量</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>ZINCRBY</td>
<td style="text-align:left">返回分值介于min和max之间的成员数量</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>ZRANK</td>
<td style="text-align:left">返回成员member在有序集合中的排名</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>ZSCORE</td>
<td style="text-align:left">妇女和成员member的分值</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>ZREVRANK</td>
<td style="text-align:left">返回有序集合里成员member的排名.成员按照分值从大到小排列</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>ZREVRANGE</td>
<td style="text-align:left">返回有序集合给定排名范围内的成员,成员按照分值从大到小排序</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>ZRANGEBYSOCRE</td>
<td style="text-align:left">返回有序集合中,分值介于min和max之间的所有成员</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>ZREVRANGEBYSOCRE</td>
<td style="text-align:left">获取有序集合中分值介于min和max之间的所有成员,并按照分值从大到小的顺序来返回它们</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>ZREMRANGEBYRANK</td>
<td style="text-align:left">移除有序集合中排名界面start和stop之间的所有成员</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>ZREMRANGEBYSCORE</td>
<td style="text-align:left">移除有序集合中分值介于min和max之间的所有成员</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>ZINTERSTORE</td>
<td style="text-align:left">对给定的有序集合执行类似于集合的交集运算</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>ZUNIONSTORE</td>
<td style="text-align:left">对给定的有序集合执行类似于集合的并集运算</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h2 id="发布于订阅">发布于订阅</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">示例</th>
<th style="text-align:left">行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>SUBSCRIBE</td>
<td style="text-align:left">SUBSCRIBE changel [changel ...]</td>
<td style="text-align:left">订阅给定的一个或多个频道</td>
</tr>
<tr>
<td>UNSUBSCRIBE</td>
<td style="text-align:left">UNSUBSCRIBE [changel [changel ...]]</td>
<td style="text-align:left">退订给定的一个或多个频道,如果执行时没有给定任何频道,那么推定所有频道</td>
</tr>
<tr>
<td>PUBLISH</td>
<td style="text-align:left">PUBLIST changel message</td>
<td style="text-align:left">向给定频道发送消息</td>
</tr>
<tr>
<td>PSUBSCRIBE</td>
<td style="text-align:left">PSUBSCRIBE pattern [pattern ...]</td>
<td style="text-align:left">订阅与给定模式相匹配的所有频道</td>
</tr>
<tr>
<td>PUNSUBSCRIBE</td>
<td style="text-align:left">PUNSUBSCRIBE [pattern [pattern ...]]</td>
<td style="text-align:left">退订给定的模式,如果执行时没有给定任何模式,那么退订所有模式</td>
</tr>
</tbody>
</table>
<h2 id="其他命令">其他命令</h2>
<h3 id="排序">排序</h3>
<p>SORT命令不仅可以对列表进行排序,还可以对集合进行排序,然后返回一个列表形式的排序结果,</p>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">示例</th>
<th style="text-align:left">行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>SORT</td>
<td style="text-align:left">SORT source-key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC or DESC] [ALPHA] [STORE dest-key]</td>
<td style="text-align:left">根据给定的选项,对输入列表,集合或者有序集合进行排序,然后返回或者存储排序的结果</td>
</tr>
</tbody>
</table>
<h3 id="事务">事务</h3>
<blockquote>
<p>用户在不被打断的情况下对多个键执行操作</p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>WATCH</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>MULTI</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>EXEC</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>UNWATCH</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>DISCARD</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h3 id="键的过期时间">键的过期时间</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">示例</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>PERSIST</td>
<td style="text-align:left">PERSIST key-name</td>
<td style="text-align:left">移除键的国企时间</td>
</tr>
<tr>
<td>TTL</td>
<td style="text-align:left">TTL key-name</td>
<td style="text-align:left">查看给定键距离过期还有多少秒</td>
</tr>
<tr>
<td>EXPIRE</td>
<td style="text-align:left">EXPIRE key-name seconds</td>
<td style="text-align:left">让给定键在指定的秒数之后过期</td>
</tr>
<tr>
<td>EXPIREAT</td>
<td style="text-align:left">EXPIREAT key-name timestamp</td>
<td style="text-align:left">将给定键的过期时间设置为给定的unix时间戳</td>
</tr>
<tr>
<td>PTTL</td>
<td style="text-align:left">PTTL key-name</td>
<td style="text-align:left">查看给定键距离过期时间还有多少毫秒</td>
</tr>
<tr>
<td>PEXPIRE</td>
<td style="text-align:left">PEXPIRE key-name milliseconds</td>
<td style="text-align:left">让给定键在指定的毫秒数之后过期</td>
</tr>
<tr>
<td>PEXPIREAT</td>
<td style="text-align:left">PEXPIREAT key-name timestamp-milliseconds</td>
<td style="text-align:left">将一个毫秒级精度的unix时间戳设置为给定键的过期时间</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[布隆过滤器]]></title>
        <id>https://blog.myxy.net/bu-long-guo-lu-qi/</id>
        <link href="https://blog.myxy.net/bu-long-guo-lu-qi/">
        </link>
        <updated>2020-09-19T13:21:18.000Z</updated>
        <content type="html"><![CDATA[<p>https://blog.csdn.net/y1054765649/article/details/88712339</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[VS  自定义 clang-format 格式化代码格式]]></title>
        <id>https://blog.myxy.net/vs-zi-ding-yi-clang-format-ge-shi-hua-dai-ma-ge-shi/</id>
        <link href="https://blog.myxy.net/vs-zi-ding-yi-clang-format-ge-shi-hua-dai-ma-ge-shi/">
        </link>
        <updated>2020-09-19T06:52:53.000Z</updated>
        <content type="html"><![CDATA[<p>将<code>.clang-format</code> 文件放到工程根目录</p>
<pre><code class="language-python">ColumnLimit:     0   # 这样就不会限制行宽，自动折行了
IndentWidth:     4
</code></pre>
<p>官方文档:http://clang.llvm.org/docs/ClangFormatStyleOptions.html<br>
中文文档: https://www.cnblogs.com/PaulpauL/p/5929753.html</p>
<h2 id="示例文件">示例文件:</h2>
<pre><code class="language-python">---
Language:        Cpp

AccessModifierOffset:                                       -2
AlignAfterOpenBracket:                                      DontAlign
AlignConsecutiveAssignments:                                true
AlignConsecutiveDeclarations:                               false
AlignEscapedNewlinesLeft:                                   false
AlignOperands:                                              true
AlignTrailingComments:                                      true
AllowAllParametersOfDeclarationOnNextLine:                  false
AllowShortBlocksOnASingleLine:                              true
AllowShortCaseLabelsOnASingleLine:                          true
AllowShortFunctionsOnASingleLine:                           All
AllowShortIfStatementsOnASingleLine:                        true
AllowShortLoopsOnASingleLine:                               true
AlwaysBreakAfterDefinitionReturnType:                       All
AlwaysBreakAfterReturnType:                                 AllDefinitions
AlwaysBreakBeforeMultilineStrings:                          false
AlwaysBreakTemplateDeclarations:                            true
BinPackArguments:                                           true
BinPackParameters:                                          true
# Ignored if BreakBeforeBraces different from Custom
BraceWrapping:
  AfterClass:                                               false
  AfterControlStatement:                                    false
  AfterEnum:                                                false
  AfterFunction:                                            false
  AfterNamespace:                                           false
  AfterObjCDeclaration:                                     false
  AfterStruct:                                              false
  AfterUnion:                                               false
  BeforeCatch:                                              true
  BeforeElse:                                               true
  IndentBraces:                                             false
BreakBeforeBinaryOperators:                                 NonAssignment
BreakBeforeBraces:                                          Custom
BreakBeforeTernaryOperators:                                true
BreakConstructorInitializersBeforeComma:                    true
# Ignored in C++
BreakAfterJavaFieldAnnotations:                             false
BreakStringLiterals:                                        false
ColumnLimit:                                                0
CommentPragmas:                                             '.*'
ConstructorInitializerAllOnOneLineOrOnePerLine:             true
ConstructorInitializerIndentWidth:                          0
ContinuationIndentWidth:                                    2
Cpp11BracedListStyle:                                       true
DerivePointerAlignment:                                     false
DisableFormat:                                              false
ExperimentalAutoDetectBinPacking:                           false
ForEachMacros:                                              [ foreach, Q_FOREACH, BOOST_FOREACH ]
IncludeCategories:
  - Regex:                                                  'cpp_redis'
    Priority:                                               1
IncludeIsMainRegex:                                         '$'
IndentCaseLabels:                                           false
IndentWidth:                                                2
IndentWrappedFunctionNames:                                 false
# Ignored in C++
JavaScriptQuotes:                                           Leave
# Ignored in C++
JavaScriptWrapImports:                                      true
KeepEmptyLinesAtTheStartOfBlocks:                           true
MacroBlockBegin:                                            ''
MacroBlockEnd:                                              ''
MaxEmptyLinesToKeep:                                        2
NamespaceIndentation:                                       None
# Ignored in C++
ObjCBlockIndentWidth:                                       2
# Ignored in C++
ObjCSpaceAfterProperty:                                     false
# Ignored in C++
ObjCSpaceBeforeProtocolList:                                true
PenaltyBreakBeforeFirstCallParameter:                       19
PenaltyBreakComment:                                        300
PenaltyBreakFirstLessLess:                                  120
PenaltyBreakString:                                         1000
PenaltyExcessCharacter:                                     1000000
PenaltyReturnTypeOnItsOwnLine:                              60
PointerAlignment:                                           Left
ReflowComments:                                             true
SortIncludes:                                               true
SpaceAfterCStyleCast:                                       true
SpaceBeforeAssignmentOperators:                             true
SpaceBeforeParens:                                          ControlStatements
SpaceInEmptyParentheses:                                    false
SpacesBeforeTrailingComments:                               1
SpacesInAngles:                                             false
SpacesInContainerLiterals:                                  true
SpacesInCStyleCastParentheses:                              false
SpacesInParentheses:                                        false
SpacesInSquareBrackets:                                     false
Standard:                                                   Cpp11
TabWidth:                                                   8
UseTab:                                                     Never
...
</code></pre>
<h2 id="说明">说明</h2>
<pre><code class="language-python">
---
# 语言: None, Cpp, Java, JavaScript, ObjC, Proto, TableGen, TextProto #
Language:	Cpp
# 基础格式 #
BasedOnStyle: Google
# 访问说明符(public、private等)的偏移 #
AccessModifierOffset: -4

# 开括号(开圆括号、开尖括号、开方括号)后的对齐: Align, DontAlign, AlwaysBreak(总是在开括号后换行)
AlignAfterOpenBracket:	Align
# 连续赋值时，对齐所有等号
AlignConsecutiveAssignments:	true
# 连续声明时，对齐所有声明的变量名
AlignConsecutiveDeclarations:	true
# 左对齐逃脱换行(使用反斜杠换行)的反斜杠
AlignEscapedNewlinesLeft:	true
# 水平对齐二元和三元表达式的操作数
AlignOperands:	true
# 对齐连续的尾随的注释
AlignTrailingComments:	true
# 允许函数声明的所有参数在放在下一行
AllowAllParametersOfDeclarationOnNextLine:	true
# 允许短的块放在同一行
AllowShortBlocksOnASingleLine:	false
# 允许短的case标签放在同一行
AllowShortCaseLabelsOnASingleLine:	false
# 允许短的函数放在同一行: None, InlineOnly(定义在类中), Empty(空函数), Inline(定义在类中，空函数), All
AllowShortFunctionsOnASingleLine:	Empty
# 允许短的if语句保持在同一行
AllowShortIfStatementsOnASingleLine:	false
# 允许短的循环保持在同一行
AllowShortLoopsOnASingleLine:	false
# 总是在定义返回类型后换行(deprecated)
AlwaysBreakAfterDefinitionReturnType:	None
# 总是在返回类型后换行: None, All, TopLevel(顶级函数，不包括在类中的函数), 
#   AllDefinitions(所有的定义，不包括声明), TopLevelDefinitions(所有的顶级函数的定义)
AlwaysBreakAfterReturnType:	None
# 总是在多行string字面量前换行
AlwaysBreakBeforeMultilineStrings:	false
# 总是在template声明后换行
AlwaysBreakTemplateDeclarations:	false
# false表示函数实参要么都在同一行，要么都各自一行
BinPackArguments:	true
# false表示所有形参要么都在同一行，要么都各自一行
BinPackParameters:	true
# 大括号换行，只有当BreakBeforeBraces设置为Custom时才有效
BraceWrapping:   
  # class定义后面
  AfterClass:	false
  # 控制语句后面
  AfterControlStatement:	false
  # enum定义后面
  AfterEnum:	false
  # 函数定义后面
  AfterFunction:	false
  # 命名空间定义后面
  AfterNamespace:	false
  # ObjC定义后面
  AfterObjCDeclaration:	false
  # struct定义后面
  AfterStruct:	false
  # union定义后面
  AfterUnion:	false
  # catch之前
  BeforeCatch:	true
  # else之前
  BeforeElse:	true
  # 缩进大括号
  IndentBraces:	false
# 在二元运算符前换行: None(在操作符后换行), NonAssignment(在非赋值的操作符前换行), All(在操作符前换行)
BreakBeforeBinaryOperators:	NonAssignment
# 在大括号前换行: Attach(始终将大括号附加到周围的上下文), Linux(除函数、命名空间和类定义，与Attach类似), 
#   Mozilla(除枚举、函数、记录定义，与Attach类似), Stroustrup(除函数定义、catch、else，与Attach类似), 
#   Allman(总是在大括号前换行), GNU(总是在大括号前换行，并对于控制语句的大括号增加额外的缩进), WebKit(在函数前换行), Custom
#   注：这里认为语句块也属于函数
BreakBeforeBraces:	Custom
# 在三元运算符前换行
BreakBeforeTernaryOperators:	true
# 在构造函数的初始化列表的逗号前换行
BreakConstructorInitializersBeforeComma:	false
# 每行字符的限制，0表示没有限制
ColumnLimit:	200
# 描述具有特殊意义的注释的正则表达式，它不应该被分割为多行或以其它方式改变
CommentPragmas:	'^ IWYU pragma:'
# 构造函数的初始化列表要么都在同一行，要么都各自一行
ConstructorInitializerAllOnOneLineOrOnePerLine:	false
# 构造函数的初始化列表的缩进宽度
ConstructorInitializerIndentWidth:	4
# 延续的行的缩进宽度
ContinuationIndentWidth:	4
# 去除C++11的列表初始化的大括号{后和}前的空格
Cpp11BracedListStyle:	false
# 继承最常用的指针和引用的对齐方式
DerivePointerAlignment:	false
# 关闭格式化
DisableFormat:	false
# 自动检测函数的调用和定义是否被格式为每行一个参数(Experimental)
ExperimentalAutoDetectBinPacking:	false
# 需要被解读为foreach循环而不是函数调用的宏
ForEachMacros:	[ foreach, Q_FOREACH, BOOST_FOREACH ]
# 对#include进行排序，匹配了某正则表达式的#include拥有对应的优先级，匹配不到的则默认优先级为INT_MAX(优先级越小排序越靠前)，
#   可以定义负数优先级从而保证某些#include永远在最前面
IncludeCategories: 
  - Regex:	'^&quot;(llvm|llvm-c|clang|clang-c)/'
    Priority:	2
  - Regex:	'^(&lt;|&quot;(gtest|isl|json)/)'
    Priority:	3
  - Regex:	'.*'
    Priority:	1
# 缩进case标签
IndentCaseLabels:	false

# 缩进宽度 #
IndentWidth: 4

# 函数返回类型换行时，缩进函数声明或函数定义的函数名
IndentWrappedFunctionNames:	false
# 保留在块开始处的空行
KeepEmptyLinesAtTheStartOfBlocks:	true
# 开始一个块的宏的正则表达式
MacroBlockBegin:	''
# 结束一个块的宏的正则表达式
MacroBlockEnd:	''
# 连续空行的最大数量
MaxEmptyLinesToKeep:	1
# 命名空间的缩进: None, Inner(缩进嵌套的命名空间中的内容), All
NamespaceIndentation:	Inner
# 使用ObjC块时缩进宽度
ObjCBlockIndentWidth:	4
# 在ObjC的@property后添加一个空格
ObjCSpaceAfterProperty:	false
# 在ObjC的protocol列表前添加一个空格
ObjCSpaceBeforeProtocolList:	true
# 在call(后对函数调用换行的penalty
PenaltyBreakBeforeFirstCallParameter:	19
# 在一个注释中引入换行的penalty
PenaltyBreakComment:	300
# 第一次在&lt;&lt;前换行的penalty
PenaltyBreakFirstLessLess:	120
# 在一个字符串字面量中引入换行的penalty
PenaltyBreakString:	1000
# 对于每个在行字符数限制之外的字符的penalty
PenaltyExcessCharacter:	1000000
# 将函数的返回类型放到它自己的行的penalty
PenaltyReturnTypeOnItsOwnLine:	60
# 指针和引用的对齐: Left, Right, Middle
PointerAlignment:	Left
# 允许重新排版注释
ReflowComments:	true
# 允许排序#include
SortIncludes:	true
# 在C风格类型转换后添加空格
SpaceAfterCStyleCast:	false
# 在赋值运算符之前添加空格
SpaceBeforeAssignmentOperators:	true
# 开圆括号之前添加一个空格: Never, ControlStatements, Always
SpaceBeforeParens:	ControlStatements
# 在空的圆括号中添加空格
SpaceInEmptyParentheses:	false
# 在尾随的评论前添加的空格数(只适用于//)
SpacesBeforeTrailingComments:	2
# 在尖括号的&lt;后和&gt;前添加空格
SpacesInAngles:	true
# 在容器(ObjC和JavaScript的数组和字典等)字面量中添加空格
SpacesInContainerLiterals:	true
# 在C风格类型转换的括号中添加空格
SpacesInCStyleCastParentheses:	true
# 在圆括号的(后和)前添加空格
SpacesInParentheses:	true
# 在方括号的[后和]前添加空格，lamda表达式和未指明大小的数组的声明不受影响
SpacesInSquareBrackets:	true
# 标准: Cpp03, Cpp11, Auto
Standard:	Cpp11
# tab宽度
TabWidth:	4
# 使用tab字符: Never, ForIndentation, ForContinuationAndIndentation, Always
UseTab:	Never
...
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis]]></title>
        <id>https://blog.myxy.net/redis/</id>
        <link href="https://blog.myxy.net/redis/">
        </link>
        <updated>2020-09-19T05:59:55.000Z</updated>
        <content type="html"><![CDATA[<p>官方命令手册:<a href="https://oss.redislabs.com/redisearch/Commands.html">https://oss.redislabs.com/redisearch/Commands.html</a><br>
中文手册:<a href="https://www.php.cn/redis/redis-commands.html">https://www.php.cn/redis/redis-commands.html</a><br>
命令参考:<a href="http://doc.redisfans.com/index.html">http://doc.redisfans.com/index.html</a><br>
命令手册1:<a href="https://www.redis.net.cn/order/">https://www.redis.net.cn/order/</a><br>
命令手册2:<a href="https://www.redis.com.cn/commands/">https://www.redis.com.cn/commands/</a></p>
<table>
<thead>
<tr>
<th>角色</th>
<th style="text-align:left">redis.conf</th>
<th style="text-align:left">权限说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>超户</td>
<td style="text-align:left">requirepass</td>
<td style="text-align:left">所有功能</td>
</tr>
<tr>
<td>普通</td>
<td style="text-align:left">requireuserpass</td>
<td style="text-align:left">不能进程管理类命令,如shutdown</td>
</tr>
<tr>
<td>只读</td>
<td style="text-align:left">requirereaduserpass</td>
<td style="text-align:left">在普通用户基础上,进一步限制只能进行读操作,没有script命令权限</td>
</tr>
</tbody>
</table>
<h2 id="普通用户不能进行的操作有">普通用户不能进行的操作有：</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>INFO commandstats</td>
<td style="text-align:left">查看所有命令统计</td>
</tr>
<tr>
<td>CONFIG RESETSTAT</td>
<td style="text-align:left">重置统计</td>
</tr>
<tr>
<td>save</td>
<td style="text-align:left">SAVE命令执行一个同步保存操作,将当前Redis实列的所有数据快照(snapshot)以RDB文件的形式保存到硬盘</td>
</tr>
<tr>
<td>bgsave</td>
<td style="text-align:left">在后台异步(Asynchronously)保存当前数据库的数据到磁盘</td>
</tr>
<tr>
<td>bgrrwriteaof</td>
<td style="text-align:left">执行一个AOF文件重写操作,重写会创建一个当前AOF文件的体积优化版本,即使BGREWRITEAOF执行失败,也不会有任何数据丢失,因为旧的AOF文件在BGREWRITEAOF成功之前不会被修改</td>
</tr>
<tr>
<td>shutdown</td>
<td style="text-align:left">停止所有客户端,如果有至少一个保存点在等待,执行SAVE命令,如果AOF选项被打开,更新AOF文件,关闭Redis服务器(server)</td>
</tr>
<tr>
<td>sync</td>
<td style="text-align:left">用户复制功能(replication)的内部命令</td>
</tr>
<tr>
<td>psync</td>
<td style="text-align:left">用户复制功能(replication)的内部命令</td>
</tr>
<tr>
<td>replconf</td>
<td style="text-align:left">暂无用处</td>
</tr>
<tr>
<td>monitor</td>
<td style="text-align:left">实时打印出Redis服务器收到的命令,调试专用</td>
</tr>
<tr>
<td>slaveof</td>
<td style="text-align:left">SLAVEOF命令用户在Redis运行时动态地修改复制(replication)功能的行为</td>
</tr>
<tr>
<td>debug</td>
<td style="text-align:left">调试命令</td>
</tr>
<tr>
<td>config</td>
<td style="text-align:left">配置参数</td>
</tr>
<tr>
<td>restore</td>
<td style="text-align:left">反序列化给定的序列化值,并将它和给定的KEY关联</td>
</tr>
<tr>
<td>migrate</td>
<td style="text-align:left">将key原子性地从当前实例传送到目标实例的指定数据库上,一旦传送成功,KEY保证会出现在目标实例上,而当前实例上的KEY会被删除</td>
</tr>
<tr>
<td>dump</td>
<td style="text-align:left">序列化给定KEY,并返回被序列化的值,使用restore命令可以将这个值反序列化为Redis键</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>查看锁定IP</td>
<td style="text-align:left">config get lockedips</td>
</tr>
<tr>
<td>解锁单个IP</td>
<td style="text-align:left">config set unlockips 10.67.147.111</td>
</tr>
<tr>
<td>解锁所有IP</td>
<td style="text-align:left">config set unlockips “all”</td>
</tr>
</tbody>
</table>
<h1 id="string类型">string类型</h1>
<h2 id="字符串常见操作">字符串常见操作</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>set key value</td>
<td style="text-align:left">存入键值对</td>
</tr>
<tr>
<td>mset key value [key value…]</td>
<td style="text-align:left">批量存储字符串键值对</td>
</tr>
<tr>
<td>setnx key value</td>
<td style="text-align:left">存入一个不存在的字符串键值对</td>
</tr>
<tr>
<td>get key</td>
<td style="text-align:left">获取一个字符串</td>
</tr>
<tr>
<td>mget key [key…]</td>
<td style="text-align:left">批量获取字符串键值</td>
</tr>
<tr>
<td>del key [key…]</td>
<td style="text-align:left">删除一个键</td>
</tr>
<tr>
<td>expire key seconds</td>
<td style="text-align:left">设置一个键的过期时间（秒）</td>
</tr>
</tbody>
</table>
<h2 id="原子加减">原子加减</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>incr key</td>
<td style="text-align:left">将key中存储的数字值加一</td>
</tr>
<tr>
<td>decr key</td>
<td style="text-align:left">将key中存储的数字值减一</td>
</tr>
<tr>
<td>incr by key increment</td>
<td style="text-align:left">将key中所存储的值加上increment</td>
</tr>
<tr>
<td>decr by key decrement</td>
<td style="text-align:left">将key所存储的值减去decrement</td>
</tr>
</tbody>
</table>
<h2 id="string应用场景">string应用场景</h2>
<blockquote>
<p>计数器<br>
文章计数器 阅读量 incr article:num</p>
</blockquote>
<h2 id="分布式锁">分布式锁</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>setnx product true</td>
<td style="text-align:left">返回1代表获取锁成功</td>
</tr>
<tr>
<td>setnx product true</td>
<td style="text-align:left">返回0代表获取锁失败</td>
</tr>
<tr>
<td>del product</td>
<td style="text-align:left">执行完业务释放锁</td>
</tr>
</tbody>
</table>
<h1 id="hash类型">hash类型</h1>
<h2 id="hash常用操作">hash常用操作</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>hset key field value</td>
<td style="text-align:left">存储一个哈希key的键值</td>
</tr>
<tr>
<td>hsetnx key field value</td>
<td style="text-align:left">存储一个不存在的哈希表key的键值</td>
</tr>
<tr>
<td>hmseet key field value[field value…]</td>
<td style="text-align:left">在一个哈希表key中存储多个键值对</td>
</tr>
<tr>
<td>hget key field</td>
<td style="text-align:left">获取哈希表key对应的field的值</td>
</tr>
<tr>
<td>hmget key field[field…]</td>
<td style="text-align:left">批量获取哈希表key中多个field的值</td>
</tr>
<tr>
<td>hdel key field [field…]</td>
<td style="text-align:left">删除哈希表key中的field的键值</td>
</tr>
<tr>
<td>hlen key</td>
<td style="text-align:left">返回哈希表key中的field的数量</td>
</tr>
<tr>
<td>hgetall key</td>
<td style="text-align:left">返回哈希表key中所有的键值</td>
</tr>
<tr>
<td>hincrby key field increment</td>
<td style="text-align:left">为哈希表key中field键的值加上增量increment</td>
</tr>
</tbody>
</table>
<h2 id="hash应用场景">hash应用场景</h2>
<blockquote>
<p>对象缓存<br>
hmset user userid1:name value userid1:age 14<br>
购物车<br>
hmset user product1:name value prodeuct1:num value</p>
</blockquote>
<h2 id="hash优缺点">hash优缺点</h2>
<ul>
<li>优点<br>
同类数据归类整合存储，方便数据管理<br>
相比string操作消耗内存与cpu更小<br>
相比string存储更节省空间</li>
<li>缺点<br>
过期功能不能使用在field上，只能使用在key上<br>
Redis集群架构下不适合大规模使用</li>
</ul>
<h1 id="list类型">list类型</h1>
<h2 id="list常用操作">list常用操作</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>lpush key value[value…]</td>
<td style="text-align:left">将一个或多个值value插入到key列表的表头（最左边）</td>
</tr>
<tr>
<td>rpush key value[value…]</td>
<td style="text-align:left">将一个或多个value插入到key列表的表尾（最右边）</td>
</tr>
<tr>
<td>lpop key</td>
<td style="text-align:left">移除并返回key列表的头元素</td>
</tr>
<tr>
<td>rpop key</td>
<td style="text-align:left">移除并返回key列表的尾元素</td>
</tr>
<tr>
<td>lrange key start stop</td>
<td style="text-align:left">返回列表key中指定区间内的元素，区间以偏移量start和stop指定</td>
</tr>
<tr>
<td>blpop key [key…] timeout</td>
<td style="text-align:left">从key列表表头弹出一个元素，若列表中没有元素，阻塞等待timeout秒，如果timeout=0，一直阻塞等待</td>
</tr>
<tr>
<td>brpop key [key…] timeout</td>
<td style="text-align:left">从key列表表尾弹出一个元素，若列表中没有元素，阻塞等待timeout秒，如果timeout=0，一直阻塞等待</td>
</tr>
</tbody>
</table>
<h2 id="list应用场景">list应用场景</h2>
<p>栈（stack）<br>
lpush + lpop —&gt;FILO<br>
队列（queue）<br>
lpush + rpop<br>
阻塞队列（Blocking MQ）<br>
lpush + brpop<br>
微博微信消息流<br>
使用lpush放入用户ID消息，然后使用lrange 来获取消息</p>
<h1 id="set类型">set类型</h1>
<h2 id="set常用操作">set常用操作</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>sadd key member [member…]</td>
<td style="text-align:left">往集合key中存入元素，元素存在则忽略，若key不存在则创建</td>
</tr>
<tr>
<td>srem key member[member…]</td>
<td style="text-align:left">从集合key中删除元素</td>
</tr>
<tr>
<td>smembers key</td>
<td style="text-align:left">获取集合key中的所有元素</td>
</tr>
<tr>
<td>scardkey</td>
<td style="text-align:left">获取集合key中的元素的个数</td>
</tr>
<tr>
<td>sismemver key member</td>
<td style="text-align:left">判断member元素是否存在于集合key中</td>
</tr>
<tr>
<td>srandmember key [count]</td>
<td style="text-align:left">从集合key中选出count个元素，元素不从key中删除</td>
</tr>
</tbody>
</table>
<p>spop key [count]//从集合key中选出count个元素，元素从key中删除</p>
<h2 id="set运算操作">set运算操作</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>sinter key [key…]</td>
<td style="text-align:left">交集运算</td>
</tr>
<tr>
<td>sinterstore destination key [key…]</td>
<td style="text-align:left">交集结果存入新集合destination中</td>
</tr>
<tr>
<td>sunion key [key…]</td>
<td style="text-align:left">并集运算</td>
</tr>
<tr>
<td>sunionstore destination key [key…]</td>
<td style="text-align:left">并集结果存入新集合destination中</td>
</tr>
<tr>
<td>sdiff key [key…]</td>
<td style="text-align:left">差集运算</td>
</tr>
<tr>
<td>sdiffstore destination key [key…]</td>
<td style="text-align:left">差集结果存入新集合destination中</td>
</tr>
</tbody>
</table>
<h2 id="set使用场景">set使用场景</h2>
<p>微信抽奖小程序<br>
点击参与抽奖加入集合 sadd key {userID}<br>
查看参与抽奖所有用户 smembers key<br>
抽取count名中奖者 srandmember key [count]/spop key [count]<br>
微信微博点赞、收藏、标签<br>
点赞 sadd user ID<br>
取消点赞 srem user ID<br>
检查用户是否点过赞 sismember user ID<br>
获取用户点赞列表 smembers user<br>
获取点赞用户数 scard user<br>
关注模型 （使用集合）<br>
共同关注的人 ------ 交集<br>
可能认识的人 ------- 差集</p>
<p>其他应用场景:<br>
https://bbs.huaweicloud.com/forum/thread-10558-1-1.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Promise]]></title>
        <id>https://blog.myxy.net/promise/</id>
        <link href="https://blog.myxy.net/promise/">
        </link>
        <updated>2020-09-07T08:11:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="promise是什么">promise是什么？</h1>
<ul>
<li>主要用于异步计算</li>
<li>可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果</li>
<li>可以在对象之间传递和操作promise，帮助我们处理队列</li>
</ul>
<blockquote>
<p><em>同步</em>：假设你去了一家饭店，找个位置，叫来服务员，这个时候服务员对你说，对不起我是“同步”服务员，我要服务完这张桌子才能招呼你。那桌客人明明已经吃上了，你只是想要个菜单，这么小的动作，服务员却要你等到别人的一个大动作完成之后，才能再来招呼你，这个便是同步的问题：也就是“顺序交付的工作1234，必须按照1234的顺序完成”。<br>
<em>异步</em>：则是将耗时很长的A交付的工作交给系统之后，就去继续做B交付的工作，。等到系统完成了前面的工作之后，再通过回调或者事件，继续做A剩下的工作。<br>
AB工作的完成顺序，和交付他们的时间顺序无关，所以叫“异步”。</p>
</blockquote>
<p>promise详解</p>
<pre><code>new Promise(
  function (resolve, reject) {
    // 一段耗时的异步操作
    resolve('成功') // 数据处理完成
    // reject('失败') // 数据处理出错
  }
).then(
  (res) =&gt; {console.log(res)},  // 成功
  (err) =&gt; {console.log(err)} // 失败
)
</code></pre>
<p><code>resolve</code>作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</p>
<p><code>reject</code>作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p><em>promise</em>有三个状态：<br>
1、pending[待定]初始状态<br>
2、fulfilled[实现]操作成功<br>
3、rejected[被否决]操作失败<br>
当promise状态发生改变，就会触发then()里的响应函数处理后续步骤；<br>
promise状态一经改变，不会再变。</p>
<p>Promise对象的状态改变，只有两种可能：<br>
从pending变为fulfilled<br>
从pending变为rejected。<br>
这两种情况只要发生，状态就凝固了，不会再变了。</p>
<p>1.promise简单用法</p>
<pre><code>function2(){
    // 你的逻辑代码 
    return Promise.resolve(/* 这里是需要返回的数据*/)
}

function3(){
    // 你的逻辑代码 
    return Promise.resolve(/* 这里是需要返回的数据*/)
}

// 调用
function1(){
    this.function2().then(val =&gt; { 
        this.function3();
    });
}
</code></pre>
<p>2.promise高阶用法</p>
<pre><code>init1(){
return new Promise((resolve, reject) =&gt; {
    let data={
        dateStr:this.time
    };
    api.get('url', null).then( res =&gt; {
       //自己的操作
        resolve()
    }).catch(err =&gt; {
        reject()
    });
});
};
init2(){
return new Promise((resolve, reject) =&gt; {
    let data={
        dateStr:this.time
    };
    api.get('url', null).then( res =&gt; {
       //自己的操作
        resolve()
    }).catch(err =&gt; {
        reject()
    });
});
};


//调用
Promise.all([this.init1(),this.init2()]).then(() =&gt; {
    //两个都调成功以后执行的操作
//主要是loading问题
}).catch(err =&gt; {
    // 抛出错误信息
});
</code></pre>
<p>https://www.jianshu.com/p/1b63a13c2701<br>
https://blog.csdn.net/qq_34645412/article/details/81170576</p>
]]></content>
    </entry>
</feed>