<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.myxy.net</id>
    <title>Maxbad`Blog</title>
    <updated>2021-05-11T12:38:49.389Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.myxy.net"/>
    <link rel="self" href="https://blog.myxy.net/atom.xml"/>
    <subtitle>记录一些东西</subtitle>
    <logo>https://blog.myxy.net/images/avatar.png</logo>
    <icon>https://blog.myxy.net/favicon.ico</icon>
    <rights>All rights reserved 2021, Maxbad`Blog</rights>
    <entry>
        <title type="html"><![CDATA[const int* 与 int const*]]></title>
        <id>https://blog.myxy.net/const-int-yu-int-const/</id>
        <link href="https://blog.myxy.net/const-int-yu-int-const/">
        </link>
        <updated>2021-04-14T00:48:39.000Z</updated>
        <content type="html"><![CDATA[<p><code>cons</code>t默认作用于其左边的东西，否则作用于其右边的东西</p>
<p><code>const</code>在<code>*</code>的左边，值不能修改。<code>const</code>在<code>*</code>的右边，地址不能修改</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue2-ace-editor ]]></title>
        <id>https://blog.myxy.net/vue2-ace-editor/</id>
        <link href="https://blog.myxy.net/vue2-ace-editor/">
        </link>
        <updated>2021-04-13T12:21:20.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.npmjs.com/package/vue2-ace-editor4">https://www.npmjs.com/package/vue2-ace-editor4</a></p>
<pre><code class="language-js">var ace = require('brace');

module.exports = {
    render: function (h) {
        var height = this.height ? this.px(this.height) : '100%'
        var width = this.width ? this.px(this.width) : '100%'
        return h('div', {
            attrs: {
                style: &quot;height: &quot; + height + '; width: ' + width,
            }
        })
    },
    props: {
        value: String,
        lang: true,
        theme: String,
        height: true,
        width: true,
        autoComplete: false, //源码中添加该配置
        options: Object
    },
    data: function () {
        return {
            editor: null,
            contentBackup: &quot;&quot;
        }
    },
    methods: {
        px: function (n) {
            if (/^\d*$/.test(n)) {
                return n + &quot;px&quot;;
            }
            return n;
        }
    },
    watch: {
        value: function (val) {
            if (this.contentBackup !== val) {
                this.editor.session.setValue(val, 1);
                this.contentBackup = val;
            }
        },
        theme: function (newTheme) {
            this.editor.setTheme('ace/theme/' + newTheme);
        },
        lang: function (newLang) {
            this.editor.getSession().setMode(typeof newLang === 'string' ? ('ace/mode/' + newLang) : newLang);
        },
        options: function (newOption) {
            this.editor.setOptions(newOption);
        },
        height: function () {
            this.$nextTick(function () {
                this.editor.resize()
            })
        },
        width: function () {
            this.$nextTick(function () {
                this.editor.resize()
            })
        }
    },
    beforeDestroy: function () {
        this.editor.destroy();
        this.editor.container.remove();
    },
    mounted: function () {
        var _this = this //插入该行，直接使用this会报错
        var vm = this;
        var lang = this.lang || 'text';
        var theme = this.theme || 'chrome';
        var autoComplete = this.autoComplete || false //插入该行
        require('brace/ext/emmet');

        var editor = vm.editor = ace.edit(this.$el);
        editor.$blockScrolling = Infinity;

        this.$emit('init', editor);

        //editor.setOption(&quot;enableEmmet&quot;, true);
        editor.getSession().setMode(typeof lang === 'string' ? ('ace/mode/' + lang) : lang);
        editor.setTheme('ace/theme/' + theme);
        if (this.value)
            editor.setValue(this.value, 1);
        this.contentBackup = this.value;

        // 插入以下代码块
        if (autoComplete) {
            var staticWordCompleter = {
                getCompletions: function (editor, session, pos, prefix, callback) {
                    _this.$emit('setCompletions', editor, session, pos, prefix, callback)
                }
            }
            var lnTools = ace.acequire(&quot;ace/ext/language_tools&quot;)
            lnTools.addCompleter(staticWordCompleter)
            editor.setOptions({
                enableBasicAutocompletion: true,
                enableSnippets: true,
                enableLiveAutocompletion: true, //智能补全
            })
        }
        editor.on('change', function () {
            var content = editor.getValue();
            vm.$emit('input', content);
            vm.contentBackup = content;
        });
        // newadd
        editor.on('focus', function () {
            vm.$emit('focus');
        });
        // newadd
        editor.on('blur', function () {
            vm.$emit('blur');
        });
        if (vm.options)
            editor.setOptions(vm.options);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue 中使用 debounce]]></title>
        <id>https://blog.myxy.net/vue-zhong-shi-yong-debounce/</id>
        <link href="https://blog.myxy.net/vue-zhong-shi-yong-debounce/">
        </link>
        <updated>2021-04-08T09:48:59.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-vue">import Vue from 'vue'
import { debounce } from 'lodash'
export default Vue.extend({
    methods: {
        myDebounce: debounce(function(){
            // 执行内容...
        },500),
    }
})
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue-iview使用技巧]]></title>
        <id>https://blog.myxy.net/vue-iview-shi-yong-ji-qiao/</id>
        <link href="https://blog.myxy.net/vue-iview-shi-yong-ji-qiao/">
        </link>
        <updated>2021-03-23T08:29:03.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>修改数据</li>
</ul>
<pre><code class="language-js">this.items[1]='xxxx';  // 不能监听数据变的
this.$set(this.items,1,'xxxxxx');  // 可以监听数据变化

// 拷贝一份出来,修改后再赋值回去也可以监听
let temp=[...this.items];
temp[1]='xxxxx'
this.tiems=temp;
</code></pre>
<ul>
<li>数据深拷贝,针对数组和对象使用</li>
</ul>
<pre><code class="language-js">import { deepCopy } from 'view-design/src/utils/assist';
// deepCopy(data)
</code></pre>
<blockquote>
<p><code>Object.assign</code> 和es6扩展运算符 三个点<code>{...}</code> 只针对一层对象可用,多层需要通过<code>JSON.parse(JSON.stringify())</code>达到深拷贝</p>
</blockquote>
<ul>
<li>获取对象样式</li>
</ul>
<pre><code class="language-js">import { getStyle } from 'view-design/src/utils/assist';
// getStyle (element, styleName)
</code></pre>
<ul>
<li>判断参数是否是其中之一</li>
</ul>
<pre><code class="language-js">import { oneOf } from 'view-design/src/utils/assist';
// oneOf (value, validList)
</code></pre>
<ul>
<li>类操作</li>
</ul>
<pre><code class="language-js">import { hasClass,addClass,removeClass } from 'view-design/src/utils/assist';
// hasClass(el, cls) 
// addClass(el, cls)
// removeClass(el, cls)
</code></pre>
<ul>
<li>兼容SSR的事件绑定监听dom事件</li>
</ul>
<pre><code class="language-js">import { on, off } from 'view-design/src/utils/dom';
</code></pre>
<ul>
<li>清空Select 选择器</li>
</ul>
<pre><code class="language-js">this.$refs.xxxxxx.clearSingleSelect();
</code></pre>
<ul>
<li>清空DatePicker（日期选择器）</li>
</ul>
<pre><code class="language-js">this.$refs.xxxxxx.handleClear()
</code></pre>
<ul>
<li>清空TimePicker（时间选择器）</li>
</ul>
<pre><code class="language-js">this.$refs.xxxxxx.handleClear()
</code></pre>
<ul>
<li>清空Table (表格) 选中的所有项</li>
</ul>
<pre><code class="language-js">this.$refs.xxxxxx.selectAll(false);
</code></pre>
<ul>
<li>清空Form验证</li>
</ul>
<pre><code class="language-js">this.$refs.xxxxxx.resetFields();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[VUE components 组件用法]]></title>
        <id>https://blog.myxy.net/vue-components-zu-jian-yong-fa/</id>
        <link href="https://blog.myxy.net/vue-components-zu-jian-yong-fa/">
        </link>
        <updated>2021-03-19T06:13:34.000Z</updated>
        <content type="html"><![CDATA[<p><em>子组件给父组件传递数据</em></p>
<pre><code class="language-js">子组件中：
this.showFaceDia = false  
this.$emit('showFaceDia',this.showFaceDia)  //执行showFaceDia函数并把要改变的值作为参数带过去

父组件：
methods:{
showFaceDia(msg){
    this.showFaceDia = msg
  }
}
不要忘记在DOM中引用：
&lt;test :title=&quot;title&quot; @showFaceDia=&quot;showFaceDia&quot;&gt;&lt;/test&gt;//注意showFaceDia后不能加括号

</code></pre>
<p><em>父组件调用子组件的方法</em></p>
<pre><code class="language-js">//父组件
&lt;v-test :title=&quot;title&quot; ref=&quot;aa&quot;&gt;&lt;/v-test&gt; //通过ref为子组件赋予ID引用
&lt;div @click=&quot;getChild()&quot;&gt;&lt;/div&gt;
getChild(){
  this.$refs.aa.childFun()   // 此处使用
}
</code></pre>
<p><em>子组件调用父组件的方法</em></p>
<pre><code class="language-js">（1）直接在子组件中通过this.$parent.event来调用父组件的方法
（2）在子组件里用$emit向父组件触发一个事件，父组件监听这个事件就行了
实例:
子组件：
methods: {
        getParent () {
            this.$emit('togglePop')  //此处直接写父组件的事件名称
        }
    }
父组件：
DOM中：&lt;test :title=&quot;title&quot; @togglePop=&quot;togglePop&quot;&gt;&lt;/test&gt;
togglePop(){
            console.log('ddddddd')
        },
</code></pre>
<p><a href="https://www.jianshu.com/p/6dfb2d2cbc71">https://www.jianshu.com/p/6dfb2d2cbc71</a></p>
<p><a href="https://www.jianshu.com/p/816971e4269b">https://www.jianshu.com/p/816971e4269b</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[VUE子组件向父组件传值]]></title>
        <id>https://blog.myxy.net/vue-zi-zu-jian-xiang-fu-zu-jian-chuan-zhi/</id>
        <link href="https://blog.myxy.net/vue-zi-zu-jian-xiang-fu-zu-jian-chuan-zhi/">
        </link>
        <updated>2021-03-19T06:13:34.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-VUE">子组件中：
this.showFaceDia = false  
this.$emit('showFaceDia',this.showFaceDia)  //执行showFaceDia函数并把要改变的值作为参数带过去

父组件：
methods:{
showFaceDia(msg){
    this.showFaceDia = msg
  }
}
不要忘记在DOM中引用：
&lt;test :title=&quot;title&quot; @showFaceDia=&quot;showFaceDia&quot;&gt;&lt;/test&gt;//注意showFaceDia后不能加括号

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[VUE 子组件设置scoped]]></title>
        <id>https://blog.myxy.net/vue-zi-zu-jian-she-zhi-scoped/</id>
        <link href="https://blog.myxy.net/vue-zi-zu-jian-she-zhi-scoped/">
        </link>
        <updated>2021-03-18T08:19:21.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-css">&lt;style lang=&quot;less&quot; scoped&gt;
/deep/.ivu-tree-arrow{
  padding-top: 10px 0;
}
&lt;/style&gt;
</code></pre>
<p><em>问题</em><br>
使用 <code>scoped</code> 后，父组件的样式将不会渗透到子组件中。但是一个子组件的根节点会同时受其父组件的 scoped CSS 和子组件的 scoped CSS 的影响。</p>
<p><em>解决方案</em><br>
使用深度作用选择器，即 <code>&gt;&gt;&gt;</code> 操作符，或使用 <code>/deep/</code> 或 <code>::v-deep</code> 操作符，后两者都是 <code>&gt;&gt;&gt;</code> 的别名，三者效果一样。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从资源文件中加载二进制数据]]></title>
        <id>https://blog.myxy.net/cong-zi-yuan-wen-jian-zhong-jia-zai-er-jin-zhi-shu-ju/</id>
        <link href="https://blog.myxy.net/cong-zi-yuan-wen-jian-zhong-jia-zai-er-jin-zhi-shu-ju/">
        </link>
        <updated>2021-03-12T11:34:09.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-cpp">
	static uint8_t* load_binary (HMODULE hModule, LPCTSTR resType, LPCTSTR resName) {
		HRSRC _hRsrc = ::FindResource (hModule, resName, resType);
		if (!_hRsrc)
			return nullptr;
		HGLOBAL _hGlobal = ::LoadResource (hModule, _hRsrc);
		if (!_hGlobal)
			return nullptr;
		LPVOID _src_ptr = ::LockResource (_hGlobal);
		DWORD _size = ::SizeofResource (hModule, _hRsrc);
		uint8_t *_ptr = new uint8_t [_size];
		memcpy (_ptr, _src_ptr, _size);
		//::UnlockResource (_hGlobal);
		::FreeResource (_hGlobal);
		return _ptr;
	}


    uint8_t *pdata =load_binary ((HMODULE) CPaintManagerUI::GetInstance (), _T (&quot;IPDB&quot;), MAKEINTRESOURCE (IDR_IPDB1));
if (pdata) {
			delete [] pdata;
			pdata = nullptr;
		}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows环境下“路径”处理]]></title>
        <id>https://blog.myxy.net/windows-huan-jing-xia-lu-jing-chu-li/</id>
        <link href="https://blog.myxy.net/windows-huan-jing-xia-lu-jing-chu-li/">
        </link>
        <updated>2021-03-12T03:11:38.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-cpp">#include &lt;Shlwapi.h&gt;
#pragma comment(lib, &quot;shlwapi.lib&quot;)


// 路径截断与合并函数
PathRemoveArgs                去除路径后面的参数
PathRemoveBackslash           去除路径最后的反斜杠“\”
PathAddBackslash              在路径最后加上反斜杠“\”
PathRemoveBlanks              去除路径前后的空格
PathAddExtension              在文件路径后面加上扩展名
PathRemoveExtension           去除文件路径扩展名
PathRenameExtension           更改文件路径扩展名
PathRemoveFileSpec            去除文件名，得到目录
PathUnquoteSpaces             去除路径中的首尾引号
PathQuoteSpaces               判断路径中是否有空格，有的话，就是用“”引号把整个路径包含起来
PathAppend                    将一个路径追加到另一个路径后面
PathCombine                   合并两个路径
PathSkipRoot                  去掉路径中的磁盘符或UNC部分。
PathStripPath                 去掉路径中的目录部分，得到文件名。
PathStripToRoot               去掉路径的文件部分，得到根目录。
PathCompactPath               根据像素值生成符合长度的路径。
                              如原始路径：          C:\path1\path2\sample.txt
                              根据120像素截断后为：  C:\pat...\sample.txt
                              根据25像素截断后为:   ...\sample.txt
 
PathCompactPathEx             根据字符个数来生成符合长度的路径。
PathSetDlgItemPath            将路径数据设置到对话框的子控件上。
PathUndecorate                去除路径中的修饰 
PathUnExpandEnvStrings        将路径中部分数据替换为系统环境变量格式

// 路径查找比较函数
PathFindOnPath                从路径中查找路径
PathFindExtension             查找路径的扩展名
PathFindFileName              获取路径的文件名
PathFindNextComponent         查找匹配路径（不太熟悉）
PathFindSuffixArray           查找给定的文件名是否有给定的后缀。
PathGetArgs                   获取路径参数
PathGetCharType               获取路径字符类型
PathGetDriveNumber            根据逻辑盘符返回驱动器序号

// 路径验证函数
PathCleanupSpec               去除路径中不合法的字符
PathCommonPrefix              比较并提取两个路径相同的前缀
PathFileExists                验证路径是否存在
PathMatchSpec                 判断路径是否匹配制定的扩展名。
PathIsDirectory               判断路径是否是一个有效的目录
PathIsFileSpec                验证路径是否一个文件名（有可能是一个路径）
PathIsExe                     验证路径是否是可执行文件。注意：不仅仅是.exe，还有.bat，.com，.src等
PathIsRoot                    路径是否为根路径
PathIsRelative                判断路径是否是相对路径
PathIsContentType             检测文件是否为制定类型。
                              例如：PathIsContentType( “hello.txt” , “text/plain” ) 返回TRUE
　                                  PathIsContentType( “hello.txt” , “image/gif” ) 返回FALSE
PathIsHTMLFile                判断路径是否是html文件类型——根据系统注册类型判断。
PathIsLFNFileSpec             判断路径是否是长路径格式
PathIsNetworkPath             判断路径是否是一个网络路径。
PathIsPrefix                  判断路径是否含有指定前缀
PathIsSameRoot                判断路径是否有相同根目录
PathIsSlow                    判断路径是否是一个高度延迟的网络连接
PathIsSystemFolder            判断路径是否有系统属性（属性可以自己设定）
PathIsUNC                     路径是否是UNC格式（网络路径）
PathIsUNCServer               路径是否是UNC服务器
PathIsUNCServerShare          路径是否仅仅是UNC的共享路径格式
PathIsURL                     路径是否是http格式。
PathYetAnotherMakeUniqueName  基于已存在的文件，自动创建一个唯一的文件名。比较有用，比如存在“新建文件”，此函数会创建文件名“新建文件夹 (2)”。



</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[取EXE文件自身所在的文件夹]]></title>
        <id>https://blog.myxy.net/qu-exe-wen-jian-zi-shen-suo-zai-de-wen-jian-jia/</id>
        <link href="https://blog.myxy.net/qu-exe-wen-jian-zi-shen-suo-zai-de-wen-jian-jia/">
        </link>
        <updated>2021-03-12T02:29:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="方式一">方式一:</h2>
<pre><code class="language-cpp">
TCHAR run_path[MAX_PATH] = { 0, };
//获取应用程序或者DLL的完整路径
::GetModuleFileName(NULL, run_path, MAX_PATH);
//去掉路径末尾的文件名留下反斜杠
(_tcsrchr(run_path, TEXT('\\')))[1] = 0;
// 设置运行目录
::SetCurrentDirectory(run_path);
</code></pre>
<h2 id="方式二">方式二:</h2>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;Shlwapi.h&gt;
#pragma comment(lib,&quot;shlwapi.lib&quot;)
 
int main()  
{  
	TCHAR szPath[MAX_PATH];
	//获取应用程序或者DLL的完整路径
	::GetModuleFileName(NULL, szPath, MAX_PATH);
	//去掉路径末尾的文件名和反斜杠
	::PathRemoveFileSpec(szPath);
 
	printf(&quot;%ls\n&quot;, szPath);
 
	return 0;
}
</code></pre>
<h2 id="方式三">方式三</h2>
<pre><code class="language-cpp">void GetModuleFilePath(IN char* pPath, IN DWORD nSize)
{
	char path_buffer[_MAX_PATH] = { 0 };
	char drive[_MAX_DRIVE] = { 0 };
	char dir[_MAX_DIR] = { 0 };
	char fname[_MAX_FNAME] = { 0 };
	char ext[_MAX_EXT] = { 0 };
	if (NULL == pPath)
	{
		return;
	}
	GetModuleFileNameA(NULL, path_buffer, _MAX_PATH);
	_splitpath(path_buffer, drive, dir, fname, ext);
	strcat(pPath, drive);
	strcat(pPath, dir);
}

	char path_buffer[_MAX_PATH] = { 0 };
	GetModuleFilePath(path_buffer, _MAX_PATH);

</code></pre>
]]></content>
    </entry>
</feed>