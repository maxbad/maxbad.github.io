<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.myxy.net</id>
    <title>Maxbad`Blog</title>
    <updated>2020-05-19T09:37:52.898Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.myxy.net"/>
    <link rel="self" href="https://blog.myxy.net/atom.xml"/>
    <subtitle>记录一些东西</subtitle>
    <logo>https://blog.myxy.net/images/avatar.png</logo>
    <icon>https://blog.myxy.net/favicon.ico</icon>
    <rights>All rights reserved 2020, Maxbad`Blog</rights>
    <entry>
        <title type="html"><![CDATA[inja模板渲染]]></title>
        <id>https://blog.myxy.net/inja-mo-ban-xuan-ran/</id>
        <link href="https://blog.myxy.net/inja-mo-ban-xuan-ran/">
        </link>
        <updated>2020-05-16T01:55:17.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://github.com/xmh0511/inja">inja</a></p>
<h2 id="赋值方式">赋值方式</h2>
<pre><code class="language-cpp">//方式一:
res.set_attr(&quot;variable&quot;,&quot;hello,world&quot;);
//方式二:
json  jsondata;
jsondata[&quot;code&quot;]=0;
jsondata[&quot;msg&quot;]=&quot;ok&quot;;
res.write_view(&quot;./tpl/login.html&quot;, jsondata,false);
</code></pre>
<h2 id="循环输出">循环输出</h2>
<blockquote>
<p>对json数组的遍历</p>
</blockquote>
<pre><code class="language-html">{% for item in list %}
    &lt;p&gt;@{item.name}&lt;/p&gt;
{% endfor %}

// 数组元素的访问
&lt;div&gt;@{list.0.name}&lt;/div&gt;

// 获取list长度
&lt;div&gt;@{length(list)}&lt;/div&gt;

// 获取list中的第一个或最后一个元素
&lt;div&gt;@{first (list)}&lt;/div&gt;
&lt;div&gt;@{last (list)}&lt;/div&gt;

//列表排序
&lt;div&gt;@{sort([3,2,1])}&lt;/div&gt;
&lt;div&gt;@{sort(list)}&lt;/div&gt;

// 获取list中的最大最小值
&lt;div&gt;max([1,3,2])&lt;/div&gt;
&lt;div&gt;min([3,1,2])&lt;/div&gt;
&lt;div&gt;min(list)&lt;/div&gt;

// 还可以通过关键字loop访问当前循环的属性和值
{% for item in list %}
    &lt;p&gt;
        &lt;span&gt;@{loop.index }&lt;/span&gt;
        &lt;span&gt;@{loop.index1 }&lt;/span&gt;
        &lt;span&gt;@{loop.is_first   }&lt;/span&gt;
        &lt;span&gt;@{loop.is_last  }&lt;/span&gt;
        &lt;span&gt;@{item.name}&lt;/span&gt;
    &lt;/p&gt;
{% endfor %}

// 多重循环中，嵌套的循环中可以通过loop.parent访问父层循环的loop，以此类推loop.parent.parent
{% for item in list %}
    {% for item0 in item %}
        &lt;p&gt;@{item0.abc}&lt;/p&gt;
    {% endfor %}
{% endfor %}
</code></pre>
<blockquote>
<p>对json对象的遍历</p>
</blockquote>
<pre><code class="language-html">{% for key, value in object %}
    &lt;p&gt;
        &lt;span&gt;@{key}&lt;/span&gt;
        &lt;span&gt;:&lt;/span&gt;
        &lt;span&gt;@{value}&lt;/span&gt;
    &lt;/p&gt;
{% endfor %}
</code></pre>
<blockquote>
<p>获取一个循环区间</p>
</blockquote>
<pre><code class="language-html">{% for i in range(4) %}
    &lt;div&gt;@{ loop.index1 }&lt;/div&gt;
{% endfor %}
</code></pre>
<h2 id="变量输出">变量输出:</h2>
<pre><code class="language-html">@{downpath}
</code></pre>
<h2 id="条件判断">条件判断:</h2>
<p><code>==</code> , <code>&gt;</code> , <code>&gt;=</code> , <code>&lt;</code> , <code>&lt;=</code> , <code>!=</code> , <code>逻辑与 and</code> , <code>逻辑或 or</code> , <code>逻辑非 not</code></p>
<pre><code>{% if variable == true %}
    &lt;div&gt;如果variable是true则显示&lt;/div&gt;
{% endif %}

{% if variable in list %}
    &lt;div&gt;variable:&quot;a&quot;,list:[&quot;a&quot;,&quot;b&quot;]&lt;/div&gt;
{% endif %}

{% if variable == null %}
    {% endif %}
    {% if ... %}
        {% else if ... %}
    {% else %}
{% endif %}

// 判断对象中是否存在某键名
{% if exists(\&quot;variable\&quot;) %}
    存在
{% endif %}

{% if existsIn(variable,\&quot;time\&quot;) %}
    &lt;div&gt;variable对象中是否存在key为time的键值对&lt;/div&gt;
{% endif %}

// 判断值的类型
&lt;div&gt;@{isString(variable)}&lt;/div&gt;
&lt;div&gt;@{isArray(variable)}&lt;/div&gt;
</code></pre>
<h2 id="包含外部模板文件">包含外部模板文件</h2>
<pre><code class="language-cpp">{% include \&quot;footer.html\&quot; %}
</code></pre>
<h2 id="原样输出">原样输出</h2>
<pre><code class="language-html">&lt;div&gt;
    #(
        {% for item in list %}
        {% endfor %}
    )#
&lt;div&gt;
</code></pre>
<h2 id="转换成大小写输出">转换成大小写输出</h2>
<pre><code class="language-html">&lt;div&gt;@{upper(variable)}&lt;/div&gt;
&lt;div&gt;@{lower(variable)}&lt;/div&gt;
</code></pre>
<h2 id="判断数值奇偶性">判断数值奇偶性</h2>
<pre><code class="language-html">&lt;div&gt;@{odd(42)}&lt;/div&gt;
&lt;div&gt;@{even(42)}&lt;/div&gt;
</code></pre>
<h2 id="保留小数点n位">保留小数点N位</h2>
<pre><code class="language-html">&lt;div&gt;round(3.1415, 0)&lt;/div&gt;
&lt;div&gt;round(3.1415, 2)&lt;/div&gt;
</code></pre>
<h2 id="是否能整除">是否能整除</h2>
<pre><code class="language-html">&lt;div&gt;@{divisibleBy(42,7)}&lt;/div&gt;
</code></pre>
<h2 id="字符串转数值">字符串转数值</h2>
<pre><code class="language-html">&lt;div&gt;@{int(\&quot;2\&quot;) == 2 } &lt;/div&gt;
&lt;div&gt;@{float(\&quot;1.8\&quot;) &gt; 2}&lt;/div&gt;
</code></pre>
<h2 id="代码注释">代码注释:</h2>
<pre><code class="language-html">&lt;div&gt;1&lt;/div&gt;
{# 
  Todo...
#}
</code></pre>
<h2 id="给不存在的对象设置默认值">给不存在的对象设置默认值</h2>
<pre><code class="language-html">&lt;div&gt;@{default(notexists, \&quot;默认值\&quot;)}&lt;/div&gt;
</code></pre>
<h2 id="自定义模板函数">自定义模板函数</h2>
<blockquote>
<p>通过http_server类的add_view_method方法可以给模板渲染引擎增加处理方法<br>
add_view_method 参数解释</p>
</blockquote>
<pre><code class="language-cpp">参数一: 定义的方法名:string
参数二: 方法参数个数
参数三: 为该方法注册的cpp方法,其参数为 inja::Arguments const&amp; args，返回值为可以隐式转换成json对象的类型

server.add_view_method(&quot;str2int&quot;, 1, [](inja::Arguments const&amp; args) {
        auto i = std::atoi(args[0]-&gt;get&lt;std::string&gt;().data());
        return std::string(&quot;transform:&quot;) + std::to_string(i);
});

 &lt;div&gt;@{str2int(\&quot;123\&quot;)}&lt;/div&gt;
</code></pre>
<h2 id="自定义句法">自定义句法</h2>
<blockquote>
<p>通过response类中的view_environment方法获取模板渲染引擎的句柄 ,注意此设置只针对当前请求的返回，不是全局的</p>
</blockquote>
<ul>
<li>set_expression 设置输出变量值的句法</li>
<li>set_comment 设置注释句法</li>
<li>set_statement 设置块状表达式句法</li>
<li>set_line_statement 设置行表达式句法<br>
<code>res. view_environment().set_expression(&quot;@{&quot;,&quot;}&quot;)</code></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nlohmann/json 使用记录]]></title>
        <id>https://blog.myxy.net/nlohmannjson-shi-yong-ji-lu/</id>
        <link href="https://blog.myxy.net/nlohmannjson-shi-yong-ji-lu/">
        </link>
        <updated>2020-05-12T04:02:56.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://github.com/nlohmann/json">nlohmann</a>库是C++解析json的库，库使用很简单，程序中使用nlohmann仅需要将json.hpp添加到工程中即可。<a href="https://nlohmann.github.io/json/">在线帮助文档</a><br>
定义一个JSON对象: <code>nlohmann::json j_object;</code><br>
打印json对象内容：<code>j_object.dump(缩进量)</code><br>
删除: <code>j_object.erase(&quot;one&quot;);</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows 最常用的多线程同步对象 Event]]></title>
        <id>https://blog.myxy.net/windows-zui-chang-yong-de-duo-xian-cheng-tong-bu-dui-xiang-event/</id>
        <link href="https://blog.myxy.net/windows-zui-chang-yong-de-duo-xian-cheng-tong-bu-dui-xiang-event/">
        </link>
        <updated>2020-05-12T02:37:13.000Z</updated>
        <content type="html"><![CDATA[<p>创建 Event 的 Windows API 函数签名是：</p>
<pre><code class="language-cpp">HANDLE CreateEvent(
  LPSECURITY_ATTRIBUTES lpEventAttributes,
  BOOL                  bManualReset,
  BOOL                  bInitialState,
  LPCTSTR               lpName
);
</code></pre>
<p><strong>参数和返回值的说明如下:</strong></p>
<ul>
<li>参数 <strong>lpEventAttributes</strong>，这个参数设置了 Event 对象的安全属性，Windows 中所有的内核对象都可以设置这个属性，我们一般设置为 NULL，即使用默认安全属性。</li>
<li>参数 <strong>bManualReset</strong>，这个参数设置 Event 对象受信（变成有信号状态）时的行为，当设置为 TRUE 时，表示需要手动调用 ResetEvent 函数去将 Event 重置成无信号状态；当设置为 FALSE，Event 事件对象受信后会自动重置为无信号状态。</li>
<li>参数 <strong>bInitialState</strong> 设置 Event 事件对象初始状态是否是受信的，TRUE 表示有信号，FALSE 表示无信号。</li>
<li>参数 <strong>lpName</strong> 可以设置 Event 对象的名称，如果不需要设置名称，可以将该参数设置为 NULL。一个 Event 对象根据是否设置了名称分为具名对象（具有名称的对象）和匿名对象。Event 对象是可以通过名称在不同进程之间共享的，通过这种方式共享很有用，后面我们会相信介绍。</li>
<li>返回值，如果成功创建 Event 对象返回对象的句柄，如果创建失败返回 NULL。</li>
</ul>
<p>一个无信号的 Event 对象，我们可以通过 <code>SetEvent</code> 将其变成受信状态，SetEvent 的函数签名如下：<code>BOOL SetEvent(HANDLE hEvent);</code> 参数 hEvent 设置为需要设置信号的 Event 句柄即可。</p>
<p>同理，一个已经受信的 Event 对象，可以使用 <code>ResetEvent</code> 对象将其变成无信号状态，ResetEvent 的函数签名如下：<code>BOOL ResetEvent(HANDLE hEvent);</code> 参数 hEvent 即我们需要重置的 Event 对象句柄。</p>
<p>例子,假设现在有两个线程，其中一个是主线程，主线程等待工作线程执行某一项耗时的任务完成后，将任务结果显示出来。代码如下：</p>
<pre><code class="language-cpp"> #include &lt;Windows.h&gt;
 #include &lt;string&gt;
 #include &lt;iostream&gt;

 bool        g_bTaskCompleted = false;
 std::string g_TaskResult;
 HANDLE      g_hTaskEvent = NULL;

 DWORD __stdcall WorkerThreadProc(LPVOID lpThreadParameter)
{
   //使用 Sleep 函数模拟一个很耗时的操作
   //睡眠3秒
   Sleep(3000);
   g_TaskResult = &quot;task completed&quot;;
   g_bTaskCompleted = true;
   //设置事件信号
   SetEvent(g_hTaskEvent);
   return 0;
 }

int main()
{
   //创建一个匿名的手动重置初始无信号的事件对象
   g_hTaskEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
   HANDLE hWorkerThread = CreateThread(NULL, 0, WorkerThreadProc, NULL, 0, NULL); 
   
   DWORD dwResult = WaitForSingleObject(g_hTaskEvent, INFINITE);
   if (dwResult == WAIT_OBJECT_0)
   {
       std::cout &lt;&lt; g_TaskResult &lt;&lt; std::endl;
   }
   
   CloseHandle(hWorkerThread);
   CloseHandle(g_hTaskEvent);
   return 0;
 }
</code></pre>
<p><strong>Event 对象有两个显著的特点：</strong></p>
<ul>
<li>与临界区对象（以及接下来要介绍的 Mutex 对象）相比，Event 对象没有被谁持让持有者线程变成其 owner 这一说法，因此 Event 对象可以同时唤醒多个等待的工作线程。</li>
<li>手动重置的 Event 对象一旦变成受信状态，其信号不会丢失，也就是说当 Event 从无信号变成有信号时，即使某个线程当时没有调用 <code>WaitForSingleObject</code>等待该 Event 对象受信，而是在这之后才调用 <code>WaitForSingleObject</code> ，仍然能检测到事件的受信状态，即不会丢失信号，而后面要介绍的条件变量就可能会丢失信号。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c++ Lambda 表达式]]></title>
        <id>https://blog.myxy.net/c-lambda-biao-da-shi/</id>
        <link href="https://blog.myxy.net/c-lambda-biao-da-shi/">
        </link>
        <updated>2020-05-12T02:17:19.000Z</updated>
        <content type="html"><![CDATA[<p><code>Lambda</code> 表达式，实际上就是提供了一个类似匿名函数的特性，而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用的。<br>
基本语法如下：<br>
<code>[ caputrue ] ( params ) opt -&gt; ret { body; };</code></p>
<ul>
<li><strong>capture</strong> 是捕获列表；</li>
<li><strong>params</strong> 是参数表；(选填)</li>
<li><strong>opt是函数选项</strong> 可以填mutable,exception,attribute（选填）</li>
</ul>
<blockquote>
<p><code>mutable</code>说明lambda表达式体内的代码可以修改被捕获的变量，并且可以访问被捕获的对象的non-const方法。<br>
<code>exception</code>说明lambda表达式是否抛出异常以及何种异常。<br>
<code>attribute</code>用来声明属性。</p>
</blockquote>
<ul>
<li><strong>ret</strong> 是返回值类型（拖尾返回类型）。(选填)</li>
<li><strong>body</strong> 是函数体。</li>
</ul>
<p><strong>捕获列表</strong>：lambda表达式的捕获列表精细控制了lambda表达式能够访问的外部变量，以及如何访问这些变量。</p>
<ol>
<li><strong>[]</strong> 不捕获任何变量。</li>
<li><strong>[&amp;]</strong> 捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。</li>
<li><strong>[=]</strong> 捕获外部作用域中所有变量，并作为副本在函数体中使用(按值捕获)。注意值捕获的前提是变量可以拷贝，且被捕获的变量在 lambda 表达式被创建时拷贝，而非调用时才拷贝。如果希望lambda表达式在调用时能即时访问外部变量，我们应当使用引用方式捕获。</li>
</ol>
<pre><code class="language-cpp">int a = 0;
auto f = [=] { return a; };
a+=1;
cout &lt;&lt; f() &lt;&lt; endl;       //输出0
int a = 0;
auto f = [&amp;a] { return a; };
a+=1;
cout &lt;&lt; f() &lt;&lt;endl;       //输出1
</code></pre>
<ol start="4">
<li><strong>[=,&amp;foo]</strong> 按值捕获外部作用域中所有变量，并按引用捕获foo变量。</li>
<li><strong>[bar]</strong> 按值捕获bar变量，同时不捕获其他变量。</li>
<li><strong>[this]</strong> 捕获当前类中的this指针，让lambda表达式拥有和当前类成员函数同样的访问权限。如果已经使用了<code>&amp;</code>或者<code>=</code>，就默认添加此选项。捕获this的目的是可以在lamda中使用当前类的成员函数和成员变量。</li>
</ol>
<pre><code class="language-cpp">class A
{
 public:
     int i_ = 0;

     void func(int x,int y){
         auto x1 = [] { return i_; };                   //error,没有捕获外部变量
         auto x2 = [=] { return i_ + x + y; };          //OK
         auto x3 = [&amp;] { return i_ + x + y; };        //OK
         auto x4 = [this] { return i_; };               //OK
         auto x5 = [this] { return i_ + x + y; };       //error,没有捕获x,y
         auto x6 = [this, x, y] { return i_ + x + y; };     //OK
         auto x7 = [this] { return i_++; };             //OK
};

int a=0 , b=1;
auto f1 = [] { return a; };                         //error,没有捕获外部变量    
auto f2 = [&amp;] { return a++ };                      //OK
auto f3 = [=] { return a; };                        //OK
auto f4 = [=] {return a++; };                       //error,a是以复制方式捕获的，无法修改
auto f5 = [a] { return a+b; };                      //error,没有捕获变量b
auto f6 = [a, &amp;b] { return a + (b++); };                //OK
auto f7 = [=, &amp;b] { return a + (b++); };                //OK
</code></pre>
<blockquote>
<p><strong>注意</strong> : 虽然按值捕获的变量值均复制一份存储在lambda表达式变量中，修改他们也并不会真正影响到外部，但我们却仍然无法修改它们。如果希望去修改按值捕获的外部变量，需要显示指明lambda表达式为<code>mutable</code>。被<code>mutable</code>修饰的lambda表达式就算没有参数也要写明参数列表。<br>
<strong>原因</strong>：lambda表达式可以说是就地定义仿函数闭包的“语法糖”。它的捕获列表捕获住的任何外部变量，最终会变为闭包类型的成员变量。按照C++标准，lambda表达式的<code>operator()</code>默认是<code>const</code>的，一个<code>const</code>成员函数是无法修改成员变量的值的。而<code>mutable</code>的作用，就在于取消<code>operator()</code>的<code>const</code>。</p>
</blockquote>
<pre><code class="language-cpp">int a = 0;
auto f1 = [=] { return a++; };                //error
auto f2 = [=] () mutable { return a++; };       //OK
</code></pre>
<p><strong>lambda表达式的大致原理</strong> ：每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类重载了()运算符），我们称为闭包类型（closure type）。那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，是一个右值。所以，我们上面的lambda表达式的结果就是一个个闭包。对于复制传值捕捉方式，类中会相应添加对应类型的非静态数据成员。在运行时，会用复制的值初始化这些成员变量，从而生成闭包。对于引用捕获方式，无论是否标记<code>mutable</code>，都可以在lambda表达式中修改捕获的值。至于闭包类中是否有对应成员，C++标准中给出的答案是：不清楚的，与具体实现有关。</p>
<p><a href="https://blog.csdn.net/jiange_zh/article/details/79356417">查看更多C++11常用新特性</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ｃ++11 std::call_once：多线程仅执行一次的完美解决方案]]></title>
        <id>https://blog.myxy.net/c11-stdcall_onceduo-xian-cheng-jin-zhi-xing-yi-ci-de-wan-mei-jie-jue-fang-an/</id>
        <link href="https://blog.myxy.net/c11-stdcall_onceduo-xian-cheng-jin-zhi-xing-yi-ci-de-wan-mei-jie-jue-fang-an/">
        </link>
        <updated>2020-05-12T02:02:26.000Z</updated>
        <content type="html"><![CDATA[<p><code>std::call_once</code> 的作用是很简单的,就是保证函数或者一些代码段在并发或者多线程的情况下,始终只会被执行一次。比如一些初始化函数，多次调用可能导致各种奇怪问题。<br>
需要包含头文件：<code>#include &lt;mutex&gt;</code></p>
<pre><code class="language-cpp">    template &lt;class Fn, class... Args&gt;
    void call_once(once_flag &amp; flag, Fn &amp;&amp; fn, Args &amp;&amp;...args);
</code></pre>
<p><strong>参数</strong></p>
<ul>
<li><strong>flag</strong> 是std::once_falg对象,属于控制的标签，相同的falg只执行一次</li>
<li><strong>fn</strong> 需要只执行一次的函数对象</li>
<li><strong>args</strong> 传递给fn函数的参数,如果有就传递，没有就不传递。</li>
</ul>
<p>给个例子：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
 
std::once_flag flag1;  //必须是全局变量
 
void simple_do_once()
{
    std::call_once(flag1, [](){ std::cout &lt;&lt; &quot;Simple example: called once\n&quot;; });
}
 
int main()
{
    std::thread st1(simple_do_once);
    std::thread st2(simple_do_once);
    std::thread st3(simple_do_once);
    std::thread st4(simple_do_once);
    st1.join();
    st2.join();
    st3.join();
    st4.join();
}
</code></pre>
<p>只会输出一行:<code>Simple example: called once</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[std::wcout,wprintf控制台输出unicode中文]]></title>
        <id>https://blog.myxy.net/stdwcoutwprintf-kong-zhi-tai-shu-chu-unicode-zhong-wen/</id>
        <link href="https://blog.myxy.net/stdwcoutwprintf-kong-zhi-tai-shu-chu-unicode-zhong-wen/">
        </link>
        <updated>2020-05-10T05:25:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="wprintf">wprintf</h2>
<p><code>_wsetlocale(LC_ALL, L&quot;chs&quot;);</code></p>
<blockquote>
<p>发现一个弊端,strftime格式化本地时间/日期的时候,星期几也会变成中文.</p>
</blockquote>
<hr>
<h2 id="stdwcout">std::wcout</h2>
<p><code>std::wcout.imbue(std::locale(&quot;chs&quot;, std::locale::all));</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[标准库std::min/std::max与min/max宏冲突的解决方案]]></title>
        <id>https://blog.myxy.net/biao-zhun-ku-stdminstdmax-yu-minmax-hong-chong-tu/</id>
        <link href="https://blog.myxy.net/biao-zhun-ku-stdminstdmax-yu-minmax-hong-chong-tu/">
        </link>
        <updated>2020-05-09T07:09:14.000Z</updated>
        <content type="html"><![CDATA[<p>如题，因为<code>windef.h</code>中定义了<code>max</code>和<code>min</code>宏.<br>
如果工程中包含了<code>windows.h</code>或<code>windef.h</code>头文件，再使用c++标准库<code>std::min</code>或<code>std::max</code>，就会发生编译错误。</p>
<h2 id="方案一">方案一</h2>
<h4 id="程序里面使用宏-min和max">程序里面使用宏 min和max</h4>
<pre><code class="language-cpp">#ifndef NOMINMAX

#ifndef max
#define max(a,b)            (((a) &gt; (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) &lt; (b)) ? (a) : (b))
#endif

#endif  /* NOMINMAX */
</code></pre>
<h2 id="方案二">方案二:</h2>
<h4 id="程序里面要使用标准库-stdmin和stdmax">程序里面要使用标准库 std::min和std::max</h4>
<pre><code class="language-cpp">#define NOMINMAX
#undef max
#undef min
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++17：folder expression（折叠表达式）]]></title>
        <id>https://blog.myxy.net/c17folder-expressionzhe-die-biao-da-shi/</id>
        <link href="https://blog.myxy.net/c17folder-expressionzhe-die-biao-da-shi/">
        </link>
        <updated>2020-05-08T06:15:00.000Z</updated>
        <content type="html"><![CDATA[<p>（1）先举一个不是很恰当的例子给大家看一下折叠表达式具体是怎么使用的：</p>
<pre><code class="language-cpp">int sum_1_to_5()
{
  return (1 + 2 + 3 + 4 + 5);
}

sum_1_to_5();
</code></pre>
<p>我们使用</p>
<pre><code class="language-cpp">template&lt;typename ...Args&gt;
int sum(Args&amp;&amp;... args) 
{
    return (args + ... + 0); 
}

sum(1, 2, 3, 4, 5);
</code></pre>
<p>也就是说折叠表达式能够自动的将指定的操作应用于形参包。<code>(args + ... + 0)</code> 等价于<code>(1+2+3+4+5+0)</code></p>
<p>（2）语法</p>
<pre><code class="language-cpp">( pack op ... )                             (1) 
( ... op pack )                             (2) 
( pack op ... op init )                 (3) 
( init op ... op pack )                 (4) 
</code></pre>
<p><code>pack</code>指的是参数包，<code>op</code>指的是具体的操作，<code>init</code>指的是具体的初始值。<br>
上述的语法等价于<br>
(1) 称为一元右折叠：unary right fold<br>
(2) 称为一元左折叠：unary left fold<br>
(3) 称为二元右折叠：binary right fold<br>
(4) 称为二元左折叠：binary left fold<br>
上述的表达式等价于：<br>
<code>(E op ...)</code> &lt;=&gt; <code>(E1 op (... op (E N-1 op EN))) （1）</code><br>
<code>(... op E)</code>&lt;=&gt; <code>(((E1 op E2) op ...) op EN) （2）</code><br>
<code>(E op ... op I)</code>&lt;=&gt; <code>(E1 op (... op (EN−1 op (EN op I)))) （3）</code><br>
<code>(I op ... op E)</code>&lt;=&gt; <code>((((I op E1) op E2) op ...) op EN) （4）</code><br>
E 为有N个元素的参数包，<code>op</code>为具体的操作符，<code>I</code>为初始值。在（3），（4）中，两个<code>op</code>一定要是一样的。</p>
<p>需要比较值得重点关注的一点是，二元<code>op</code>的取值范围为:<br>
<code>+</code>，<code>-</code>，<code>*</code>， <code>/</code>， <code>%</code>， <code>^</code>， <code>&amp;</code>， <code>|</code>， <code>=</code>， <code>&lt;</code>， <code>&gt;</code>， <code>&lt;&lt;</code>， <code>&gt;&gt;</code>， <code>+=</code>， <code>-=</code>， <code>*=</code>， <code>/=</code>， <code>%=</code>， <code>^=</code>， <code>&amp;=</code>， <code>|=</code>， <code>&lt;&lt;=</code>， <code>&gt;&gt;=</code>， <code>==</code>， <code>!=</code>， <code>&lt;=</code>， <code>&gt;=</code>， <code>&amp;&amp;</code>， <code>||</code> ，<code>,，</code> <code>.*</code>， <code>-&gt;*</code>。</p>
<p>再给大家两个比较简单的例子:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

//(1) ( pack op ... )
template&lt;class T, class... Args&gt;
void push_back_vec(std::vector&lt;T&gt;&amp; v, Args&amp;&amp;... args)
{
   static_assert((std::is_constructible_v&lt;T, Args&amp;&gt; &amp;&amp; ...));
   (v.push_back(args), ...);
}

//(4) (init op ... op pack)
template&lt;class ...Args&gt;
void printer(Args&amp;&amp;... args)
{
   (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; '\n';
}

int main()
{
   std::vector&lt;int&gt; v;
   push_back_vec(v, 6, 2, 45, 12);
   for (int i : v) std::cout &lt;&lt; i &lt;&lt; ' ';   //6 2 45 12
   std::cout &lt;&lt; &quot;\n&quot;;
   
   printer(1, 2, 3, &quot;abc&quot;);   //123abc
   return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++98、C++11使用C++17的 string_view]]></title>
        <id>https://blog.myxy.net/c98c11-shi-yong-c17-de-string_view/</id>
        <link href="https://blog.myxy.net/c98c11-shi-yong-c17-de-string_view/">
        </link>
        <updated>2020-05-08T04:09:36.000Z</updated>
        <content type="html"><![CDATA[<p>项目地址:<a href="https://github.com/martinmoene/string-view-lite">string-view-lite</a></p>
<p>使用示例:</p>
<pre><code class="language-cpp">#include &quot;nonstd/string_view.hpp&quot;
#include &lt;iostream&gt;

using namespace std::literals;
using namespace nonstd::literals;
using namespace nonstd;
    
void write( string_view sv )
{
    std::cout &lt;&lt; sv;
}

int main()
{
    write( &quot;hello&quot;     );   // C-string
    write( &quot;, &quot;s       );   // std::string
    write( &quot;world!&quot;_sv );   // nonstd::string_view
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[编程字体]]></title>
        <id>https://blog.myxy.net/bian-cheng-zi-ti/</id>
        <link href="https://blog.myxy.net/bian-cheng-zi-ti/">
        </link>
        <updated>2020-05-05T07:12:24.000Z</updated>
        <summary type="html"><![CDATA[<p>最近，微软和 JetBrains 纷纷推出了自己的编程字体，你现在在用哪款呢？</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近，微软和 JetBrains 纷纷推出了自己的编程字体，你现在在用哪款呢？</p>
<!-- more -->
<p><a href="https://github.com/belluzj/fantasque-sans">Fantasque Sans Mono</a>它是专门为程序员打造</p>
<p><a href="https://www.jetbrains.com/lp/mono/">JetBrains Mono</a>JetBrains 出的一款编程字体。主要特性包含增加字母高度，以获得更好的阅读体验；符号的独特性，例如 0 中间包含一个点；9°角的斜体设计等。</p>
<p><a href="https://github.com/microsoft/cascadia-code">Cascadia Code</a> 微软出的一款编程字体,它被默认集成到了 Windows Terminal 终端命令程序.</p>
]]></content>
    </entry>
</feed>