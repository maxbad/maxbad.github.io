<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.myxy.net</id>
    <title>Maxbad`Blog</title>
    <updated>2021-03-19T11:26:41.418Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.myxy.net"/>
    <link rel="self" href="https://blog.myxy.net/atom.xml"/>
    <subtitle>记录一些东西</subtitle>
    <logo>https://blog.myxy.net/images/avatar.png</logo>
    <icon>https://blog.myxy.net/favicon.ico</icon>
    <rights>All rights reserved 2021, Maxbad`Blog</rights>
    <entry>
        <title type="html"><![CDATA[VUE components 组件用法]]></title>
        <id>https://blog.myxy.net/vue-components-zu-jian-yong-fa/</id>
        <link href="https://blog.myxy.net/vue-components-zu-jian-yong-fa/">
        </link>
        <updated>2021-03-19T06:13:34.000Z</updated>
        <content type="html"><![CDATA[<p><em>子组件给父组件传递数据</em></p>
<pre><code class="language-js">子组件中：
this.showFaceDia = false  
this.$emit('showFaceDia',this.showFaceDia)  //执行showFaceDia函数并把要改变的值作为参数带过去

父组件：
methods:{
showFaceDia(msg){
    this.showFaceDia = msg
  }
}
不要忘记在DOM中引用：
&lt;test :title=&quot;title&quot; @showFaceDia=&quot;showFaceDia&quot;&gt;&lt;/test&gt;//注意showFaceDia后不能加括号

</code></pre>
<p><em>父组件调用子组件的方法</em></p>
<pre><code class="language-js">//父组件
&lt;v-test :title=&quot;title&quot; ref=&quot;aa&quot;&gt;&lt;/v-test&gt; //通过ref为子组件赋予ID引用
&lt;div @click=&quot;getChild()&quot;&gt;&lt;/div&gt;
getChild(){
  this.$refs.aa.childFun()   // 此处使用
}
</code></pre>
<p><em>子组件调用父组件的方法</em></p>
<pre><code class="language-js">（1）直接在子组件中通过this.$parent.event来调用父组件的方法
（2）在子组件里用$emit向父组件触发一个事件，父组件监听这个事件就行了
实例:
子组件：
methods: {
        getParent () {
            this.$emit('togglePop')  //此处直接写父组件的事件名称
        }
    }
父组件：
DOM中：&lt;test :title=&quot;title&quot; @togglePop=&quot;togglePop&quot;&gt;&lt;/test&gt;
togglePop(){
            console.log('ddddddd')
        },
</code></pre>
<p><a href="https://www.jianshu.com/p/6dfb2d2cbc71">https://www.jianshu.com/p/6dfb2d2cbc71</a></p>
<p><a href="https://www.jianshu.com/p/816971e4269b">https://www.jianshu.com/p/816971e4269b</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[VUE子组件向父组件传值]]></title>
        <id>https://blog.myxy.net/vue-zi-zu-jian-xiang-fu-zu-jian-chuan-zhi/</id>
        <link href="https://blog.myxy.net/vue-zi-zu-jian-xiang-fu-zu-jian-chuan-zhi/">
        </link>
        <updated>2021-03-19T06:13:34.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-VUE">子组件中：
this.showFaceDia = false  
this.$emit('showFaceDia',this.showFaceDia)  //执行showFaceDia函数并把要改变的值作为参数带过去

父组件：
methods:{
showFaceDia(msg){
    this.showFaceDia = msg
  }
}
不要忘记在DOM中引用：
&lt;test :title=&quot;title&quot; @showFaceDia=&quot;showFaceDia&quot;&gt;&lt;/test&gt;//注意showFaceDia后不能加括号

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[VUE 子组件设置scoped]]></title>
        <id>https://blog.myxy.net/vue-zi-zu-jian-she-zhi-scoped/</id>
        <link href="https://blog.myxy.net/vue-zi-zu-jian-she-zhi-scoped/">
        </link>
        <updated>2021-03-18T08:19:21.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-css">&lt;style lang=&quot;less&quot; scoped&gt;
/deep/.ivu-tree-arrow{
  padding-top: 10px 0;
}
&lt;/style&gt;
</code></pre>
<p><em>问题</em><br>
使用 <code>scoped</code> 后，父组件的样式将不会渗透到子组件中。但是一个子组件的根节点会同时受其父组件的 scoped CSS 和子组件的 scoped CSS 的影响。</p>
<p><em>解决方案</em><br>
使用深度作用选择器，即 <code>&gt;&gt;&gt;</code> 操作符，或使用 <code>/deep/</code> 或 <code>::v-deep</code> 操作符，后两者都是 <code>&gt;&gt;&gt;</code> 的别名，三者效果一样。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从资源文件中加载二进制数据]]></title>
        <id>https://blog.myxy.net/cong-zi-yuan-wen-jian-zhong-jia-zai-er-jin-zhi-shu-ju/</id>
        <link href="https://blog.myxy.net/cong-zi-yuan-wen-jian-zhong-jia-zai-er-jin-zhi-shu-ju/">
        </link>
        <updated>2021-03-12T11:34:09.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-cpp">
	static uint8_t* load_binary (HMODULE hModule, LPCTSTR resType, LPCTSTR resName) {
		HRSRC _hRsrc = ::FindResource (hModule, resName, resType);
		if (!_hRsrc)
			return nullptr;
		HGLOBAL _hGlobal = ::LoadResource (hModule, _hRsrc);
		if (!_hGlobal)
			return nullptr;
		LPVOID _src_ptr = ::LockResource (_hGlobal);
		DWORD _size = ::SizeofResource (hModule, _hRsrc);
		uint8_t *_ptr = new uint8_t [_size];
		memcpy (_ptr, _src_ptr, _size);
		//::UnlockResource (_hGlobal);
		::FreeResource (_hGlobal);
		return _ptr;
	}


    uint8_t *pdata =load_binary ((HMODULE) CPaintManagerUI::GetInstance (), _T (&quot;IPDB&quot;), MAKEINTRESOURCE (IDR_IPDB1));
if (pdata) {
			delete [] pdata;
			pdata = nullptr;
		}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows环境下“路径”处理]]></title>
        <id>https://blog.myxy.net/windows-huan-jing-xia-lu-jing-chu-li/</id>
        <link href="https://blog.myxy.net/windows-huan-jing-xia-lu-jing-chu-li/">
        </link>
        <updated>2021-03-12T03:11:38.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-cpp">#include &lt;Shlwapi.h&gt;
#pragma comment(lib, &quot;shlwapi.lib&quot;)


// 路径截断与合并函数
PathRemoveArgs                去除路径后面的参数
PathRemoveBackslash           去除路径最后的反斜杠“\”
PathAddBackslash              在路径最后加上反斜杠“\”
PathRemoveBlanks              去除路径前后的空格
PathAddExtension              在文件路径后面加上扩展名
PathRemoveExtension           去除文件路径扩展名
PathRenameExtension           更改文件路径扩展名
PathRemoveFileSpec            去除文件名，得到目录
PathUnquoteSpaces             去除路径中的首尾引号
PathQuoteSpaces               判断路径中是否有空格，有的话，就是用“”引号把整个路径包含起来
PathAppend                    将一个路径追加到另一个路径后面
PathCombine                   合并两个路径
PathSkipRoot                  去掉路径中的磁盘符或UNC部分。
PathStripPath                 去掉路径中的目录部分，得到文件名。
PathStripToRoot               去掉路径的文件部分，得到根目录。
PathCompactPath               根据像素值生成符合长度的路径。
                              如原始路径：          C:\path1\path2\sample.txt
                              根据120像素截断后为：  C:\pat...\sample.txt
                              根据25像素截断后为:   ...\sample.txt
 
PathCompactPathEx             根据字符个数来生成符合长度的路径。
PathSetDlgItemPath            将路径数据设置到对话框的子控件上。
PathUndecorate                去除路径中的修饰 
PathUnExpandEnvStrings        将路径中部分数据替换为系统环境变量格式

// 路径查找比较函数
PathFindOnPath                从路径中查找路径
PathFindExtension             查找路径的扩展名
PathFindFileName              获取路径的文件名
PathFindNextComponent         查找匹配路径（不太熟悉）
PathFindSuffixArray           查找给定的文件名是否有给定的后缀。
PathGetArgs                   获取路径参数
PathGetCharType               获取路径字符类型
PathGetDriveNumber            根据逻辑盘符返回驱动器序号

// 路径验证函数
PathCleanupSpec               去除路径中不合法的字符
PathCommonPrefix              比较并提取两个路径相同的前缀
PathFileExists                验证路径是否存在
PathMatchSpec                 判断路径是否匹配制定的扩展名。
PathIsDirectory               判断路径是否是一个有效的目录
PathIsFileSpec                验证路径是否一个文件名（有可能是一个路径）
PathIsExe                     验证路径是否是可执行文件。注意：不仅仅是.exe，还有.bat，.com，.src等
PathIsRoot                    路径是否为根路径
PathIsRelative                判断路径是否是相对路径
PathIsContentType             检测文件是否为制定类型。
                              例如：PathIsContentType( “hello.txt” , “text/plain” ) 返回TRUE
　                                  PathIsContentType( “hello.txt” , “image/gif” ) 返回FALSE
PathIsHTMLFile                判断路径是否是html文件类型——根据系统注册类型判断。
PathIsLFNFileSpec             判断路径是否是长路径格式
PathIsNetworkPath             判断路径是否是一个网络路径。
PathIsPrefix                  判断路径是否含有指定前缀
PathIsSameRoot                判断路径是否有相同根目录
PathIsSlow                    判断路径是否是一个高度延迟的网络连接
PathIsSystemFolder            判断路径是否有系统属性（属性可以自己设定）
PathIsUNC                     路径是否是UNC格式（网络路径）
PathIsUNCServer               路径是否是UNC服务器
PathIsUNCServerShare          路径是否仅仅是UNC的共享路径格式
PathIsURL                     路径是否是http格式。
PathYetAnotherMakeUniqueName  基于已存在的文件，自动创建一个唯一的文件名。比较有用，比如存在“新建文件”，此函数会创建文件名“新建文件夹 (2)”。



</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[取EXE文件自身所在的文件夹]]></title>
        <id>https://blog.myxy.net/qu-exe-wen-jian-zi-shen-suo-zai-de-wen-jian-jia/</id>
        <link href="https://blog.myxy.net/qu-exe-wen-jian-zi-shen-suo-zai-de-wen-jian-jia/">
        </link>
        <updated>2021-03-12T02:29:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="方式一">方式一:</h2>
<pre><code class="language-cpp">
TCHAR run_path[MAX_PATH] = { 0, };
//获取应用程序或者DLL的完整路径
::GetModuleFileName(NULL, run_path, MAX_PATH);
//去掉路径末尾的文件名留下反斜杠
(_tcsrchr(run_path, TEXT('\\')))[1] = 0;
// 设置运行目录
::SetCurrentDirectory(run_path);
</code></pre>
<h2 id="方式二">方式二:</h2>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;Shlwapi.h&gt;
#pragma comment(lib,&quot;shlwapi.lib&quot;)
 
int main()  
{  
	TCHAR szPath[MAX_PATH];
	//获取应用程序或者DLL的完整路径
	::GetModuleFileName(NULL, szPath, MAX_PATH);
	//去掉路径末尾的文件名和反斜杠
	::PathRemoveFileSpec(szPath);
 
	printf(&quot;%ls\n&quot;, szPath);
 
	return 0;
}
</code></pre>
<h2 id="方式三">方式三</h2>
<pre><code class="language-cpp">void GetModuleFilePath(IN char* pPath, IN DWORD nSize)
{
	char path_buffer[_MAX_PATH] = { 0 };
	char drive[_MAX_DRIVE] = { 0 };
	char dir[_MAX_DIR] = { 0 };
	char fname[_MAX_FNAME] = { 0 };
	char ext[_MAX_EXT] = { 0 };
	if (NULL == pPath)
	{
		return;
	}
	GetModuleFileNameA(NULL, path_buffer, _MAX_PATH);
	_splitpath(path_buffer, drive, dir, fname, ext);
	strcat(pPath, drive);
	strcat(pPath, dir);
}

	char path_buffer[_MAX_PATH] = { 0 };
	GetModuleFilePath(path_buffer, _MAX_PATH);

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[打印 HRESULT 返回值]]></title>
        <id>https://blog.myxy.net/da-yin-hresult-fan-hui-zhi/</id>
        <link href="https://blog.myxy.net/da-yin-hresult-fan-hui-zhi/">
        </link>
        <updated>2021-03-09T05:01:52.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-cpp">#include &lt;comdef.h&gt;
 
 // 打开服务
HRESULT pulhResult = 0;
SC_HANDLE schSCManager;
schSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
if (NULL == schSCManager)
{
    pulhResult = HRESULT_FROM_WIN32(GetLastError());
    // 方法一
    _com_error err(pulhResult);
    LPCTSTR errMsg = err.ErrorMessage();
    wprintf(L&quot;%s&quot;,errMsg);
    // 方法二
 std::string err_msg =   std::system_category().message(pulhResult)
printf(&quot;%s&quot;,err_msg.c_str());

    return pulhResult;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ 类的关键字]]></title>
        <id>https://blog.myxy.net/c-lei-de-guan-jian-zi/</id>
        <link href="https://blog.myxy.net/c-lei-de-guan-jian-zi/">
        </link>
        <updated>2021-03-08T07:39:32.000Z</updated>
        <content type="html"><![CDATA[<h1 id="final">final</h1>
<ul>
<li>禁用继承</li>
</ul>
<blockquote>
<p>C++11中允许将类标记为final，方法时直接在类名称后面使用关键字final，如此，意味着继承该类会导致编译错误。</p>
</blockquote>
<pre><code class="language-cpp">class Super final
{
    // 
};

</code></pre>
<ul>
<li>禁用重写
<blockquote>
<p>C++中还允许将方法标记为fianal，这意味着无法再子类中重写该方法。这时final关键字至于方法参数列表后面，如下</p>
</blockquote>
</li>
</ul>
<pre><code class="language-cpp">class Super
{
  public:
    Supe();
    virtual void SomeMethod() final;
};

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[限定对象只能在堆上创建]]></title>
        <id>https://blog.myxy.net/xian-ding-dui-xiang-zhi-neng-zai-dui-shang-chuang-jian/</id>
        <link href="https://blog.myxy.net/xian-ding-dui-xiang-zhi-neng-zai-dui-shang-chuang-jian/">
        </link>
        <updated>2021-03-08T06:46:28.000Z</updated>
        <content type="html"><![CDATA[<p><strong>限定对象在堆上创建的需求</strong></p>
<blockquote>
<blockquote>
<p>C++对象的一些使用场景其实已经有这种隐喻了，比如一个对象从std::enable_shared_from_this派生，当我们调用this-&gt;shared_from_this()的前提条件是这个对象已经被创建为shared_ptr，如果是一个栈对象去调用shared_from_this时会crash，所以使用派生于std::enable_shared_from_this的对象时，限定它只能在堆上创建可以保证代码的安全性。</p>
</blockquote>
</blockquote>
<pre><code class="language-cpp">struct dummy{
    class token{
    private:
        token(){}
        friend dummy;
    };

    static std::shared_ptr&lt;dummy&gt; create(){
      return std::make_shared&lt;dummy&gt;(token{});
    }

    dummy(token) : dummy() {
    }

private:
    dummy(){}
};

int main() {
  dummy d{}; //compile error
  dummy d(token{}); //compile error
  auto ptr = dummy::create(); //ok
}
</code></pre>
<p>这个代码借助了一个私有内部类token来避免在栈上创建dummy对象，因为外面无法访问这个token，只有它的友元类dummy才能访问token。另外一个问题是dummy的构造函数还是私有的，为什么这次改造之后可以用std::make_shared了？因为这里先通过public的dummy(token)去构造dummy对象的，然后dummy通过代理构造函数dummy()去真正构造一个dummy对象。</p>
<p>这个token在这里有两个作用，一个是用来避免在栈上构造dummy对象，一个是提供一个public的构造函数给std::make_shared使用。对于创建一个std::unique_ptr对象来说思路也是一样的，读者可以自行实现。至此，我们比较完美地实现了限定对象只能在堆上创建的目标。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程安全-map]]></title>
        <id>https://blog.myxy.net/xian-cheng-an-quan-map/</id>
        <link href="https://blog.myxy.net/xian-cheng-an-quan-map/">
        </link>
        <updated>2021-03-06T03:11:58.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-cpp">#pragma once
#include &lt;map&gt;
#include &lt;mutex&gt;

template&lt;typename Key, typename Val&gt;
class SafeMap
{
public:
	typedef typename std::map&lt;Key, Val&gt;::iterator this_iterator;
	typedef typename std::map&lt;Key, Val&gt;::const_iterator this_const_iterator;
	Val&amp; operator [](const Key&amp; key)
	{
		std::lock_guard&lt;std::mutex&gt; lk(mtx_);
		return dataMap_[key];
	}

	int erase(const Key&amp; key)
	{
		std::lock_guard&lt;std::mutex&gt; lk(mtx_);
		return dataMap_.erase(key);
	}

	this_iterator find(const Key&amp; key)
	{
		std::lock_guard&lt;std::mutex&gt; lk(mtx_);
		return dataMap_.find(key);
	}

	this_const_iterator find(const Key&amp; key) const
	{
		std::lock_guard&lt;std::mutex&gt; lk(mtx_);
		return dataMap_.find(key);
	}

	this_iterator end()
	{
		return dataMap_.end();
	}

	this_const_iterator end() const
	{
		return dataMap_.end();
	}

private:
	std::map&lt;Key, Val&gt; dataMap_;
	std::mutex mtx_;
};
</code></pre>
]]></content>
    </entry>
</feed>