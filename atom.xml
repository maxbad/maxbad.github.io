<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.myxy.net</id>
    <title>Maxbad`Blog</title>
    <updated>2020-11-04T13:00:26.525Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.myxy.net"/>
    <link rel="self" href="https://blog.myxy.net/atom.xml"/>
    <subtitle>记录一些东西</subtitle>
    <logo>https://blog.myxy.net/images/avatar.png</logo>
    <icon>https://blog.myxy.net/favicon.ico</icon>
    <rights>All rights reserved 2020, Maxbad`Blog</rights>
    <entry>
        <title type="html"><![CDATA[debug调试打印日志]]></title>
        <id>https://blog.myxy.net/debug-diao-shi-da-yin-ri-zhi/</id>
        <link href="https://blog.myxy.net/debug-diao-shi-da-yin-ri-zhi/">
        </link>
        <updated>2020-11-04T12:59:54.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-cpp">#ifdef _DEBUG
#define DBG_PRINTF(format,...) printf(&quot;Func:%s,Line[%05d]: &quot;format&quot;\n&quot;, __FUNCTION__,__LINE__, ##__VA_ARGS__)
#else
#define DBG_PRINTF(format,...)
#endif
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ptrdiff_t]]></title>
        <id>https://blog.myxy.net/ptrdiff_t/</id>
        <link href="https://blog.myxy.net/ptrdiff_t/">
        </link>
        <updated>2020-11-04T02:50:59.000Z</updated>
        <content type="html"><![CDATA[<p>int =&gt; ptrdiff_t<br>
usigned int =&gt; size_t</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解决DragQueryFile()在x64下获取文件数量为0]]></title>
        <id>https://blog.myxy.net/jie-jue-dragqueryfilezai-x64-xia-huo-qu-wen-jian-shu-liang-wei-0/</id>
        <link href="https://blog.myxy.net/jie-jue-dragqueryfilezai-x64-xia-huo-qu-wen-jian-shu-liang-wei-0/">
        </link>
        <updated>2020-10-30T03:20:32.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-cpp">HDROP hDrop = NULL;

HANDLE hProcessHeap = ::GetProcessHeap();
if (NULL != hProcessHeap &amp;&amp; ::HeapLock(hProcessHeap))
{
  PROCESS_HEAP_ENTRY heapEntry = { 0 };
  while(::HeapWalk(hProcessHeap, &amp;heapEntry) != FALSE)
  {
    if ((heapEntry.wFlags &amp; PROCESS_HEAP_ENTRY_BUSY) != 0)
    {
      HGLOBAL hGlobal = ::GlobalHandle(heapEntry.lpData);
      // Assuming wParam is the WM_DROPFILES WPARAM
      if ((((DWORD_PTR) hGlobal) &amp; 0xFFFFFFFF) == (wParam &amp; 0xFFFFFFFF))
      {
        hDrop = (HDROP) hGlobal; // We got it !!
        break;
      }
    }
  }
  ::HeapUnlock(hProcessHeap);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iview]]></title>
        <id>https://blog.myxy.net/iview/</id>
        <link href="https://blog.myxy.net/iview/">
        </link>
        <updated>2020-10-29T06:23:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="样式覆盖">样式覆盖</h1>
<p>样式文件:  <code>src\styles\default\index.less</code></p>
<pre><code class="language-style">// 下拉框,时间弹出动画速度
@animation-time:.3x;    
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[hp-socket 内存加载失败]]></title>
        <id>https://blog.myxy.net/hp-socket-nei-cun-jia-zai-shi-bai/</id>
        <link href="https://blog.myxy.net/hp-socket-nei-cun-jia-zai-shi-bai/">
        </link>
        <updated>2020-10-27T05:40:44.000Z</updated>
        <content type="html"><![CDATA[<p><code>c/c++</code> - <code>命令行</code>  增加  <code>/Zc:threadSafeInit-</code> (注意后面的减号)</p>
<p><a href="https://docs.microsoft.com/zh-cn/cpp/build/reference/zc-threadsafeinit-thread-safe-local-static-initialization?view=vs-2019">https://docs.microsoft.com/zh-cn/cpp/build/reference/zc-threadsafeinit-thread-safe-local-static-initialization?view=vs-2019</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11 生产者消费者]]></title>
        <id>https://blog.myxy.net/c11-sheng-chan-zhe-xiao-fei-zhe/</id>
        <link href="https://blog.myxy.net/c11-sheng-chan-zhe-xiao-fei-zhe/">
        </link>
        <updated>2020-10-21T10:50:13.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-CPP">#include &lt;iostream&gt;
#include &lt;deque&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;
#include&lt;Windows.h&gt;
using namespace std;

deque&lt;int&gt; q;
mutex mu;
condition_variable cond;
int c = 0;//缓冲区的产品个数

void producer() { 
 int data1;
 while (1) {//通过外层循环，能保证生产不停止
  if(c &lt; 3) {//限流
   {
    data1 = rand();
    unique_lock&lt;mutex&gt; locker(mu);//锁
    q.push_front(data1);
    cout &lt;&lt; &quot;存了&quot; &lt;&lt; data1 &lt;&lt; endl;
    cond.notify_one();  // 通知取
    ++c;
   }
   Sleep(500);
  }
 }
}

void consumer() {
 int data2;//data用来覆盖存放取的数据
 while (1) {
  {
   unique_lock&lt;mutex&gt; locker(mu);
   while(q.empty())
    cond.wait(locker); //wait()阻塞前先会解锁,解锁后生产者才能获得锁来放产品到缓冲区；生产者notify后，将不再阻塞，且自动又获得了锁。
   data2 = q.back();//取的第一步
   q.pop_back();//取的第二步
   cout &lt;&lt; &quot;取了&quot; &lt;&lt; data2&lt;&lt;endl;
   --c;
  }
  Sleep(1500);
 }
}
int main() {
 thread t1(producer);
 thread t2(consumer);
 t1.join();
 t2.join();
 return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[系统服务弹出信息框!]]></title>
        <id>https://blog.myxy.net/xi-tong-fu-wu-dan-chu-xin-xi-kuang/</id>
        <link href="https://blog.myxy.net/xi-tong-fu-wu-dan-chu-xin-xi-kuang/">
        </link>
        <updated>2020-10-20T11:04:20.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-cpp">// dllmain.cpp : 定义 DLL 应用程序的入口点。
#include &quot;pch.h&quot;
#include &lt;tchar.h&gt;
#include &lt;WtsApi32.h&gt;
#pragma comment(lib, &quot;WtsApi32.lib&quot;)

void ShowMessage(TCHAR* lpszMessage, TCHAR* lpszTitle)
{
	// 获取当前的Session ID
	DWORD dwSessionId = ::WTSGetActiveConsoleSessionId();
	// 显示消息对话框
	DWORD dwResponse = 0;
	::WTSSendMessage(WTS_CURRENT_SERVER_HANDLE, dwSessionId,
		lpszTitle, static_cast&lt;DWORD&gt;((_tcslen(lpszTitle) + 1) * sizeof(TCHAR)),
		lpszMessage, static_cast&lt;DWORD&gt;((_tcslen(lpszMessage) + 1) * sizeof(TCHAR)),
		MB_ICONINFORMATION, 0 /*wait indefinitely*/, &amp;dwResponse, TRUE);
}

BOOL APIENTRY DllMain(HMODULE hModule,
	DWORD  ul_reason_for_call,
	LPVOID lpReserved
)
{
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
	{
		ShowMessage(TEXT(&quot;DLL_PROCESS_加载&quot;), TEXT(&quot;Tips:&quot;));
	}
	break;
	case DLL_THREAD_ATTACH:
	{
		ShowMessage(TEXT(&quot;DLL_THREAD_加载&quot;), TEXT(&quot;Tips:&quot;));
	}
	break;
	case DLL_THREAD_DETACH:
	{
		ShowMessage(TEXT(&quot;DLL_THREAD_销毁&quot;), TEXT(&quot;Tips:&quot;));
	}
	break;
	case DLL_PROCESS_DETACH:
	{
		ShowMessage(TEXT(&quot;DLL_PROCESS_销毁&quot;), TEXT(&quot;Tips:&quot;));
	}
	break;
	}
	return TRUE;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++基础 – 容器 – VECTOR]]></title>
        <id>https://blog.myxy.net/cji-chu-rong-qi-vector/</id>
        <link href="https://blog.myxy.net/cji-chu-rong-qi-vector/">
        </link>
        <updated>2020-10-20T01:39:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="vector">vector</h2>
<blockquote>
<p>动态连续数组， 头文件 &lt; vector &gt;</p>
</blockquote>
<ul>
<li>定义：</li>
</ul>
<pre><code class="language-cpp">template&lt;
    class T,
    class Allocator = std::allocator&lt;T&gt;
&gt; class vector;
</code></pre>
<ul>
<li>参数解释：</li>
</ul>
<ol>
<li>T 元素类型<br>
T必须满足可拷贝复制（CopyAssignable）和可拷贝构造（CopyConstructible）的要求</li>
<li>Allocator 用于获取/释放内存及构造/析构内存中元素的分配器</li>
</ol>
<p>常用函数<br>
<code>operator[]</code></p>
<pre><code class="language-cpp">refrence operator[](size_type pos);
const_refrence operator[](size_type pos) const;
</code></pre>
<p>返回给定pos位置的元素引用，不检查边界</p>
<p><code>at()</code></p>
<pre><code class="language-cpp">refrence at(size_type pos);
const_refrence at(size_type pos) const;
</code></pre>
<p>返回给定pos位置的元素引用，会进行边界检查。如果给定pos超出边界，会报异常 std::out_of_range</p>
<h3 id="示例">示例：</h3>
<blockquote>
<p>(演示operator[] 和 at() 使用上面的差别)</p>
</blockquote>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;iostream&gt;

int main(int argc, char** argv) {
    std::vector&lt;int&gt; int_vecs = {2, 3, 4, 5}; //c++ 11
    std::cout &lt;&lt; int_vecs[3] &lt;&lt; std::endl; // 输出：5
    int_vecs[3] = 6;
    std::cout &lt;&lt; int_vecs[3] &lt;&lt; std::endl; // 输出：6

    std::cout &lt;&lt; int_vecs.at(2) &lt;&lt; std::endl; // 输出：4
    int_vecs.at(2) = 8;
    std::cout &lt;&lt; int_vecs.at(2) &lt;&lt; std::endl; // 输出：8

    try {
        std::cout &lt;&lt; int_vecs.at(4) &lt;&lt; std::endl; // 跑出越界异常 std::out_of_range
    } catch (std::exception&amp; e) {
        std::cout &lt;&lt; e.what() &lt;&lt; std::endl; //打印异常信息
    }

    //遍历
    for(size_t i = 0; i &lt; int_vecs.size(); ++i) {
        std::cout &lt;&lt; int_vecs[i] &lt;&lt; std::endl;
        std::cout &lt;&lt; int_vecs.at(i) &lt;&lt; std::endl;
    }

    std::cout &lt;&lt; int_vecs[4] &lt;&lt; std::endl; //程序崩溃
    return 0;
}

//编译 &amp; 运行
//g++ -std=c++11 main.cc -o test &amp; ./test
</code></pre>
<p><code>front()</code></p>
<pre><code class="language-cpp">refrence front();
const_refrence front() const;
</code></pre>
<p>返回容器中第一个元素的引用。如果容器为空，调用可能会出现coredump</p>
<p><code>back()</code></p>
<pre><code class="language-cpp">refrence back();
const_refrence back() const;
</code></pre>
<p>返回容器中最后一个元素的引用。如果容器为空，调用可能会出现coredump</p>
<p><code>empty()</code></p>
<pre><code class="language-cpp">bool empty() const;
</code></pre>
<p>检查容器是否为空</p>
<p><code>size()</code></p>
<pre><code class="language-cpp">size_type size() const;
</code></pre>
<p>返回容器中元素的个数</p>
<p><code>capacity()</code></p>
<pre><code class="language-cpp">size_type capacity() const;
</code></pre>
<p>返回容器当前已分配的元素数</p>
<p><code>reserve()</code></p>
<pre><code class="language-cpp">void reserve(size_type new_cap);
</code></pre>
<p>增加容器的容量到大于或者等于new_cap的值。如果new_cap大于当前的capacity(),则分配新存储，否则该方法不做任何事。reserve不会更改容器的size<br>
如果new_cap大于capacity(),则所有迭代器，包括尾迭代器(end,cend)都失效</p>
<p><code>resize()</code></p>
<pre><code class="language-cpp">void resize(size_type count, T value = T());
</code></pre>
<p>重新设置容器大小为count<br>
当前大小大于count，则减少容器元素个数<br>
当前大小小于count，则往后添加额外的元素，并以value的副本初始化<br>
当前capacity()小于count，则重新分配内存capacity()发生变化</p>
<p><code>push_back()</code></p>
<pre><code class="language-cpp">void push_back(const T&amp; value);
void push_back(T&amp;&amp; vlaue); //(c++11)
</code></pre>
<p>把元素添加到容器的末尾，如果新的size()大于capacity(),则所有迭代器（包括尾迭代器)失效</p>
<p><code>pop_back()</code></p>
<pre><code class="language-cpp">void pop_back();
</code></pre>
<p>移除容器的末尾元素，在空容器上调用，会产生未定义行为。</p>
<p><code>emplace_back()</code></p>
<pre><code class="language-cpp">template&lt;class... Args&gt;
iterator emplace_back(Args&amp;&amp; args); //(C++11)
</code></pre>
<p>添加新元素到容器末尾，在容器所提供的位置原位构造元素。可以避免push_back时额外复制或移动操作</p>
<p><code>insert()</code></p>
<pre><code class="language-cpp">iterator insert(iterator pos, const T&amp; value);
iterator insert(iterator pos, size_type count, const T&amp; value);
template&lt;class InputIt&gt;
iterator insert(iterator pos, InputIt first, InputIt last)
</code></pre>
<ol>
<li>在pos前插入value，并返回iterator指向value</li>
<li>在pos前插入value的count个副本，并返回指向插入的第一个value的iterator，如果count = 0，返回pos</li>
<li>在pos前插入来自范围[first, last)的元素，并返回指向插入的第一个元素的iterator，如果范围为空，则返回pos</li>
</ol>
<p><code>erase()</code></p>
<pre><code class="language-cpp">iterator erase(iterator pos);
iterator erase(iterator first, iterator last);
</code></pre>
<ol>
<li>移除位于pos的元素， pos需要能合法，可解引用</li>
<li>移除范围[first, last)中的元素<br>
使删除点之后的元素的迭代器失效</li>
</ol>
<h3 id="基础使用示例">基础使用示例:</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

template&lt;class T&gt;
void print(const std::vector&lt;T&gt;&amp; vec) {
    for(auto it = vec.begin(); it != vec.end(); ++it) {
        if(it != vec.begin()) {
            std::cout &lt;&lt; &quot; &quot;;
        }
        std::cout &lt;&lt; *it;
    }
    std::cout &lt;&lt; std::endl;
}

template&lt;class T&gt;
void print_size(const std::vector&lt;T&gt;&amp; vec) {
    std::cout &lt;&lt; &quot;size=&quot; &lt;&lt; vec.size() &lt;&lt; &quot; capacity=&quot; &lt;&lt; vec.capacity() &lt;&lt; std::endl;
}

int main(int argc, char** argv) {
    std::vector&lt;int&gt; int_vec;
    int_vec.resize(3);

    print_size(int_vec); //输出: size=3 capacity=3
    int_vec.push_back(10);
    print_size(int_vec); //输出: size=4 capacity=6
    print(int_vec); //输出: 0 0 0 10
    int_vec.resize(3);
    print_size(int_vec); //输出: size=3 capacity=6
    print(int_vec); //输出: 0 0 0
    int_vec.reserve(3);
    print_size(int_vec); //输出: size=3 capacity=6

    auto it = int_vec.insert(int_vec.begin(), 10);
    print_size(int_vec); //输出: size=4 capacity=6
    print(int_vec); //输出: 10 0 0 0
    std::cout &lt;&lt; *it &lt;&lt; &quot; &quot; &lt;&lt; (it == int_vec.begin()) &lt;&lt; std::endl; //输出: 10 1

    std::cout &lt;&lt; int_vec.back() &lt;&lt; &quot; &quot; &lt;&lt; int_vec.front() &lt;&lt; std::endl; //输出： 0 10

    int_vec.push_back(11);
    print_size(int_vec); //输出: size=5 capacity=6
    print(int_vec); //输出: 10 0 0 0 11

    int_vec.emplace_back(12);
    print_size(int_vec); //输出: size=6 capacity=6
    print(int_vec); //输出: 10 0 0 0 11 12

    int_vec.emplace_back(13);
    print_size(int_vec); //输出: size=7 capacity=12
    print(int_vec); //输出: 10 0 0 0 11 12 13

    std::cout &lt;&lt; (it == int_vec.begin()) &lt;&lt; std::endl; //输出： 0

    //循环删除偶数
    for(auto it = int_vec.begin(); it != int_vec.end();) {
        if(*it % 2 == 0) {
            it = int_vec.erase(it);
        } else {
            ++it;
        }
    }

    print_size(int_vec); //输出: size=2 capacity=12
    print(int_vec); //输出: 11 13
    return true;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++基础 – 容器 – ARRAY]]></title>
        <id>https://blog.myxy.net/cji-chu-rong-qi-array/</id>
        <link href="https://blog.myxy.net/cji-chu-rong-qi-array/">
        </link>
        <updated>2020-10-20T01:35:46.000Z</updated>
        <content type="html"><![CDATA[<h2 id="array">array</h2>
<blockquote>
<p>c++11封装固定大小数组的容器。不同于vector，不能自动扩展。头文件 &lt; array &gt;</p>
</blockquote>
<ul>
<li>定义：</li>
</ul>
<pre><code class="language-cpp">template&lt;class T,
        std::size_t N
&gt; class array;
</code></pre>
<ul>
<li>参数解释:</li>
</ul>
<ol>
<li>T 元素类型</li>
<li>N 元素个数</li>
</ol>
<h2 id="常用函数">常用函数</h2>
<h2 id=""></h2>
<p><code>operator()</code></p>
<pre><code class="language-cpp">reference operator[](size_type pos);
const_reference operator[](size_type pos) const;
</code></pre>
<p>返回位于指定位置pos的元素的引用。不进行边界检查。</p>
<p><code>at()</code></p>
<pre><code class="language-cpp">reference at(size_type pos);
const_reference at(size_t pos) const;
</code></pre>
<p>返回位于指定位置pos的元素的引用。有边界检查。如果pos不在容器范围内，则抛出std::out_of_range类型的异常。</p>
<p><code>front()</code></p>
<pre><code class="language-cpp">reference front();
const_reference front() const;
</code></pre>
<p>返回容器的第一个元素的引用。在空容器上行为未定义。</p>
<p><code>back()</code></p>
<pre><code class="language-cpp">reference back();
const_reference back() const;
</code></pre>
<p>返回容器的最后一个元素的引用。在空容器上行为未定义。</p>
<p><code>data()</code></p>
<pre><code class="language-cpp">T* data() noexcept; //c++17
constexpr T* data() noexcept; //c++17
const T* data() const noexcept;
constexpr const T* data() const noexcept;
</code></pre>
<p>返回指向元素存储的底层数组的指针。指针满足范围[data(); data() + size())</p>
<p><code>empty()</code></p>
<pre><code class="language-cpp">constexpr bool empty() const noexcept;
</code></pre>
<p>检查容器是否为空</p>
<p><code>size()</code></p>
<pre><code class="language-cpp">size_type size() const noexcept;
</code></pre>
<p>返回容器可容纳的元素个数</p>
<p><code>fill()</code></p>
<pre><code class="language-cpp">void fill(const T&amp; value);
constexpr void fill(const T&amp; value); //c++20
</code></pre>
<p>将给定value赋值给所有元素</p>
<h3 id="简单使用示例">简单使用示例:</h3>
<pre><code class="language-cpp">#include &lt;array&gt;
#include &lt;iostream&gt;

int main(int argc, char** argv) {
    std::array&lt;int, 3&gt; arr = {1, 2, 3};
    for(size_t i = 0; i &lt; arr.size(); ++i) {
        if(i) {
            std::cout &lt;&lt; &quot; &quot;;
        }
        std::cout &lt;&lt; arr[i];
    }
    std::cout &lt;&lt; std::endl;

    try {
        arr.at(3) = 4;
    } catch (std::exception&amp; e) {
        std::cout &lt;&lt; &quot;exception: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;
    }

    arr[3] = 4; //未定义行为，可能会core
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++基础 – 容器 – LIST]]></title>
        <id>https://blog.myxy.net/cji-chu-rong-qi-list/</id>
        <link href="https://blog.myxy.net/cji-chu-rong-qi-list/">
        </link>
        <updated>2020-10-20T01:27:31.000Z</updated>
        <content type="html"><![CDATA[<h2 id="list">list</h2>
<blockquote>
<p>std::list支持从容器的任何位置快速插入和删除元素，不支持随机访问。双向链表,头文件：&lt; list &gt;</p>
</blockquote>
<ul>
<li>定义：</li>
</ul>
<pre><code class="language-cpp">template&lt;
    class T,
    class Allocator = std::allocator&lt;T&gt;
&gt; class list;
</code></pre>
<ul>
<li>参数解释：</li>
</ul>
<ol>
<li>T 元素类型,T必须满足可拷贝复制（CopyAssignable）和可拷贝构造（CopyConstructible）的要求</li>
<li>Allocator, 用于获取/释放内存及构造/析构内存中元素的分配器</li>
</ol>
<h2 id="常用函数">常用函数</h2>
<h2 id=""></h2>
<p><code>front()</code></p>
<pre><code class="language-cpp">reference front();
const_reference front() const;
</code></pre>
<p>返回容器的第一个元素的引用。空容器上行为未定义</p>
<p><code>back()</code></p>
<pre><code class="language-cpp">reference back();
const_reference back() const;
</code></pre>
<p>返回到容器中最后一个元素的引用。空容器上行为未定义</p>
<p><code>empty()</code></p>
<pre><code class="language-cpp">bool empty() const;
</code></pre>
<p>返回容器是否为空</p>
<p><code>size()</code></p>
<pre><code class="language-cpp">size_type size() const;
</code></pre>
<p>返回容器中元素个数</p>
<p><code>clear()</code></p>
<pre><code class="language-cpp">void clear();
</code></pre>
<p>删除容器内所有元素。调用后size()返回0</p>
<p><code>resize()</code></p>
<pre><code class="language-cpp">void resize(size_type count, T value = T());
</code></pre>
<p>重设容器的大小为count个元素。如果当前size()大于count，则在尾部增加元素，并以value的副本初始化。</p>
<p><code>insert()</code></p>
<pre><code class="language-cpp">iterator insert(iterator pos, const T&amp; value); //(1)
void insert(iterator pos, size_type count, const T&amp; value); //(2)
template&lt;class InputIt&gt;
void insert(iterator pos, InputIt first, InputIt last); //(3)
</code></pre>
<p>插入元素到容器的指定位置。</p>
<ol>
<li>在pos前插入value</li>
<li>在pos前插入value的count个副本</li>
<li>在pos前插入来自范围[first, last)的元素</li>
</ol>
<p><code>emplace()</code></p>
<pre><code class="language-cpp">template&lt;class... Args&gt;
iterator emplace(const_iterator pos, Args&amp;&amp;... args); //c++11
</code></pre>
<p>直接在pos前插入元素到容器，通过std::allocator_traits::construct构造元素,将参数args…作为std::forward<Args>(args)…转发给构造函数。返回指向插入元素的iterator</p>
<p><code>erase()</code></p>
<pre><code class="language-cpp">iterator erase(iterator pos); //(1)
iterator erase(iterator first, iterator last); //(2)
</code></pre>
<p>从容器内删除指定元素,返回被移除元素之后的迭代器</p>
<ol>
<li>删除位于pos的元素</li>
<li>删除范围[first, last)中的元素</li>
</ol>
<p><code>push_back()</code></p>
<pre><code class="language-cpp">void push_back(const T&amp; value);
</code></pre>
<p>将元素value添加到容器尾部</p>
<p><code>emplace_back()</code></p>
<pre><code class="language-cpp">template&lt;class... Args&gt;
void emplace_back(Args&amp;&amp;... args); //c++11
</code></pre>
<p>添加新元素到容器尾部。通过std::allocator_traits::construct构造，参数args…以std::forward(args)…转发到构造函数。</p>
<p><code>pop_back()</code></p>
<pre><code class="language-cpp">void pop_back();
</code></pre>
<p>移除容器最后一个元素。在空容器上调用，行为未定义</p>
<p><code>push_front()</code></p>
<pre><code class="language-cpp">void push_front(const T&amp; value);
</code></pre>
<p>将元素value添加到容器的头部</p>
<p><code>emplace_front()</code></p>
<pre><code class="language-cpp">template&lt;class... Args&gt;
void emplace_front(Args&amp;&amp;... args);
</code></pre>
<p>插入元素到容器开始，通过std::allocator_traits::construct构造元素,将参数args…作为std::forward(args)…转发给构造函数</p>
<p><code>pop_front()</code></p>
<pre><code class="language-cpp">void pop_front();
</code></pre>
<p>移除容器第一个元素,如果容器为空，则行为未定义</p>
<p><code>swap()</code></p>
<pre><code class="language-cpp">void swap(list&amp; other);
</code></pre>
<p>将内容和other的交换</p>
<p><code>merge()</code></p>
<pre><code class="language-cpp">void merge(list&amp; other); //(1)
template&lt;class T&gt;
void merge(list&amp; other, Compare comp) //(2)
</code></pre>
<p>归并两个已排序链表为一个。操作后other变为空。</p>
<ol>
<li>使用operator&lt; 归并</li>
<li>使用comp 归并</li>
</ol>
<p><code>splice()</code></p>
<pre><code class="language-cpp">void splice(const_iterator pos, list&amp; other); //(1)
void splice(const_iterator pos, list&amp; other, const_iterator it); //(2)
void splice(const_iterator pos, list&amp; other, const_iterator first, const_iterator last); //(3)
</code></pre>
<p>从一个list转移元素给另一个。不复制或者移动元素，仅重值向链表节点的内部指针。</p>
<ol>
<li>从other转移所有元素到<em>this中，元素被插入到pos指向的元素之前。操作后容器other变成空。如果other和</em>this指代同一对象则行为未定义</li>
<li>从other转移it所指代的元素到*this。元素被插入到pos所指向的元素之前。</li>
<li>从other转移范围[first, last)中的元素到*this。元素被插入到pos所指向的元素之前。如果pos是范围[first, last)中的迭代器则行为未定义</li>
</ol>
]]></content>
    </entry>
</feed>