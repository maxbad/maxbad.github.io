<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.myxy.net</id>
    <title>Maxbad`Blog</title>
    <updated>2021-01-11T03:55:02.314Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.myxy.net"/>
    <link rel="self" href="https://blog.myxy.net/atom.xml"/>
    <subtitle>记录一些东西</subtitle>
    <logo>https://blog.myxy.net/images/avatar.png</logo>
    <icon>https://blog.myxy.net/favicon.ico</icon>
    <rights>All rights reserved 2021, Maxbad`Blog</rights>
    <entry>
        <title type="html"><![CDATA[std::string 构造函数]]></title>
        <id>https://blog.myxy.net/stdstring-gou-zao-han-shu/</id>
        <link href="https://blog.myxy.net/stdstring-gou-zao-han-shu/">
        </link>
        <updated>2021-01-11T03:28:26.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>1,将构造的对象初始化为s的前n个字符，s不够n个时将相邻的内存单元的内容当作s的一部分继续复制:<br>
<code>string(const char *s, size_type n, const Allocator &amp;a = Allocator());</code></p>
<pre><code class="language-cpp">  std::string testStr(&quot;Telephone home.&quot;, 4);
  OutputDebugStringA(testStr.c_str());
  // 输出:Tele
</code></pre>
</li>
<li>
<p>2,将构造的对象初始化为s的后n个字符，也就是从s指向的内存的第n个字节开始复制：<br>
<code>string(const string &amp;str, size_type pos,size_type n = npos, const Allocator &amp;a = Allocator());</code></p>
</li>
</ul>
<pre><code class="language-cpp">    std::string text(&quot;Telephone home.&quot;);
    std::string testStr(text, 4);
    OutputDebugStringA(testStr.c_str());
    // 输出:phone home.
</code></pre>
<ul>
<li>3,创建一个n个字符的string对象：<br>
<code>string(size_type n, char c, const Allocator &amp;a = Allocator())</code><pre><code class="language-cpp">  std::string testStr(10, 'a');
  OutputDebugStringA(testStr.c_str());
  // 输出:aaaaaaaaaa
</code></pre>
</li>
</ul>
<p>其他文档:<a href="http://c.biancheng.net/view/1443.html">http://c.biancheng.net/view/1443.html</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue项目打包时，去掉console.log输出]]></title>
        <id>https://blog.myxy.net/vue-xiang-mu-da-bao-shi-qu-diao-consolelog-shu-chu/</id>
        <link href="https://blog.myxy.net/vue-xiang-mu-da-bao-shi-qu-diao-consolelog-shu-chu/">
        </link>
        <updated>2021-01-09T06:50:20.000Z</updated>
        <content type="html"><![CDATA[<p>安装插件：<code>npm install babel-plugin-transform-remove-console --save-dev</code></p>
<p>在<code>babel.config.js</code>文件的<code>plugins</code>中添加<code>transform-remove-console</code>，此时再build就不会有console警告了。</p>
<pre><code class="language-java">// 项目发布阶段需要用到的Babel插件
const prodPlugins = []
if (process.env.NODE_ENV === 'production') {
  prodPlugins.push('transform-remove-console')
}
module.exports = {
  presets: [
    '@vue/cli-plugin-babel/preset'
  ],
  plugins: [
    [
      'component',
      {
        libraryName: 'element-ui',
        styleLibraryName: 'theme-chalk'
      }
    ],
    // 发布产品时候的插件数组
    ...prodPlugins
  ]
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[proxy配置]]></title>
        <id>https://blog.myxy.net/proxy-pei-zhi/</id>
        <link href="https://blog.myxy.net/proxy-pei-zhi/">
        </link>
        <updated>2020-12-26T11:29:57.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-js">const address = require('address');
devServer: {
        publicPath: Setting.publicPath,
        host: address.ip(),
        noInfo: false,
        progress: true // 将运行进度输出到控制台。
         openPage: 'admin/version', // 默认打开页
         proxy: {
            '/v1': {
                target: 'http://' + address.ip() + ':8098',
                changeOrigin: true, // 是否跨域
                onProxyReq: function (proxyReq, req, res, options) {
                    console.log('发送', req.method, req.url);

                    if (req.body) {
                        console.log('发送 Body', req.body);
                    }
                },
                onProxyRes: function (proxyRes, req, res) {
                    console.log('收到', req.method, req.url);

                    let body = [];
                    proxyRes.on('data', function (chunk) {
                        body.push(chunk);
                    });
                    proxyRes.on('end', function () {
                        body = Buffer.concat(body).toString();
                        console.log('收到 Body', body);
                        // res.end('my response to cli');
                    });
                },
                onError: function (err, req, res) {
                    console.log('代理错误消息', err);
                },
                logLevel: 'debug'
            }
        } 
    },
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[prettier 配置]]></title>
        <id>https://blog.myxy.net/prettier-pei-zhi/</id>
        <link href="https://blog.myxy.net/prettier-pei-zhi/">
        </link>
        <updated>2020-12-22T03:42:30.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode">https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode</a></p>
<blockquote>
<p>自动格式化整理代码，vscode 需要去插件商店下载【Prettier - Code formatter 】这个插件</p>
</blockquote>
<pre><code class="language-json">{
  &quot;[vue]&quot;: {
    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;
  },
  &quot;editor.quickSuggestions&quot;: {
    &quot;strings&quot;: true
  },
  &quot;editor.tabSize&quot;: 2,
  &quot;editor.detectIndentation&quot;: false,
  &quot;emmet.triggerExpansionOnTab&quot;: true,
  &quot;editor.formatOnSave&quot;: true,
  &quot;javascript.format.enable&quot;: true,
  &quot;[json]&quot;: {
    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;
  },
  &quot;explorer.confirmDelete&quot;: false,
  &quot;javascript.updateImportsOnFileMove.enabled&quot;: &quot;always&quot;,
  &quot;typescript.updateImportsOnFileMove.enabled&quot;: &quot;always&quot;,
  &quot;files.exclude&quot;: {
    &quot;**/.idea&quot;: true
  },
  &quot;editor.codeActionsOnSave&quot;: {
    &quot;source.fixAll.stylelint&quot;: true,
    &quot;source.fixAll.eslint&quot;: true
  },
  &quot;[javascript]&quot;: {
    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;
  },
  &quot;[scss]&quot;: {
    &quot;editor.defaultFormatter&quot;: &quot;HookyQR.beautify&quot;
  },
  &quot;[jsonc]&quot;: {
    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;
  },
  &quot;[html]&quot;: {
    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;
  },
  &quot;editor.suggest.snippetsPreventQuickSuggestions&quot;: false,
  &quot;prettier.htmlWhitespaceSensitivity&quot;: &quot;ignore&quot;,
  &quot;prettier.vueIndentScriptAndStyle&quot;: true,
  &quot;vetur.format.defaultFormatter.html&quot;: &quot;prettier&quot;,
  &quot;files.autoSave&quot;: &quot;onFocusChange&quot;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ for遍历循环表达示 auto, auto&, auto&&]]></title>
        <id>https://blog.myxy.net/c-for-bian-li-xun-huan-biao-da-shi-auto-autoand-autoand/</id>
        <link href="https://blog.myxy.net/c-for-bian-li-xun-huan-biao-da-shi-auto-autoand-autoand/">
        </link>
        <updated>2020-12-18T06:44:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="创建拷贝无法修改dataarr中的元素">创建拷贝，无法修改dataArr中的元素</h2>
<pre><code class="language-cpp">for(auto x : dataArr)
</code></pre>
<h2 id="参考引用可以修改dataarr中的元素但一般用第二种">参考引用，可以修改dataArr中的元素，但一般用第二种</h2>
<pre><code class="language-cpp">for(auto&amp; iter : dataArr)
for(auto&amp;&amp; iter : dataArr)
</code></pre>
<h2 id="只读引用不能修改dataarr中的元素">只读引用，不能修改dataArr中的元素</h2>
<pre><code class="language-cpp">for(const auto&amp; iter : dataArr)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ 类中的构造函数]]></title>
        <id>https://blog.myxy.net/c-lei-zhong-de-gou-zao-han-shu/</id>
        <link href="https://blog.myxy.net/c-lei-zhong-de-gou-zao-han-shu/">
        </link>
        <updated>2020-12-16T11:33:37.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/explicitly-defaulted-and-deleted-functions?view=msvc-160">https://docs.microsoft.com/zh-cn/cpp/cpp/explicitly-defaulted-and-deleted-functions?view=msvc-160</a></p>
<h2 id="编译器默认为一个类生成的默认函数">编译器默认为一个类生成的默认函数</h2>
<ul>
<li>默认构造函数</li>
<li>默认析构函数</li>
<li>默认拷贝构造函数</li>
<li>默认赋值函数</li>
<li>移动构造函数</li>
<li>移动拷贝函数</li>
</ul>
<pre><code class="language-cpp">class DataOnly {
public:
    DataOnly ()                  // 默认构造函数
    ~DataOnly ()                 // 默认析构函数

    DataOnly (const DataOnly &amp; rhs)         　 　  // 默认拷贝构造函数
    DataOnly &amp; operator=(const DataOnly &amp; rhs)    // 默认赋值函数

    DataOnly (const DataOnly &amp;&amp; rhs)         // C++11, 移动构造函数
    DataOnly &amp; operator=(DataOnly &amp;&amp; rhs)    // C++11, 移动拷贝函数
};
</code></pre>
<p>类不可复制的通用写法</p>
<pre><code class="language-cpp">struct noncopyable
{
  noncopyable() =default;
  noncopyable(const noncopyable&amp;) =delete;
  noncopyable&amp; operator=(const noncopyable&amp;) =delete;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[hpSocket线程池]]></title>
        <id>https://blog.myxy.net/hpsocket-xian-cheng-chi/</id>
        <link href="https://blog.myxy.net/hpsocket-xian-cheng-chi/">
        </link>
        <updated>2020-12-10T02:50:46.000Z</updated>
        <content type="html"><![CDATA[<p>HP-Socket v5.4.x版本开始，提供线程池组件IHPThreadPool，协助用户实现通信逻辑与业务逻辑分离，提高应用程序的整体执行效率。IHPThreadPool提供以下主要操作方法。这些方法成功返回TRUE，失败返回FALSE，失败可通过SYS_GetLastError() 获取系统错误代码。</p>
<h2 id="启动线程池">启动线程池</h2>
<pre><code class="language-cpp">BOOL Start(dwThreadCount = 0, dwMaxQueueSize = 0, enRejectedPolicy = TRP_CALL_FAIL, dwStackSize = 0)

dwThreadCount  线程数量，（默认：0）
&gt;0 ：dwThreadCount
=0 ：(CPU核数 * 2 + 2)
&lt;0 ：(CPU核数 * (-dwThreadCount))
dwMaxQueueSize  任务队列最大容量（默认：0，不限制）
enRejectedPolicy  任务拒绝处理策略
TRP_CALL_FAIL	：（默认）立刻返回失败
TRP_WAIT_FOR	：等待（直到成功、超时或线程池关闭等原因导致失败）
TRP_CALLER_RUN	：调用者线程直接执行
dwStackSize  线程堆栈空间大小（默认：0 -&gt; 操作系统默认）
</code></pre>
<h2 id="关闭线程池">关闭线程池</h2>
<blockquote>
<p>在规定时间内关闭线程池组件，如果工作线程在最大等待时间内未能正常关闭，会尝试强制关闭，这种情况下很可能会造成系统资源泄漏。</p>
</blockquote>
<pre><code class="language-cpp">BOOL Stop(dwMaxWait = INFINITE)

dwMaxWait  最大等待时间（毫秒，默认：INFINITE，一直等待）
</code></pre>
<h2 id="提交任务">提交任务</h2>
<pre><code class="language-cpp">BOOL Sbumit(fnTaskProc, pvArg, dwMaxWait = INFINITE)

fnTaskProc  任务处理函数
pvArg  任务参数
dwMaxWait  任务提交最大等待时间（仅对TRP_WAIT_FOR类型线程池生效，默认：INFINITE，一直等待）。
** SYS_GetLastError() 错误码ERROR_DESTINATION_ELEMENT_FULL表示任务队列已满。
</code></pre>
<h2 id="提交socket任务">提交Socket任务</h2>
<pre><code class="language-cpp">BOOL Sbumit(pTask, dwMaxWait = INFINITE)

pTask  任务参数
dwMaxWait  任务提交最大等待时间（仅对TRP_WAIT_FOR类型线程池生效，默认：INFINITE，一直等待）
** SYS_GetLastError() 错误码ERROR_DESTINATION_ELEMENT_FULL表示任务队列已满。
</code></pre>
<h2 id="动态调整线程池大小">动态调整线程池大小</h2>
<pre><code class="language-cpp">BOOL AdjustThreadCount(dwNewThreadCount)

dwNewThreadCount  线程数量
&gt;0 ：dwNewThreadCount
=0 ：(CPU核数 * 2 + 2)
&lt;0 ：(CPU核数 * (-dwNewThreadCount))
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[thread_local 线程本地数据]]></title>
        <id>https://blog.myxy.net/thread_local-xian-cheng-ben-di-shu-ju/</id>
        <link href="https://blog.myxy.net/thread_local-xian-cheng-ben-di-shu-ju/">
        </link>
        <updated>2020-12-04T13:39:07.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/y396397735/article/details/81271339">https://blog.csdn.net/y396397735/article/details/81271339</a></p>
<pre><code class="language-cpp">
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;

std::mutex coutMutex;

thread_local std::string s(&quot;hello from &quot;);

void addThreadLocal(std::string const&amp; s2){

  s+=s2;
  // protect std::cout
  std::lock_guard&lt;std::mutex&gt; guard(coutMutex);
  std::cout &lt;&lt; s &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;&amp;s: &quot; &lt;&lt; &amp;s &lt;&lt; std::endl;
  std::cout &lt;&lt; std::endl;

}

int main(){

  std::cout &lt;&lt; std::endl;

  std::thread t1(addThreadLocal,&quot;t1&quot;); 
  std::thread t2(addThreadLocal,&quot;t2&quot;); 
  std::thread t3(addThreadLocal,&quot;t3&quot;); 
  std::thread t4(addThreadLocal,&quot;t4&quot;); 

  t1.join();
  t2.join();
  t3.join();
  t4.join();

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11之重写说明符override和final]]></title>
        <id>https://blog.myxy.net/c11-zhi-chong-xie-shuo-ming-fu-override-he-final/</id>
        <link href="https://blog.myxy.net/c11-zhi-chong-xie-shuo-ming-fu-override-he-final/">
        </link>
        <updated>2020-12-01T13:12:46.000Z</updated>
        <content type="html"><![CDATA[<p>c++11引入关键字 <code>override</code>和<code>final</code> 用来解决继承中虚函数的问题。</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>override</td>
<td style="text-align:left">指明该函数是重载的基类中的一个函数</td>
</tr>
<tr>
<td>final</td>
<td style="text-align:left">A.禁止该函数从基类继承；B.禁止该函数的重载</td>
</tr>
</tbody>
</table>
<p>注意: 这俩关键字 必须作用于虚函数。否则，编译提示将出错。</p>
<ul>
<li>错误示范</li>
</ul>
<pre><code class="language-cpp">class case_err
{
public:
      // 错误，编译器提示： error C3668: “case_err::name()”: 包含重写说明符“override”的方法没有重写任何基类方法
      void name() override {}      

      // error C3609: “demo_class::gender”: “final”函数必须是虚函数
      void gender() final {}
};
</code></pre>
<ul>
<li>正确用法</li>
</ul>
<pre><code class="language-cpp">// 基类
class base_class
{
public:
	// 用作测试 override 关键字的函数
	virtual void show()  { std::cout &lt;&lt; &quot;base_class::show()\n&quot;; }
	
	// 用作测试 final 关键字的函数
	virtual void say() final { std::cout &lt;&lt; &quot;base_class::say()\n&quot;; }
};

// 派生类
class demo_class : public base_class
{
public:
	// override的作用：指明该函数时重载的基类中的一个函数
	// 这里明确指明该函数是继承基类的show函数
	virtual void show() override { std::cout &lt;&lt; &quot;demo_class::show()\n&quot;; }

	// 编译错误： error C3248: “base_class::say”: 声明为“final”的函数无法被“demo_class::say”重写
	// virtual void say() override { std::cout &lt;&lt; &quot;demo_class::say()\n&quot;; }
};
</code></pre>
<p>纯虚函数一种特殊的虚函数。 but，纯虚函数通常用作基类定义接口。 显然，纯虚函数不能使用关键字override. 那 final 关键字呢? 一个例子：</p>
<pre><code class="language-cpp">class base_class
{
public:
	virtual void run() final = 0;
};
</code></pre>
<p>理论分析： 纯虚函数 run 使用关键字 final后，run函数不能被派生类（子类）继承并实现，且语法也正确。 实际： 编译通过。<br>
but，类base_class及继承自base_class的类均无法创建对象。因为： base_class的run函数是一个纯虚函数且无法被派生类继承。结论： 纯虚函数使用final关键字，无实际意义。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[fn-log]]></title>
        <id>https://blog.myxy.net/fn-log/</id>
        <link href="https://blog.myxy.net/fn-log/">
        </link>
        <updated>2020-11-27T02:40:54.000Z</updated>
        <content type="html"><![CDATA[<p>文件名支持变量:</p>
<pre><code>$PNAME      // 进程名
$PID            // 进程ID
$YEAR              // 年
$MON             // 月
$DAY               // 日
$HOUR            // 小时
$MIN               // 分钟
$SEC                // 秒
</code></pre>
]]></content>
    </entry>
</feed>